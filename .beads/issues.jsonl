{"id":"clipboard-0nf","title":"ClipStack v1.1 Upgrade - Comprehensive Enhancement Suite","status":"open","priority":1,"issue_type":"epic","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:27:55.937476986-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T12:27:55.937476986-05:00"}
{"id":"clipboard-0nf.2","title":"Integration test: Daemon + Picker + Storage interaction","description":"Create integration test (tests/integration/test_component_interaction.sh) verifying daemon+picker+storage component interaction. Tests:\n\nCOMPONENT BOUNDARY SCENARIOS:\n1. Daemon saves → Picker sees immediately\n   - Start daemon, copy text via wl-copy\n   - Open picker within 500ms, verify entry visible\n   \n2. Picker changes → Daemon respects\n   - Open picker, delete entry, close picker\n   - Daemon next poll should see deletion (verify file removed)\n   \n3. Atomic writes during concurrent access\n   - Start daemon, open picker\n   - Rapidly copy 100 items while navigating picker\n   - Verify: No corruption, no .tmp files remaining\n   \n4. Lock file prevents multiple daemons\n   - Start daemon, try to start second\n   - Verify: Second exits with \"already running\" message\n   \n5. Graceful handling when daemon stops\n   - Open picker, stop daemon (kill -TERM)\n   - Navigate in picker (should work, just no new entries)\n   - Copy action should succeed (calls wl-copy directly)\n\nRACE CONDITION TESTS:\n6. Simultaneous pin toggle from two processes\n   - Use flock or similar to test contention\n   - Verify: No corruption, one wins\n\nLOGGING: Same format as E2E tests\nCLEANUP: Temp data dir, kill any stray daemon processes\nEXIT: 0 if all pass, 1 if any fail","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T13:30:27.608504769-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T14:09:54.411050415-05:00","dependencies":[{"issue_id":"clipboard-0nf.2","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T13:30:27.610420482-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.2","depends_on_id":"clipboard-8u5","type":"blocks","created_at":"2026-01-13T14:01:13.313961839-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-0nf.3","title":"Integration test: All v1.1 features work together","description":"Create comprehensive integration test (tests/integration/test_v11_features.sh) that verifies all v1.1 features work correctly together. Tests:\n\nCROSS-FEATURE SCENARIOS:\n1. Configurable limits + Pinned entries\n   - Set max_entries=20, pin 5 entries, add 25 more\n   - Verify: 25 total (5 pinned + 20 unpinned), oldest unpinned pruned\n   \n2. Full content search + Pinned entries\n   - Pin entry with deep content match, search for it\n   - Verify: Found with ★ indicator AND [+] content match indicator\n   \n3. Preview scrolling + Long pinned entries\n   - Pin entry with 500 lines, scroll to line 200\n   - Verify: Scroll works, ★ indicator persists\n   \n4. Atomic writes + Pin toggle\n   - Toggle pin during simulated crash (kill -9 during write)\n   - Verify: Either old or new state (no corruption)\n   \n5. Recovery + Pinned entries\n   - Corrupt index with pinned entries, run recover\n   - Verify: Recovered entries have pinned=false (expected)\n   \n6. All features respect max_entries configuration\n   - Test with CLI flag, env var, and default\n   - Verify: All features obey configured limit\n\nLOGGING: Same format as E2E tests (colored, numbered, summary)\nCLEANUP: Temp data dir per test\nEXIT: 0 if all pass, 1 if any fail","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T16:27:31.018993447-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T16:27:31.018993447-05:00","dependencies":[{"issue_id":"clipboard-0nf.3","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T16:27:31.024296507-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.3","depends_on_id":"clipboard-tsd.22","type":"blocks","created_at":"2026-01-13T16:27:37.636439047-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.3","depends_on_id":"clipboard-8u5.17","type":"blocks","created_at":"2026-01-13T16:27:37.736488745-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.3","depends_on_id":"clipboard-b6y.27","type":"blocks","created_at":"2026-01-13T16:27:37.835605427-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.3","depends_on_id":"clipboard-2wl.21","type":"blocks","created_at":"2026-01-13T16:27:37.926999467-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.3","depends_on_id":"clipboard-pve.24","type":"blocks","created_at":"2026-01-13T16:27:38.022651371-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl","title":"Improvement #1: Full Content Search","description":"HIGHEST IMPACT improvement. Currently search only matches 100-char preview, missing content buried deeper. User copies 500-line file, searches for function name on line 247 - search finds nothing! This undermines core value prop. Solution: two-phase search - Phase 1 searches previews (fast), Phase 2 loads and searches full content for non-matches. Visual indicator [+] shows content-only matches.","status":"closed","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:35:25.658108397-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:20:24.415433195Z","closed_at":"2026-01-13T22:20:24.415433195Z","close_reason":"Full content search feature complete: FilteredEntry type, MatchLocation enum, two-phase search (preview + content), UI updates with match indicators, comprehensive unit tests, and E2E tests. All tests pass.","dependencies":[{"issue_id":"clipboard-2wl","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:36:36.790625926-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.16","title":"Add FilteredEntry type and MatchLocation enum","description":"## Overview\nAdd the core data structures for full content search in src/picker.rs.\n\n## Implementation Details\n\n### MatchLocation Enum\n```rust\n#[derive(Clone, Copy, PartialEq)]\nenum MatchLocation {\n    Preview,   // Match found in preview (fast path)\n    Content,   // Match found in full content (required loading)\n}\n```\n\n### FilteredEntry Struct\n```rust\nstruct FilteredEntry {\n    index: usize,           // Index into original entries list\n    score: i64,             // Fuzzy match score (higher = better)\n    match_location: MatchLocation,  // Where match was found\n}\n```\n\n## Key Design Decisions\n- FilteredEntry wraps index instead of cloning ClipEntry (memory efficient)\n- MatchLocation tracks search phase for UX feedback\n- Score uses i64 to accommodate fuzzy-matcher scoring range\n\n## Files to Modify\n- src/picker.rs: Add types after imports, before PickerState\n\n## Acceptance Criteria\n- [ ] MatchLocation enum with Preview and Content variants\n- [ ] FilteredEntry struct with index, score, match_location fields\n- [ ] Both types derive necessary traits (Clone, Copy for enum)\n- [ ] Code compiles without warnings","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:41:09.741655568-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:03:35.290236328Z","closed_at":"2026-01-13T22:03:35.290236328Z","close_reason":"MatchLocation enum and FilteredEntry struct added to picker.rs - compiles","dependencies":[{"issue_id":"clipboard-2wl.16","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:41:09.743205212-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.17","title":"Implement two-phase search with scoring","description":"## Overview\nImplement the two-phase search algorithm in PickerState that searches preview first (fast), then falls back to full content search (lazy-loaded).\n\n## Implementation Details\n\n### Phase 1: Preview Search (Fast Path)\n```rust\nfn filter_entries(\u0026mut self, query: \u0026str, storage: \u0026Storage) -\u003e Vec\u003cFilteredEntry\u003e {\n    let matcher = SkimMatcherV2::default();\n    let mut results: Vec\u003cFilteredEntry\u003e = Vec::new();\n    \n    // Phase 1: Search previews (always available, fast)\n    for (idx, entry) in self.entries.iter().enumerate() {\n        if let Some((score, _)) = matcher.fuzzy_match(\u0026entry.preview, query) {\n            results.push(FilteredEntry {\n                index: idx,\n                score,\n                match_location: MatchLocation::Preview,\n            });\n        }\n    }\n    // ... continues to Phase 2\n}\n```\n\n### Phase 2: Content Search (Lazy Load)\n```rust\n    // Phase 2: For entries not matched in preview, search full content\n    let preview_matched: HashSet\u003cusize\u003e = results.iter().map(|r| r.index).collect();\n    \n    for (idx, entry) in self.entries.iter().enumerate() {\n        if preview_matched.contains(\u0026idx) {\n            continue;  // Already matched in preview\n        }\n        \n        // Lazy load content only when needed\n        if let Ok(content) = storage.load_content(\u0026entry.id) {\n            if let Some((score, _)) = matcher.fuzzy_match(\u0026content, query) {\n                results.push(FilteredEntry {\n                    index: idx,\n                    score,\n                    match_location: MatchLocation::Content,\n                });\n            }\n        }\n    }\n    \n    // Sort by score descending\n    results.sort_by(|a, b| b.score.cmp(\u0026a.score));\n    results\n}\n```\n\n## Key Design Decisions\n- Use HashSet for O(1) lookup of already-matched indices\n- Only load content for entries that did not match preview\n- Sort results by score for relevance ranking\n- Gracefully handle content load failures (skip entry)\n\n## Dependencies\n- Requires fuzzy-matcher crate: fuzzy-matcher = \"0.3\"\n- Use SkimMatcherV2 for sublime-text-like fuzzy matching\n\n## Files to Modify\n- src/picker.rs: Add filter_entries method to PickerState impl\n- Cargo.toml: Add fuzzy-matcher dependency if not present\n\n## Acceptance Criteria\n- [ ] filter_entries method implemented with two-phase search\n- [ ] Preview matches found without loading content\n- [ ] Content search only triggers for non-preview-matched entries\n- [ ] Results sorted by score descending\n- [ ] fuzzy-matcher dependency added to Cargo.toml","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:41:25.261377852-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:15:00.374955026Z","closed_at":"2026-01-13T22:15:00.374955026Z","close_reason":"Implemented two-phase search with scoring: Phase 1 searches previews (fast), Phase 2 lazy-loads full content for non-preview matches. Added filter_entries(), get_match_location() helper, and filtered_entries field for tracking match metadata","dependencies":[{"issue_id":"clipboard-2wl.17","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:41:25.263168267-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.17","depends_on_id":"clipboard-2wl.16","type":"blocks","created_at":"2026-01-13T15:42:44.887356442-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.18","title":"Update Picker UI for filtered search mode","description":"## Overview\nIntegrate the two-phase search into the Picker event loop, managing filtered state and search input.\n\n## Implementation Details\n\n### Add PickerState Fields\n```rust\nstruct PickerState {\n    // Existing fields...\n    filter_query: String,           // Current search query\n    filtered: Vec\u003cFilteredEntry\u003e,   // Current filtered results\n    in_filter_mode: bool,           // Whether actively filtering\n}\n```\n\n### Search Mode Entry (/ key)\n```rust\nKeyCode::Char('/') if \\!self.in_filter_mode =\u003e {\n    self.in_filter_mode = true;\n    self.filter_query.clear();\n    self.filtered = self.filter_entries(\"\", storage);\n}\n```\n\n### Character Input During Search\n```rust\nif self.in_filter_mode {\n    match key.code {\n        KeyCode::Char(c) =\u003e {\n            self.filter_query.push(c);\n            self.filtered = self.filter_entries(\u0026self.filter_query, storage);\n            self.selected = 0;  // Reset selection on query change\n        }\n        KeyCode::Backspace =\u003e {\n            self.filter_query.pop();\n            self.filtered = self.filter_entries(\u0026self.filter_query, storage);\n            self.selected = 0;\n        }\n        KeyCode::Esc =\u003e {\n            self.in_filter_mode = false;\n            self.filter_query.clear();\n            self.filtered.clear();\n        }\n        KeyCode::Enter =\u003e {\n            // Select filtered entry and exit filter mode\n            if let Some(fe) = self.filtered.get(self.selected) {\n                self.selected = fe.index;\n            }\n            self.in_filter_mode = false;\n            // Continue with normal Enter handling...\n        }\n        _ =\u003e {}\n    }\n}\n```\n\n### Selection Index Translation\nWhen in filter mode, selection indexes into filtered list, not entries:\n```rust\nfn current_entry(\u0026self) -\u003e Option\u003c\u0026ClipEntry\u003e {\n    if self.in_filter_mode \u0026\u0026 \\!self.filtered.is_empty() {\n        self.filtered.get(self.selected)\n            .and_then(|fe| self.entries.get(fe.index))\n    } else {\n        self.entries.get(self.selected)\n    }\n}\n```\n\n## Key Design Decisions\n- / key enters filter mode (vi-style)\n- Esc exits filter mode and clears query\n- Enter in filter mode selects entry AND exits filter mode\n- Selection resets to 0 when query changes for consistency\n- Up/Down navigate filtered results, not full list\n\n## Files to Modify\n- src/picker.rs: Update PickerState struct, handle_event, current_entry\n\n## Acceptance Criteria\n- [ ] PickerState has filter_query, filtered, in_filter_mode fields\n- [ ] / key enters search mode\n- [ ] Character input updates query and re-filters\n- [ ] Backspace removes last character\n- [ ] Esc exits filter mode\n- [ ] Enter selects filtered entry\n- [ ] Navigation works on filtered list when in filter mode","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:41:43.264912527-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:15:17.831155776Z","closed_at":"2026-01-13T22:15:17.831155776Z","close_reason":"All UI functionality already implemented: search_query, mode, filtered_entries fields; / for search; char input; backspace; esc; enter; navigation","dependencies":[{"issue_id":"clipboard-2wl.18","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:41:43.266764277-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.18","depends_on_id":"clipboard-2wl.17","type":"blocks","created_at":"2026-01-13T15:42:44.926351185-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.19","title":"Update rendering for search mode and match indicators","description":"## Overview\nUpdate the Picker rendering to display search query input, match count, and indicate where matches were found.\n\n## Implementation Details\n\n### Title Bar with Search Query\n```rust\nfn render_title(\u0026self) -\u003e String {\n    if self.in_filter_mode {\n        format\\!(\"ClipStack - Search: {}_\", self.filter_query)\n    } else {\n        format\\!(\"ClipStack ({} entries)\", self.entries.len())\n    }\n}\n```\n\n### Match Count Status\n```rust\nfn render_status(\u0026self) -\u003e String {\n    if self.in_filter_mode {\n        let content_matches = self.filtered.iter()\n            .filter(|fe| fe.match_location == MatchLocation::Content)\n            .count();\n        if content_matches \u003e 0 {\n            format\\!(\"{} matches ({} in content)\", self.filtered.len(), content_matches)\n        } else {\n            format\\!(\"{} matches\", self.filtered.len())\n        }\n    } else {\n        // Normal status...\n    }\n}\n```\n\n### Match Location Indicator\nShow indicator when match is in content (not preview):\n```rust\nfn render_list_item(\u0026self, fe: \u0026FilteredEntry, entry: \u0026ClipEntry) -\u003e String {\n    let indicator = match fe.match_location {\n        MatchLocation::Preview =\u003e \"\",\n        MatchLocation::Content =\u003e \"[content] \",\n    };\n    format\\!(\"{}{}\", indicator, entry.preview)\n}\n```\n\n### Search Help Text\nShow keybindings in footer during search:\n```rust\nfn render_help(\u0026self) -\u003e String {\n    if self.in_filter_mode {\n        \"Type to search | Enter: select | Esc: cancel\"\n    } else {\n        \"/: search | Enter: paste | d: delete | q: quit\"\n    }\n}\n```\n\n## Key Design Decisions\n- Cursor indicator (_) shows active input\n- Match count helps user know search is working\n- Content match indicator distinguishes deep matches\n- Help text changes contextually for discoverability\n\n## Files to Modify\n- src/picker.rs: Update render methods\n\n## Acceptance Criteria\n- [ ] Title shows search query with cursor indicator\n- [ ] Status shows match count\n- [ ] Status shows content match count when \u003e 0\n- [ ] List items show [content] indicator for content matches\n- [ ] Help text shows search-mode keybindings","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:41:59.443663978-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:19:04.844968545Z","closed_at":"2026-01-13T22:19:04.844968545Z","close_reason":"Rendering updated: [content] indicator for deep matches, content match count in title, search query display","dependencies":[{"issue_id":"clipboard-2wl.19","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:41:59.44544212-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.19","depends_on_id":"clipboard-2wl.18","type":"blocks","created_at":"2026-01-13T15:42:44.965043913-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.20","title":"Unit tests for full content search","description":"## Overview\nComprehensive unit test suite for the full content search functionality in storage.rs and picker.rs.\n\n## Test Cases\n\n### FilteredEntry Type Tests\n```rust\n#[test]\nfn test_filtered_entry_creation() {\n    let fe = FilteredEntry {\n        index: 5,\n        score: 100,\n        match_location: MatchLocation::Preview,\n    };\n    assert_eq\\!(fe.index, 5);\n    assert_eq\\!(fe.score, 100);\n    assert_eq\\!(fe.match_location, MatchLocation::Preview);\n}\n\n#[test]\nfn test_match_location_equality() {\n    assert_eq\\!(MatchLocation::Preview, MatchLocation::Preview);\n    assert_eq\\!(MatchLocation::Content, MatchLocation::Content);\n    assert_ne\\!(MatchLocation::Preview, MatchLocation::Content);\n}\n```\n\n### Search Algorithm Tests\n```rust\n#[test]\nfn test_preview_match_found_without_content_load() {\n    // Entry with \"hello world\" preview should match \"hello\"\n    // Verify content was NOT loaded (track load_content calls)\n}\n\n#[test]\nfn test_content_search_finds_non_preview_match() {\n    // Entry with truncated preview but full content containing search term\n    // Should find match with MatchLocation::Content\n}\n\n#[test]\nfn test_search_results_sorted_by_score() {\n    // Multiple matches with different scores\n    // Verify returned in score descending order\n}\n\n#[test]\nfn test_empty_query_returns_all_entries() {\n    // Empty string query should return all entries\n}\n\n#[test]\nfn test_no_matches_returns_empty() {\n    // Query with no matches returns empty vec\n}\n\n#[test]\nfn test_preview_match_prioritized_over_content() {\n    // Same entry matches in both preview and content\n    // Should only appear once with Preview location\n}\n```\n\n### Search UI State Tests\n```rust\n#[test]\nfn test_filter_mode_entry_exit() {\n    // / enters filter mode, Esc exits\n}\n\n#[test]\nfn test_query_updates_filtered_results() {\n    // Typing characters updates filtered list\n}\n\n#[test]\nfn test_backspace_removes_character() {\n    // Backspace shrinks query\n}\n\n#[test]\nfn test_selection_resets_on_query_change() {\n    // Selection goes to 0 when query changes\n}\n```\n\n## Test Utilities\n```rust\nfn create_test_entries(storage: \u0026Storage, contents: \u0026[\u0026str]) -\u003e Vec\u003cClipEntry\u003e {\n    contents.iter().map(|c| storage.save_entry(c).unwrap()).collect()\n}\n```\n\n## Files to Modify\n- src/picker.rs: Add #[cfg(test)] mod tests with search tests\n\n## Acceptance Criteria\n- [ ] All FilteredEntry type tests pass\n- [ ] All search algorithm tests pass\n- [ ] All UI state tests pass\n- [ ] Tests use real storage with tempfile for content loading\n- [ ] No flaky tests (deterministic results)","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:42:18.27505543-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:19:00.999043768Z","closed_at":"2026-01-13T22:19:00.999043768Z","close_reason":"Added 13 comprehensive unit tests for full content search: FilteredEntry type tests, search algorithm tests (preview match, content match, sorting by score, empty query, no matches, deduplication), UI state tests (get_match_location, selection reset, fuzzy matching, case insensitivity). All tests pass.","dependencies":[{"issue_id":"clipboard-2wl.20","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:42:18.27680043-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.20","depends_on_id":"clipboard-2wl.16","type":"blocks","created_at":"2026-01-13T15:42:45.006284415-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.21","title":"E2E tests for full content search","description":"## Overview\nEnd-to-end test script for full content search functionality using real clipboard operations.\n\n## Test Script: tests/e2e_search.sh\n\n```bash\n#\\!/bin/bash\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" \u0026\u0026 pwd)\"\nPROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"\nBINARY=\"$PROJECT_ROOT/target/release/clipstack\"\nTEST_DIR=$(mktemp -d)\ntrap \"rm -rf $TEST_DIR\" EXIT\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\npass() { echo -e \"${GREEN}✓ PASS${NC}: $1\"; }\nfail() { echo -e \"${RED}✗ FAIL${NC}: $1\"; exit 1; }\ninfo() { echo -e \"${YELLOW}INFO${NC}: $1\"; }\n\n# Build release binary\ninfo \"Building release binary...\"\ncargo build --release --manifest-path=\"$PROJECT_ROOT/Cargo.toml\"\n\n# Test 1: Search finds preview match\ninfo \"Test 1: Search finds preview match\"\necho \"unique_preview_text here\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n# Use expect/interact for picker or test via index\nINDEX=\"$TEST_DIR/index.json\"\nif grep -q \"unique_preview_text\" \"$INDEX\"; then\n    pass \"Preview text stored correctly\"\nelse\n    fail \"Preview text not found in index\"\nfi\n\n# Test 2: Search finds content-only match  \ninfo \"Test 2: Search finds content-only match\"\n# Create entry where search term is beyond preview length (100 chars)\nLONG_PREFIX=$(printf 'x%.0s' {1..110})\necho \"${LONG_PREFIX}findme_content_term\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\n# Verify search term is NOT in preview but IS in content file\nif grep -q \"findme_content\" \"$INDEX\"; then\n    fail \"Content-only term should not be in preview\"\nfi\n\n# Find the content file and verify term exists\nCONTENT_FILE=$(ls \"$TEST_DIR\"/*.txt | head -1)\nif grep -q \"findme_content_term\" \"$CONTENT_FILE\"; then\n    pass \"Content-only term stored in file\"\nelse\n    fail \"Content-only term not found in content file\"\nfi\n\n# Test 3: Empty search returns all entries\ninfo \"Test 3: Verify multiple entries stored\"\nENTRY_COUNT=$(jq '.entries | length' \"$INDEX\")\nif [ \"$ENTRY_COUNT\" -ge 2 ]; then\n    pass \"Multiple entries available for search ($ENTRY_COUNT)\"\nelse\n    fail \"Expected at least 2 entries, got $ENTRY_COUNT\"\nfi\n\n# Test 4: Search results are deterministic\ninfo \"Test 4: Verify index structure supports search\"\nif jq -e '.entries[0].preview' \"$INDEX\" \u003e /dev/null; then\n    pass \"Entries have preview field for search\"\nelse\n    fail \"Entries missing preview field\"\nfi\n\necho \"\"\necho -e \"${GREEN}All search E2E tests passed\\!${NC}\"\n```\n\n## Test Scenarios\n1. **Preview Match**: Search term in first 100 chars → found in preview\n2. **Content Match**: Search term beyond preview → requires content load\n3. **Multiple Entries**: Verify search works with multiple entries\n4. **Index Structure**: Verify data structure supports search\n\n## Limitations\n- Cannot test interactive picker in automated tests\n- Tests verify data layer supports search; UI tested via unit tests\n\n## Files to Create\n- tests/e2e_search.sh: E2E test script\n\n## Acceptance Criteria\n- [ ] Script is executable (chmod +x)\n- [ ] All test scenarios pass\n- [ ] Cleanup removes temp directory\n- [ ] Clear pass/fail output with colors\n- [ ] Script exits with non-zero on failure","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:42:39.400152846-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:20:29.550225837Z","closed_at":"2026-01-13T22:20:29.550225837Z","close_reason":"E2E search tests pass: preview match, content-only match, multiple entries, index structure, stats/list commands","dependencies":[{"issue_id":"clipboard-2wl.21","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:42:39.402072443-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.21","depends_on_id":"clipboard-2wl.20","type":"blocks","created_at":"2026-01-13T15:42:45.043871331-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5","title":"Improvement #3: Atomic File Writes","description":"CRITICAL reliability fix - current fs::write() is NOT atomic. If interrupted mid-write (Ctrl+C, crash, power loss), files can be corrupted: truncated JSON, partial data, or empty files. This violates ClipStack's core promise of 'never lose clipboard history'. Solution: implement write-to-temp-then-rename pattern with fsync. The rename() syscall is atomic on POSIX filesystems. Also adds cleanup of orphaned temp files on startup and a recovery command for corrupted storage.","status":"closed","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:28:52.871570748-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:12:14.561804188Z","closed_at":"2026-01-13T22:12:14.561804188Z","close_reason":"Completed all atomic file write features: atomic_write() helper with fsync, temp file cleanup on startup, recovery command for corrupted storage, unit tests, and E2E tests. All 32 unit tests pass and E2E tests pass.","dependencies":[{"issue_id":"clipboard-8u5","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:30:09.313812816-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.12","title":"[#3] Implement atomic_write() helper method","description":"## Overview\nImplement the core write-then-rename pattern that guarantees atomic file operations.\n\n## Code Changes in src/storage.rs\n\n```rust\nuse std::io::Write;\n\nimpl Storage {\n    /// Atomically write data to a file using write-then-rename pattern.\n    /// \n    /// This guarantees that file writes are atomic:\n    /// 1. Write to temporary file (.tmp extension)\n    /// 2. fsync() to ensure data is on disk\n    /// 3. Atomic rename() to final path\n    /// 4. fsync() parent directory for full durability\n    /// \n    /// If interrupted at any point, the original file remains intact.\n    fn atomic_write(\u0026self, path: \u0026Path, data: \u0026[u8]) -\u003e Result\u003c()\u003e {\n        let tmp_path = path.with_extension(\"tmp\");\n        \n        // Step 1: Write to temporary file\n        let mut file = fs::File::create(\u0026tmp_path)\n            .with_context(|| format!(\"Failed to create temp file: {:?}\", tmp_path))?;\n        \n        file.write_all(data)\n            .with_context(|| format!(\"Failed to write temp file: {:?}\", tmp_path))?;\n        \n        // Step 2: Ensure data is flushed to disk\n        file.sync_all()\n            .with_context(|| format!(\"Failed to sync temp file: {:?}\", tmp_path))?;\n        \n        // Step 3: Close file before rename (required on some platforms)\n        drop(file);\n        \n        // Step 4: Atomic rename (POSIX guarantees atomicity)\n        fs::rename(\u0026tmp_path, path)\n            .with_context(|| format!(\"Failed to rename {:?} to {:?}\", tmp_path, path))?;\n        \n        // Step 5: Sync parent directory for full durability\n        if let Some(parent) = path.parent() {\n            if let Ok(dir) = fs::File::open(parent) {\n                let _ = dir.sync_all();\n            }\n        }\n        \n        Ok(())\n    }\n}\n```\n\n## Why This Pattern\n- fs::write() truncates file BEFORE writing - crash = data loss\n- rename() is atomic on POSIX filesystems (ext4, btrfs, APFS, HFS+, NTFS)\n- If crash during write to .tmp, original file untouched\n- If crash during rename, operation either completes or doesn't (no corruption)\n\n## Files Changed\n- src/storage.rs: Add atomic_write() method\n\n## Acceptance Criteria\n- [ ] atomic_write() method compiles\n- [ ] Uses .tmp extension for temp file\n- [ ] Calls sync_all() before rename\n- [ ] Handles parent directory sync","status":"closed","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:24:57.271976987-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:03:17.734519657Z","closed_at":"2026-01-13T22:03:17.734519657Z","close_reason":"Implemented atomic_write() helper with write-then-rename pattern, fsync, and directory sync. Added 3 unit tests.","dependencies":[{"issue_id":"clipboard-8u5.12","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:24:57.273798625-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.13","title":"[#3] Update save_index() and save_entry() to use atomic_write()","description":"## Overview\nReplace all non-atomic fs::write() calls with the new atomic_write() method.\n\n## Code Changes in src/storage.rs\n\n### Update save_index()\n```rust\nimpl Storage {\n    pub fn save_index(\u0026self, index: \u0026ClipIndex) -\u003e Result\u003c()\u003e {\n        let path = self.index_path();\n        let data = serde_json::to_string_pretty(index)?;\n        self.atomic_write(\u0026path, data.as_bytes())  // CHANGED from fs::write()\n    }\n}\n```\n\n### Update save_entry() content file writing\nIn save_entry(), find the fs::write() call for content files and replace:\n\n```rust\n// BEFORE (non-atomic):\nfs::write(\u0026content_path, content.as_bytes())\n    .with_context(|| format!(\"Failed to write content: {:?}\", content_path))?;\n\n// AFTER (atomic):\nself.atomic_write(\u0026content_path, content.as_bytes())\n    .with_context(|| format!(\"Failed to write content: {:?}\", content_path))?;\n```\n\n## Critical Change\nThis protects BOTH critical storage files:\n1. index.json - entry metadata (most critical)\n2. *.txt content files - actual clipboard content\n\n## Files Changed\n- src/storage.rs: Update save_index() and save_entry()\n\n## Acceptance Criteria\n- [ ] save_index() uses atomic_write()\n- [ ] save_entry() uses atomic_write() for content files\n- [ ] All tests still pass\n- [ ] No direct fs::write() calls remain for storage files","status":"closed","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:25:03.717866535-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:03:19.898642495Z","closed_at":"2026-01-13T22:03:19.898642495Z","close_reason":"save_index() and save_entry() already use atomic_write(). Tests pass.","dependencies":[{"issue_id":"clipboard-8u5.13","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:25:03.719689746-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.13","depends_on_id":"clipboard-8u5.12","type":"blocks","created_at":"2026-01-13T15:27:58.514496434-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.14","title":"[#3] Implement temp file cleanup on startup","description":"## Overview\nClean up orphaned .tmp files from interrupted operations when Storage is initialized.\n\n## Code Changes in src/storage.rs\n\n### Add cleanup method\n```rust\nimpl Storage {\n    /// Clean up orphaned temp files from interrupted operations\n    fn cleanup_temp_files(\u0026self) -\u003e Result\u003c()\u003e {\n        if let Ok(entries) = fs::read_dir(\u0026self.base_dir) {\n            for entry in entries.flatten() {\n                let path = entry.path();\n                if path.extension().map_or(false, |ext| ext == \"tmp\") {\n                    eprintln!(\"[cleanup] Removing orphaned temp file: {:?}\", path);\n                    let _ = fs::remove_file(\u0026path);\n                }\n            }\n        }\n        Ok(())\n    }\n}\n```\n\n### Call in Storage::new()\n```rust\nimpl Storage {\n    pub fn new(base_dir: PathBuf, max_entries: usize) -\u003e Result\u003cSelf\u003e {\n        fs::create_dir_all(\u0026base_dir)\n            .with_context(|| format!(\"Failed to create storage dir: {:?}\", base_dir))?;\n        \n        let max_entries = max_entries.clamp(1, ABSOLUTE_MAX_ENTRIES);\n        let storage = Self { base_dir, max_entries };\n        \n        // Clean up any orphaned temp files from interrupted operations\n        storage.cleanup_temp_files()?;\n        \n        storage.sync_max_entries()?;\n        Ok(storage)\n    }\n}\n```\n\n## When This Helps\n- User hits Ctrl+C during clipboard save\n- System crash during write operation\n- Power failure during daemon operation\n- Left over .tmp files from any interruption\n\n## Files Changed\n- src/storage.rs: Add cleanup_temp_files(), call in new()\n\n## Acceptance Criteria\n- [ ] cleanup_temp_files() removes .tmp files\n- [ ] Called during Storage initialization\n- [ ] Logs removed files to stderr\n- [ ] Doesn't fail if no temp files exist","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:25:14.821350807-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:04:52.69418137Z","closed_at":"2026-01-13T22:04:52.69418137Z","close_reason":"cleanup_temp_files() already implemented and called in Storage::new()","dependencies":[{"issue_id":"clipboard-8u5.14","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:25:14.823113634-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.14","depends_on_id":"clipboard-8u5.12","type":"blocks","created_at":"2026-01-13T15:27:58.551763127-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.15","title":"[#3] Implement attempt_recovery() method and Recover CLI command","description":"## Overview\nAdd recovery functionality that rebuilds index from content files. Useful when index is corrupted.\n\n## Code Changes\n\n### src/storage.rs - Recovery method\n```rust\nimpl Storage {\n    /// Attempt to recover from corrupted storage.\n    /// Rebuilds index from existing content files.\n    pub fn attempt_recovery(\u0026self) -\u003e Result\u003cusize\u003e {\n        eprintln!(\"[recovery] Starting storage recovery...\");\n        \n        let index_path = self.index_path();\n        let mut recovered_entries: Vec\u003cClipEntry\u003e = Vec::new();\n        \n        // Try to load existing index entries first\n        if index_path.exists() {\n            match fs::read_to_string(\u0026index_path) {\n                Ok(data) =\u003e {\n                    match serde_json::from_str::\u003cClipIndex\u003e(\u0026data) {\n                        Ok(index) =\u003e {\n                            eprintln!(\"[recovery] Loaded {} entries from existing index\", \n                                     index.entries.len());\n                            recovered_entries = index.entries;\n                        }\n                        Err(e) =\u003e {\n                            eprintln!(\"[recovery] Index corrupted ({}), scanning files...\", e);\n                        }\n                    }\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"[recovery] Cannot read index ({}), scanning files...\", e);\n                }\n            }\n        }\n        \n        // Collect IDs of entries we already have\n        let known_ids: std::collections::HashSet\u003c_\u003e = \n            recovered_entries.iter().map(|e| e.id.clone()).collect();\n        \n        // Scan for orphaned content files\n        let mut orphan_count = 0;\n        for entry in fs::read_dir(\u0026self.base_dir)? {\n            let entry = entry?;\n            let path = entry.path();\n            \n            if path.extension().map_or(false, |ext| ext == \"txt\") {\n                let id = path.file_stem()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"\").to_string();\n                \n                if known_ids.contains(\u0026id) { continue; }\n                \n                if let Ok(content) = fs::read_to_string(\u0026path) {\n                    let timestamp: i64 = id.parse().unwrap_or(0);\n                    \n                    let mut hasher = Sha256::new();\n                    hasher.update(content.as_bytes());\n                    let hash = format!(\"sha256:{:x}\", hasher.finalize());\n                    \n                    let preview: String = content.chars()\n                        .take(MAX_PREVIEW_LEN)\n                        .map(|c| if c.is_control() { ' ' } else { c })\n                        .collect();\n                    \n                    recovered_entries.push(ClipEntry {\n                        id, timestamp, size: content.len(), \n                        preview, hash, pinned: false,\n                    });\n                    orphan_count += 1;\n                }\n            }\n        }\n        \n        eprintln!(\"[recovery] Found {} orphaned content files\", orphan_count);\n        \n        // Sort by timestamp descending\n        recovered_entries.sort_by(|a, b| b.timestamp.cmp(\u0026a.timestamp));\n        \n        // Deduplicate by hash (keep most recent)\n        let mut seen_hashes = std::collections::HashSet::new();\n        recovered_entries.retain(|e| seen_hashes.insert(e.hash.clone()));\n        \n        let total = recovered_entries.len();\n        eprintln!(\"[recovery] Total entries after dedup: {}\", total);\n        \n        // Save recovered index\n        let index = ClipIndex {\n            max_entries: self.max_entries,\n            entries: recovered_entries,\n        };\n        self.save_index(\u0026index)?;\n        \n        eprintln!(\"[recovery] Recovery complete\");\n        Ok(total)\n    }\n}\n```\n\n### src/main.rs - Add Recover command\n```rust\n#[derive(Subcommand)]\nenum Commands {\n    // ... existing commands ...\n    \n    /// Attempt to recover from corrupted storage\n    Recover,\n}\n\n// In main() match:\nSome(Commands::Recover) =\u003e {\n    match storage.attempt_recovery() {\n        Ok(count) =\u003e {\n            println!(\"Recovery complete. Recovered {} entries.\", count);\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Recovery failed: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add attempt_recovery()\n- src/main.rs: Add Recover command variant and handler\n\n## Acceptance Criteria\n- [ ] attempt_recovery() rebuilds index from .txt files\n- [ ] Handles corrupted JSON gracefully\n- [ ] Deduplicates by hash\n- [ ] clipstack recover CLI command works","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:26:58.410770459-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:07:05.106810675Z","closed_at":"2026-01-13T22:07:05.106810675Z","close_reason":"Implemented attempt_recovery() method and Recover CLI command with tests for orphaned files and corrupted index recovery","dependencies":[{"issue_id":"clipboard-8u5.15","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:26:58.412685579-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.15","depends_on_id":"clipboard-8u5.12","type":"blocks","created_at":"2026-01-13T15:27:58.586824506-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.16","title":"[#3] Write comprehensive unit tests for atomic file writes and recovery","description":"## Overview\nTDD: Comprehensive tests for atomic writes, temp cleanup, and recovery.\n\n## Test Cases (copy-paste ready)\n\n```rust\n#[cfg(test)]\nmod atomic_write_tests {\n    use super::*;\n    use tempfile::TempDir;\n    use std::sync::Arc;\n    use std::thread;\n    \n    #[test]\n    fn test_atomic_write_creates_file() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let test_path = dir.path().join(\"test.json\");\n        \n        storage.atomic_write(\u0026test_path, b\"test data\").unwrap();\n        \n        assert!(test_path.exists());\n        assert_eq!(fs::read_to_string(\u0026test_path).unwrap(), \"test data\");\n    }\n    \n    #[test]\n    fn test_atomic_write_no_temp_file_remains() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let test_path = dir.path().join(\"test.json\");\n        \n        storage.atomic_write(\u0026test_path, b\"test data\").unwrap();\n        \n        let tmp_path = test_path.with_extension(\"tmp\");\n        assert!(!tmp_path.exists(), \"Temp file should be removed after write\");\n    }\n    \n    #[test]\n    fn test_atomic_write_overwrites_existing() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let test_path = dir.path().join(\"test.json\");\n        \n        storage.atomic_write(\u0026test_path, b\"initial\").unwrap();\n        assert_eq!(fs::read_to_string(\u0026test_path).unwrap(), \"initial\");\n        \n        storage.atomic_write(\u0026test_path, b\"updated\").unwrap();\n        assert_eq!(fs::read_to_string(\u0026test_path).unwrap(), \"updated\");\n    }\n    \n    #[test]\n    fn test_cleanup_removes_orphaned_temp_files() {\n        let dir = TempDir::new().unwrap();\n        \n        // Create orphaned temp files (simulating interrupted ops)\n        fs::write(dir.path().join(\"index.tmp\"), \"orphaned\").unwrap();\n        fs::write(dir.path().join(\"12345.tmp\"), \"orphaned\").unwrap();\n        fs::write(dir.path().join(\"normal.txt\"), \"keep me\").unwrap();\n        \n        // Storage::new should clean up .tmp files\n        let _storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        \n        assert!(!dir.path().join(\"index.tmp\").exists(), \"index.tmp should be removed\");\n        assert!(!dir.path().join(\"12345.tmp\").exists(), \"12345.tmp should be removed\");\n        assert!(dir.path().join(\"normal.txt\").exists(), \".txt should NOT be removed\");\n    }\n    \n    #[test]\n    fn test_recovery_from_missing_index() {\n        let dir = TempDir::new().unwrap();\n        \n        // Create content files without index\n        fs::write(dir.path().join(\"1000.txt\"), \"content one\").unwrap();\n        fs::write(dir.path().join(\"2000.txt\"), \"content two\").unwrap();\n        \n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let count = storage.attempt_recovery().unwrap();\n        \n        assert_eq!(count, 2);\n        let index = storage.load_index().unwrap();\n        assert_eq!(index.entries.len(), 2);\n    }\n    \n    #[test]\n    fn test_recovery_deduplicates_by_hash() {\n        let dir = TempDir::new().unwrap();\n        \n        // Create content files with same content (same hash)\n        fs::write(dir.path().join(\"1000.txt\"), \"duplicate\").unwrap();\n        fs::write(dir.path().join(\"2000.txt\"), \"duplicate\").unwrap();\n        \n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let count = storage.attempt_recovery().unwrap();\n        \n        // Should keep only one (most recent = 2000)\n        assert_eq!(count, 1);\n    }\n    \n    #[test]\n    fn test_concurrent_saves_dont_corrupt() {\n        let dir = TempDir::new().unwrap();\n        let storage = Arc::new(Storage::new(dir.path().to_path_buf(), 100).unwrap());\n        \n        let mut handles = vec![];\n        for i in 0..10 {\n            let storage = Arc::clone(\u0026storage);\n            handles.push(thread::spawn(move || {\n                storage.save_entry(\u0026format!(\"thread {} content\", i)).unwrap();\n            }));\n        }\n        \n        for handle in handles {\n            handle.join().unwrap();\n        }\n        \n        // All entries should be saved without corruption\n        let index = storage.load_index().unwrap();\n        assert_eq!(index.entries.len(), 10);\n        \n        // Verify index is valid JSON (not corrupted)\n        let json = serde_json::to_string(\u0026index).unwrap();\n        assert!(!json.is_empty());\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add test module\n\n## Acceptance Criteria\n- [ ] All 7 tests pass\n- [ ] Tests run: cargo test atomic_write\n- [ ] Thread safety test verifies no corruption","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:27:37.110814109-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:09:03.207520023Z","closed_at":"2026-01-13T22:09:03.207520023Z","close_reason":"All 7 atomic write tests verified passing: basic, overwrite, large data, concurrent saves, cleanup temp files, recovery from orphaned, recovery with corrupted index","dependencies":[{"issue_id":"clipboard-8u5.16","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:27:37.112738946-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.16","depends_on_id":"clipboard-8u5.12","type":"blocks","created_at":"2026-01-13T15:27:58.623252934-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.17","title":"[#3] Write E2E test script for atomic file writes and recovery","description":"## Overview\nEnd-to-end test script verifying atomic writes and recovery work in practice.\n\n## E2E Test Script (tests/e2e_atomic_writes.sh)\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# E2E Tests for Atomic File Writes and Recovery\n# Run from project root: ./tests/e2e_atomic_writes.sh\n\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nTEST_DIR=$(mktemp -d)\nCLIPSTACK=\"./target/release/clipstack\"\n\nlog_pass() { echo -e \"${GREEN}✓${NC} $1\"; }\nlog_fail() { echo -e \"${RED}✗${NC} $1\"; exit 1; }\nlog_info() { echo -e \"${YELLOW}→${NC} $1\"; }\n\ncleanup() { rm -rf \"$TEST_DIR\"; }\ntrap cleanup EXIT\n\n# Build release if needed\nif [[ ! -f \"$CLIPSTACK\" ]]; then\n    log_info \"Building release binary...\"\n    cargo build --release\nfi\n\nlog_info \"Test directory: $TEST_DIR\"\n\n# Test 1: No temp files after normal operations\nlog_info \"Test 1: No temp files after normal save\"\necho \"test content\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test1\" copy\nTEMP_COUNT=$(find \"$TEST_DIR/test1\" -name \"*.tmp\" 2\u003e/dev/null | wc -l)\n[[ \"$TEMP_COUNT\" -eq 0 ]] \u0026\u0026 \\\n    log_pass \"No .tmp files remain\" || log_fail \"Found $TEMP_COUNT .tmp files\"\n\n# Test 2: Multiple rapid saves don't corrupt\nlog_info \"Test 2: Rapid concurrent saves\"\nfor i in {1..50}; do\n    echo \"rapid entry $i\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test2\" copy \u0026\ndone\nwait\n\n# Verify index is valid JSON\n$CLIPSTACK --storage-dir \"$TEST_DIR/test2\" stats \u003e/dev/null 2\u003e\u00261 \u0026\u0026 \\\n    log_pass \"Index intact after 50 concurrent saves\" || \\\n    log_fail \"Index corrupted\"\n\n# Test 3: Temp file cleanup on startup\nlog_info \"Test 3: Temp file cleanup\"\ntouch \"$TEST_DIR/test3/index.tmp\"\ntouch \"$TEST_DIR/test3/orphan.tmp\"\nmkdir -p \"$TEST_DIR/test3\"\ntouch \"$TEST_DIR/test3/index.tmp\"\ntouch \"$TEST_DIR/test3/orphan.tmp\"\necho \"first\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test3\" copy\nTEMP_COUNT=$(find \"$TEST_DIR/test3\" -name \"*.tmp\" 2\u003e/dev/null | wc -l)\n[[ \"$TEMP_COUNT\" -eq 0 ]] \u0026\u0026 \\\n    log_pass \"Orphaned .tmp files cleaned up\" || \\\n    log_fail \"Found $TEMP_COUNT .tmp files\"\n\n# Test 4: Recovery from missing index\nlog_info \"Test 4: Recovery from missing index\"\nmkdir -p \"$TEST_DIR/test4\"\necho \"orphan 1\" \u003e \"$TEST_DIR/test4/1000.txt\"\necho \"orphan 2\" \u003e \"$TEST_DIR/test4/2000.txt\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test4\" recover\nCOUNT=$($CLIPSTACK --storage-dir \"$TEST_DIR/test4\" list 2\u003e/dev/null | wc -l)\n[[ \"$COUNT\" -ge 2 ]] \u0026\u0026 \\\n    log_pass \"Recovered $COUNT entries\" || \\\n    log_fail \"Recovery failed\"\n\n# Test 5: Recovery from corrupted index\nlog_info \"Test 5: Recovery from corrupted index\"\nmkdir -p \"$TEST_DIR/test5\"\necho \"valid content\" \u003e \"$TEST_DIR/test5/3000.txt\"\necho \"not valid json{{{\" \u003e \"$TEST_DIR/test5/index.json\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test5\" recover\n$CLIPSTACK --storage-dir \"$TEST_DIR/test5\" stats \u003e/dev/null 2\u003e\u00261 \u0026\u0026 \\\n    log_pass \"Recovered from corrupted index\" || \\\n    log_fail \"Could not recover from corruption\"\n\necho \"\"\necho -e \"${GREEN}All E2E tests passed!${NC}\"\n```\n\n## Logging\n- Clear pass/fail status for each test\n- Temp directory cleanup on exit\n\n## Acceptance Criteria\n- [ ] Script at tests/e2e_atomic_writes.sh\n- [ ] All 5 tests pass\n- [ ] Script handles cleanup properly","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:27:48.390755672-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:12:29.756546075Z","closed_at":"2026-01-13T22:12:29.756546075Z","close_reason":"E2E test script verifies all atomic write functionality: temp file cleanup, recovery from missing/corrupted index, deduplication, and index integrity after operations","dependencies":[{"issue_id":"clipboard-8u5.17","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:27:48.393012983-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.17","depends_on_id":"clipboard-8u5.16","type":"blocks","created_at":"2026-01-13T15:27:58.660174358-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y","title":"Improvement #2: Pinned/Favorites System","description":"Add ability to pin entries to protect them from automatic pruning. Users need to keep frequently-used text permanently: email signatures, code snippets, template responses. Currently no way to prevent important entries from being pruned when history exceeds limit. Solution: pinned boolean field with separate limit (MAX_PINNED=25), star indicator, 'p' keybinding to toggle. Pinned entries shown at top of list.","status":"open","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:32:16.057451575-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T12:32:16.057451575-05:00","dependencies":[{"issue_id":"clipboard-b6y","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:32:52.56484425-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y","depends_on_id":"clipboard-8u5","type":"blocks","created_at":"2026-01-13T12:32:52.83749412-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y","depends_on_id":"clipboard-tsd","type":"blocks","created_at":"2026-01-13T13:31:09.695561262-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.21","title":"[#2] Add pinned field to ClipEntry and MAX_PINNED constant","description":"## Overview\nAdd the core data structure changes needed for the pinned feature.\n\n## Code Changes in src/storage.rs\n\n### Add Constant\n```rust\nconst MAX_PINNED: usize = 25;  // Prevents users from pinning everything\n```\n\n### Update ClipEntry Struct\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ClipEntry {\n    pub id: String,\n    pub timestamp: i64,\n    pub size: usize,\n    pub preview: String,\n    pub hash: String,\n    /// Whether this entry is protected from automatic pruning\n    #[serde(default)]  // Critical for backwards compatibility!\n    pub pinned: bool,\n}\n```\n\n## Why #[serde(default)]\nExisting index.json files don't have a \"pinned\" field. The #[serde(default)] attribute:\n- Makes the field optional during deserialization\n- Defaults to false for existing entries\n- Enables seamless upgrades without data migration\n\n## Why MAX_PINNED = 25\n- Prevents abuse (pinning everything defeats the purpose)\n- 25 is plenty for common use cases (signatures, snippets, templates)\n- Total capacity: 25 pinned + 100 regular = 125 entries\n\n## Files Changed\n- src/storage.rs: Add constant, add field with serde attribute\n\n## Acceptance Criteria\n- [ ] MAX_PINNED constant = 25\n- [ ] ClipEntry has pinned: bool field\n- [ ] #[serde(default)] attribute present\n- [ ] Old index.json files load without error","status":"closed","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:28:35.695406394-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:14:09.61196816Z","closed_at":"2026-01-13T22:14:09.61196816Z","close_reason":"Already implemented: MAX_PINNED=25 constant and ClipEntry.pinned field with #[serde(default)] for backward compatibility. All 32 tests pass including recovery tests that properly set pinned=false.","dependencies":[{"issue_id":"clipboard-b6y.21","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:28:35.697054771-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.22","title":"[#2] Implement pin methods: toggle_pin(), set_pinned(), pinned_count()","description":"## Overview\nAdd Storage methods for managing pin state.\n\n## Code Changes in src/storage.rs\n\n```rust\nimpl Storage {\n    /// Toggle pin status of an entry.\n    /// Returns new pinned state, or error if at pin limit.\n    pub fn toggle_pin(\u0026self, id: \u0026str) -\u003e Result\u003cbool\u003e {\n        let mut index = self.load_index()?;\n        \n        let entry = index.entries.iter_mut().find(|e| e.id == id);\n        \n        match entry {\n            Some(entry) =\u003e {\n                // Check limit only when pinning (not unpinning)\n                if !entry.pinned {\n                    let pinned_count = index.entries.iter().filter(|e| e.pinned).count();\n                    if pinned_count \u003e= MAX_PINNED {\n                        anyhow::bail!(\n                            \"Maximum pinned entries ({}) reached. Unpin something first.\",\n                            MAX_PINNED\n                        );\n                    }\n                }\n                \n                entry.pinned = !entry.pinned;\n                let new_status = entry.pinned;\n                self.save_index(\u0026index)?;\n                Ok(new_status)\n            }\n            None =\u003e anyhow::bail!(\"Entry not found: {}\", id),\n        }\n    }\n    \n    /// Explicitly set pin status (used for undo restore)\n    pub fn set_pinned(\u0026self, id: \u0026str, pinned: bool) -\u003e Result\u003c()\u003e {\n        let mut index = self.load_index()?;\n        \n        if let Some(entry) = index.entries.iter_mut().find(|e| e.id == id) {\n            // Check limit if pinning\n            if pinned \u0026\u0026 !entry.pinned {\n                let pinned_count = index.entries.iter().filter(|e| e.pinned).count();\n                if pinned_count \u003e= MAX_PINNED {\n                    anyhow::bail!(\"Maximum pinned entries reached\");\n                }\n            }\n            entry.pinned = pinned;\n            self.save_index(\u0026index)?;\n        }\n        Ok(())\n    }\n    \n    /// Get count of pinned entries\n    pub fn pinned_count(\u0026self) -\u003e Result\u003cusize\u003e {\n        let index = self.load_index()?;\n        Ok(index.entries.iter().filter(|e| e.pinned).count())\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add 3 public methods\n\n## Acceptance Criteria\n- [ ] toggle_pin() toggles and enforces limit\n- [ ] set_pinned() allows explicit state setting\n- [ ] pinned_count() returns correct count\n- [ ] All methods save index after changes","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:29:22.458786765-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:14:53.10638182Z","closed_at":"2026-01-13T22:14:53.10638182Z","close_reason":"All 3 pin methods already implemented: toggle_pin() with MAX_PINNED limit check, set_pinned() for explicit state, pinned_count() for count. Compiles and all 32 tests pass.","dependencies":[{"issue_id":"clipboard-b6y.22","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:29:22.460578009-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.22","depends_on_id":"clipboard-b6y.21","type":"blocks","created_at":"2026-01-13T15:40:57.561320565-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.23","title":"[#2] Update prune_entries() and save_entry() for pin-aware behavior","description":"## Overview\nModify pruning logic to skip pinned entries and handle pin-preservation for duplicates.\n\n## Code Changes in src/storage.rs\n\n### Update prune logic\n```rust\nimpl Storage {\n    /// Remove oldest unpinned entries when over limit.\n    /// Pinned entries are NEVER pruned.\n    fn prune_unpinned_entries(\u0026self, index: \u0026mut ClipIndex) -\u003e Result\u003c()\u003e {\n        // Only count unpinned entries against the limit\n        while index.entries.iter().filter(|e| !e.pinned).count() \u003e self.max_entries {\n            // Find oldest (last) unpinned entry\n            if let Some(pos) = index.entries.iter().rposition(|e| !e.pinned) {\n                let old = index.entries.remove(pos);\n                let old_path = self.content_path(\u0026old.id);\n                let _ = fs::remove_file(old_path);\n            } else {\n                // All entries are pinned - nothing more to prune\n                break;\n            }\n        }\n        Ok(())\n    }\n}\n```\n\n### Update save_entry() for duplicate handling\n```rust\nimpl Storage {\n    pub fn save_entry(\u0026self, content: \u0026str) -\u003e Result\u003cClipEntry\u003e {\n        // ... hash computation ...\n        \n        let mut index = self.load_index()?;\n        \n        // Check for duplicate by hash\n        if let Some(pos) = index.entries.iter().position(|e| e.hash == hash) {\n            // Move existing entry to front, PRESERVING pin status\n            let existing = index.entries.remove(pos);\n            index.entries.insert(0, existing.clone());\n            self.save_index(\u0026index)?;\n            return Ok(existing);  // Important: return existing entry (keeps pinned=true)\n        }\n        \n        // Create new entry (new entries are NEVER pinned)\n        let entry = ClipEntry {\n            id: id.clone(),\n            timestamp,\n            size: content.len(),\n            preview,\n            hash,\n            pinned: false,  // New entries start unpinned\n        };\n        \n        // ... save content file ...\n        \n        index.entries.insert(0, entry.clone());\n        \n        // Prune old UNPINNED entries only\n        self.prune_unpinned_entries(\u0026mut index)?;\n        \n        self.save_index(\u0026index)?;\n        Ok(entry)\n    }\n}\n```\n\n## Key Behaviors\n1. Pinned entries NEVER get pruned\n2. Only unpinned count against max_entries limit\n3. Duplicate content preserves existing pin status\n4. New entries always start unpinned\n\n## Files Changed\n- src/storage.rs: Update prune and save logic\n\n## Acceptance Criteria\n- [ ] Pinned entries survive when unpinned count exceeds limit\n- [ ] Duplicate detection preserves pinned=true\n- [ ] New entries have pinned=false\n- [ ] Pruning only removes oldest unpinned","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:29:28.216389794-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:18:04.268053063Z","closed_at":"2026-01-13T22:18:04.268053063Z","close_reason":"Implemented pin-aware pruning: prune_unpinned_entries() method and sync_max_entries both now only prune unpinned entries. Pinned entries don't count against max_entries limit. All 50 tests pass.","dependencies":[{"issue_id":"clipboard-b6y.23","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:29:28.218220001-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.23","depends_on_id":"clipboard-b6y.21","type":"blocks","created_at":"2026-01-13T15:40:57.597736065-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.24","title":"[#2] Update Picker with pin toggle, sorting, and delete/undo pin state","description":"## Overview\nAdd all Picker-side pin functionality: toggle, sorting, delete/undo tracking.\n\n## Code Changes in src/picker.rs\n\n### Update DeletedEntry for pin restore\n```rust\nstruct DeletedEntry {\n    entry: ClipEntry,\n    content: String,\n    was_pinned: bool,  // NEW: Track pin state for restoration\n    deleted_at: Instant,\n}\n```\n\n### Add pin toggle method\n```rust\nimpl Picker {\n    /// Toggle pin status of selected entry\n    fn toggle_pin_selected(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if let Some(idx) = self.selected_entry_index() {\n            let entry_id = self.entries[idx].id.clone();\n            \n            match self.storage.toggle_pin(\u0026entry_id) {\n                Ok(is_pinned) =\u003e {\n                    // Update local state\n                    self.entries[idx].pinned = is_pinned;\n                    \n                    // Re-sort: pinned entries first\n                    self.sort_entries_by_pin();\n                    \n                    let msg = if is_pinned { \"★ Pinned\" } else { \"Unpinned\" };\n                    self.set_status(msg.to_string(), StatusLevel::Success);\n                }\n                Err(e) =\u003e {\n                    self.set_status(e.to_string(), StatusLevel::Warning);\n                }\n            }\n        }\n        Ok(())\n    }\n    \n    /// Sort entries: pinned first (by timestamp), then unpinned (by timestamp)\n    fn sort_entries_by_pin(\u0026mut self) {\n        let selected_id = self.selected_entry().map(|e| e.id.clone());\n        \n        self.entries.sort_by(|a, b| {\n            match (a.pinned, b.pinned) {\n                (true, false) =\u003e std::cmp::Ordering::Less,\n                (false, true) =\u003e std::cmp::Ordering::Greater,\n                _ =\u003e b.timestamp.cmp(\u0026a.timestamp),  // Most recent first\n            }\n        });\n        \n        self.update_filter();\n        \n        // Restore selection by ID\n        if let Some(id) = selected_id {\n            for (i, filtered) in self.filtered.iter().enumerate() {\n                if self.entries[filtered.index].id == id {\n                    self.selected.select(Some(i));\n                    break;\n                }\n            }\n        }\n        self.update_scroll_state();\n        self.load_preview();\n    }\n}\n```\n\n### Update delete_selected() to track pin state\n```rust\nfn delete_selected(\u0026mut self) -\u003e Result\u003c()\u003e {\n    if let Some(entry) = self.selected_entry().cloned() {\n        let content = self.storage.load_content(\u0026entry.id)?;\n        let preview: String = entry.preview.chars().take(30).collect();\n        let was_pinned = entry.pinned;  // NEW: Track pin state\n        \n        self.last_deleted = Some(DeletedEntry {\n            entry: entry.clone(),\n            content,\n            was_pinned,  // NEW\n            deleted_at: Instant::now(),\n        });\n        \n        self.storage.delete_entry(\u0026entry.id)?;\n        self.entries.retain(|e| e.id != entry.id);\n        self.update_filter();\n        self.load_preview();\n        \n        let msg = if was_pinned {\n            format!(\"Deleted ★ '{}' - 'u' to undo (5s)\", preview)\n        } else {\n            format!(\"Deleted '{}' - 'u' to undo (5s)\", preview)\n        };\n        self.set_status(msg, StatusLevel::Warning);\n    }\n    Ok(())\n}\n```\n\n### Update undo_delete() to restore pin state\n```rust\nfn undo_delete(\u0026mut self) -\u003e Result\u003c()\u003e {\n    if let Some(deleted) = self.last_deleted.take() {\n        if deleted.deleted_at.elapsed() \u003c Duration::from_secs(5) {\n            let preview: String = deleted.entry.preview.chars().take(30).collect();\n            \n            let restored = self.storage.save_entry(\u0026deleted.content)?;\n            \n            // Restore pin state if it was pinned\n            if deleted.was_pinned {\n                let _ = self.storage.set_pinned(\u0026restored.id, true);\n            }\n            \n            // Reload entries\n            let index = self.storage.load_index()?;\n            self.entries = index.entries;\n            self.sort_entries_by_pin();\n            self.update_filter();\n            self.load_preview();\n            \n            let msg = if deleted.was_pinned {\n                format!(\"Restored ★ '{}'\", preview)\n            } else {\n                format!(\"Restored '{}'\", preview)\n            };\n            self.set_status(msg, StatusLevel::Success);\n        } else {\n            self.set_status(\"Undo expired\".to_string(), StatusLevel::Warning);\n        }\n    }\n    Ok(())\n}\n```\n\n### Add 'p' keybinding in handle_normal_mode()\n```rust\nKeyCode::Char('p') =\u003e {\n    self.toggle_pin_selected()?;\n}\n```\n\n## Files Changed\n- src/picker.rs: Update DeletedEntry, add methods, add keybinding\n\n## Acceptance Criteria\n- [ ] 'p' key toggles pin\n- [ ] Pinned entries sort to top\n- [ ] Delete tracks was_pinned\n- [ ] Undo restores pin state","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:31:32.377498028-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:19:06.452623687Z","closed_at":"2026-01-13T22:19:06.452623687Z","close_reason":"Added toggle_pin_selected() and sort_entries_by_pin() methods, 'p' keybinding, pin-aware delete/undo with star indicators","dependencies":[{"issue_id":"clipboard-b6y.24","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:31:32.381007294-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.24","depends_on_id":"clipboard-b6y.22","type":"blocks","created_at":"2026-01-13T15:40:57.633789868-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.25","title":"[#2] Update rendering: star indicator, pinned count in title, status line help","description":"## Overview\nAdd visual feedback for pinned entries throughout the UI.\n\n## Code Changes in src/picker.rs\n\n### Update render_list() with pin indicator\nIn the list item rendering loop, add star for pinned entries:\n\n```rust\n// Pin indicator (★ for pinned, space for not)\nlet pin_indicator = if entry.pinned {\n    Span::styled(\"★ \", Style::default().fg(Color::Yellow))\n} else {\n    Span::raw(\"  \")\n};\n\nlet mut spans = vec![\n    pin_indicator,  // NEW: Pin star first\n    Span::styled(\n        format!(\"{:\u003e3} \", time),\n        Style::default().fg(Color::DarkGray),\n    ),\n    // ... rest of spans\n];\n```\n\n### Update title to show pinned count\n```rust\nlet pinned_count = self.entries.iter().filter(|e| e.pinned).count();\n\nlet title = if !self.search_query.is_empty() {\n    format!(\n        \"History ({}/{}) matching '{}'\",\n        self.filtered.len(), self.entries.len(), self.search_query\n    )\n} else if pinned_count \u003e 0 {\n    format!(\n        \"History ({}/{}) - {} pinned\",\n        self.filtered.len(), self.entries.len(), pinned_count\n    )\n} else {\n    format!(\"History ({}/{})\", self.filtered.len(), self.entries.len())\n};\n```\n\n### Update status line help\n```rust\n// In render_status_line()\n\"[NORMAL] Tab:Switch  j/k:Nav  p:Pin  d:Del  /:Search  Enter:Paste\"\n```\n\n### Update Stats command in main.rs\n```rust\nSome(Commands::Stats) =\u003e {\n    let index = storage.load_index()?;\n    let total_size: usize = index.entries.iter().map(|e| e.size).sum();\n    let pinned_count = index.entries.iter().filter(|e| e.pinned).count();\n    let unpinned_count = index.entries.len() - pinned_count;\n    \n    println!(\"Entries:    {}\", index.entries.len());\n    println!(\"  Pinned:   {} (protected)\", pinned_count);\n    println!(\"  Regular:  {}/{}\", unpinned_count, storage.max_entries());\n    println!(\"Total size: {}\", util::format_size(total_size));\n    // ... rest of stats\n}\n```\n\n## Visual Result\n```\n┌─History (5/105) - 3 pinned────────────────────┐\n│\u003e ★ 2d ago [   45B] My email signature...      │\n│  ★ 5d ago [  128B] import { useState }...     │\n│  ★ 1w ago [   32B] const API_BASE = ...       │\n│  10s ago [  1.2KB] function handleClick()...  │\n└───────────────────────────────────────────────┘\n[NORMAL] Tab:Switch  j/k:Nav  p:Pin  d:Del  /:Search  Enter:Paste\n```\n\n## Files Changed\n- src/picker.rs: Update render_list(), render_status_line()\n- src/main.rs: Update Stats command\n\n## Acceptance Criteria\n- [ ] Yellow ★ shows for pinned entries\n- [ ] Title shows pinned count when \u003e0\n- [ ] Status line shows p:Pin hint\n- [ ] stats command shows pinned breakdown","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:32:46.577621755-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:20:42.38507122Z","closed_at":"2026-01-13T22:20:42.38507122Z","close_reason":"All rendering updates implemented: star indicator, pinned count in title, status line help, stats pinned breakdown","dependencies":[{"issue_id":"clipboard-b6y.25","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:32:46.579625975-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.25","depends_on_id":"clipboard-b6y.21","type":"blocks","created_at":"2026-01-13T15:40:57.671141714-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.26","title":"[#2] Write comprehensive unit tests for pin functionality","description":"## Overview\nTDD: Comprehensive tests for all pin functionality including edge cases.\n\n## Test Cases (copy-paste ready)\n\n```rust\n#[cfg(test)]\nmod pin_tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    fn test_storage() -\u003e (Storage, TempDir) {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        (storage, dir)\n    }\n    \n    #[test]\n    fn test_new_entry_not_pinned() {\n        let (storage, _dir) = test_storage();\n        let entry = storage.save_entry(\"test\").unwrap();\n        assert!(!entry.pinned, \"New entries should not be pinned\");\n    }\n    \n    #[test]\n    fn test_toggle_pin_on() {\n        let (storage, _dir) = test_storage();\n        let entry = storage.save_entry(\"pin me\").unwrap();\n        \n        let is_pinned = storage.toggle_pin(\u0026entry.id).unwrap();\n        assert!(is_pinned, \"Should return true after pinning\");\n        \n        // Verify persistence\n        let index = storage.load_index().unwrap();\n        let loaded = index.entries.iter().find(|e| e.id == entry.id).unwrap();\n        assert!(loaded.pinned, \"Pin state should persist\");\n    }\n    \n    #[test]\n    fn test_toggle_pin_off() {\n        let (storage, _dir) = test_storage();\n        let entry = storage.save_entry(\"toggle me\").unwrap();\n        \n        storage.toggle_pin(\u0026entry.id).unwrap();  // Pin\n        let is_pinned = storage.toggle_pin(\u0026entry.id).unwrap();  // Unpin\n        assert!(!is_pinned, \"Should return false after unpinning\");\n    }\n    \n    #[test]\n    fn test_pinned_survives_pruning() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 10).unwrap();\n        \n        // Create and pin an entry\n        let pinned_entry = storage.save_entry(\"keep me\").unwrap();\n        storage.toggle_pin(\u0026pinned_entry.id).unwrap();\n        \n        // Fill beyond limit\n        for i in 0..20 {\n            storage.save_entry(\u0026format!(\"filler {}\", i)).unwrap();\n        }\n        \n        // Verify pinned entry still exists\n        let index = storage.load_index().unwrap();\n        let found = index.entries.iter().find(|e| e.id == pinned_entry.id);\n        assert!(found.is_some(), \"Pinned entry should survive pruning\");\n        assert!(found.unwrap().pinned, \"Should still be pinned\");\n        \n        // Verify unpinned count is at limit\n        let unpinned = index.entries.iter().filter(|e| !e.pinned).count();\n        assert_eq!(unpinned, 10, \"Unpinned should be capped at max_entries\");\n    }\n    \n    #[test]\n    fn test_pin_limit_enforced() {\n        let (storage, _dir) = test_storage();\n        \n        // Pin MAX_PINNED entries\n        for i in 0..MAX_PINNED {\n            let entry = storage.save_entry(\u0026format!(\"pinned {}\", i)).unwrap();\n            storage.toggle_pin(\u0026entry.id).unwrap();\n        }\n        \n        // Try to pin one more\n        let extra = storage.save_entry(\"one too many\").unwrap();\n        let result = storage.toggle_pin(\u0026extra.id);\n        \n        assert!(result.is_err(), \"Should fail at pin limit\");\n        assert!(result.unwrap_err().to_string().contains(\"Maximum\"), \n                \"Error should mention maximum\");\n    }\n    \n    #[test]\n    fn test_duplicate_preserves_pin_status() {\n        let (storage, _dir) = test_storage();\n        \n        // Create and pin an entry\n        let original = storage.save_entry(\"duplicate me\").unwrap();\n        storage.toggle_pin(\u0026original.id).unwrap();\n        \n        // Add other entries\n        storage.save_entry(\"other 1\").unwrap();\n        storage.save_entry(\"other 2\").unwrap();\n        \n        // Re-copy same content\n        let dup = storage.save_entry(\"duplicate me\").unwrap();\n        \n        // Should be same entry, moved to front, still pinned\n        assert_eq!(dup.id, original.id, \"Should return same entry ID\");\n        \n        let index = storage.load_index().unwrap();\n        assert_eq!(index.entries[0].id, original.id, \"Should be moved to front\");\n        assert!(index.entries[0].pinned, \"Pin status should be preserved\");\n    }\n    \n    #[test]\n    fn test_backwards_compat_missing_pinned_field() {\n        let dir = TempDir::new().unwrap();\n        let index_path = dir.path().join(\"index.json\");\n        \n        // Write old-format index (no pinned field)\n        std::fs::write(\u0026index_path, r#\"{\n            \"max_entries\": 100,\n            \"entries\": [{\n                \"id\": \"12345\",\n                \"timestamp\": 12345,\n                \"size\": 4,\n                \"preview\": \"test\",\n                \"hash\": \"sha256:abc\"\n            }]\n        }\"#).unwrap();\n        \n        std::fs::write(dir.path().join(\"12345.txt\"), \"test\").unwrap();\n        \n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let index = storage.load_index().unwrap();\n        \n        assert_eq!(index.entries.len(), 1, \"Should load old format\");\n        assert!(!index.entries[0].pinned, \"Should default to false\");\n    }\n    \n    #[test]\n    fn test_set_pinned_explicit() {\n        let (storage, _dir) = test_storage();\n        let entry = storage.save_entry(\"test\").unwrap();\n        \n        storage.set_pinned(\u0026entry.id, true).unwrap();\n        let index = storage.load_index().unwrap();\n        assert!(index.entries[0].pinned);\n        \n        storage.set_pinned(\u0026entry.id, false).unwrap();\n        let index = storage.load_index().unwrap();\n        assert!(!index.entries[0].pinned);\n    }\n    \n    #[test]\n    fn test_pinned_count() {\n        let (storage, _dir) = test_storage();\n        \n        assert_eq!(storage.pinned_count().unwrap(), 0);\n        \n        let e1 = storage.save_entry(\"one\").unwrap();\n        let e2 = storage.save_entry(\"two\").unwrap();\n        storage.toggle_pin(\u0026e1.id).unwrap();\n        storage.toggle_pin(\u0026e2.id).unwrap();\n        \n        assert_eq!(storage.pinned_count().unwrap(), 2);\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add test module\n\n## Acceptance Criteria\n- [ ] All 10 tests pass\n- [ ] Tests run: cargo test pin_tests\n- [ ] Backwards compatibility verified","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:36:06.39915299-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:22:54.150268209Z","closed_at":"2026-01-13T22:22:54.150268209Z","close_reason":"Added and verified 3 new pin tests: pinned_survives_pruning, duplicate_preserves_pin_status, backwards_compat_missing_pinned_field. All 65 tests pass.","dependencies":[{"issue_id":"clipboard-b6y.26","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:36:06.401289757-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.26","depends_on_id":"clipboard-b6y.21","type":"blocks","created_at":"2026-01-13T15:40:57.708637028-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.27","title":"[#2] Write E2E test script for pinned entries","description":"## Overview\nEnd-to-end test script verifying pinned functionality in practice.\n\n## E2E Test Script (tests/e2e_pinned.sh)\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# E2E Tests for Pinned/Favorites Feature\n# Run from project root: ./tests/e2e_pinned.sh\n\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nTEST_DIR=$(mktemp -d)\nCLIPSTACK=\"./target/release/clipstack\"\n\nlog_pass() { echo -e \"${GREEN}✓${NC} $1\"; }\nlog_fail() { echo -e \"${RED}✗${NC} $1\"; exit 1; }\nlog_info() { echo -e \"${YELLOW}→${NC} $1\"; }\n\ncleanup() { rm -rf \"$TEST_DIR\"; }\ntrap cleanup EXIT\n\n# Build release if needed\n[[ -f \"$CLIPSTACK\" ]] || cargo build --release\n\nlog_info \"Test directory: $TEST_DIR\"\n\n# Test 1: Stats shows pinned count\nlog_info \"Test 1: Pinned count in stats\"\necho \"entry1\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test1\" copy\n$CLIPSTACK --storage-dir \"$TEST_DIR/test1\" stats | grep -q \"Pinned:.*0\" \u0026\u0026 \\\n    log_pass \"Stats shows 0 pinned initially\" || log_fail \"Stats should show pinned count\"\n\n# Test 2: Pinned entries survive pruning\nlog_info \"Test 2: Pinned survive pruning\"\n# Create entry and manually mark as pinned (we can't use picker in script)\necho \"keep me forever\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test2\" --max-entries 5 copy\nKEEP_ID=$(cat \"$TEST_DIR/test2/index.json\" | grep -o '\"id\":\"[^\"]*\"' | head -1 | cut -d'\"' -f4)\n\n# Manually pin by editing JSON (simulating picker 'p' key)\nsed -i 's/\"pinned\":false/\"pinned\":true/' \"$TEST_DIR/test2/index.json\" 2\u003e/dev/null || \\\n    sed -i '' 's/\"pinned\":false/\"pinned\":true/' \"$TEST_DIR/test2/index.json\"\n\n# Fill beyond limit\nfor i in {1..10}; do\n    echo \"filler $i\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test2\" --max-entries 5 copy\ndone\n\n# Check pinned entry survives\nif grep -q \"$KEEP_ID\" \"$TEST_DIR/test2/index.json\" 2\u003e/dev/null; then\n    log_pass \"Pinned entry survived pruning\"\nelse\n    log_fail \"Pinned entry was incorrectly pruned\"\nfi\n\n# Test 3: Backwards compatibility (old index without pinned field)\nlog_info \"Test 3: Backwards compatibility\"\nmkdir -p \"$TEST_DIR/test3\"\ncat \u003e \"$TEST_DIR/test3/index.json\" \u003c\u003c 'EOF'\n{\n  \"max_entries\": 100,\n  \"entries\": [\n    {\"id\":\"1234\",\"timestamp\":1234,\"size\":4,\"preview\":\"test\",\"hash\":\"sha256:abc\"}\n  ]\n}\nEOF\necho \"test\" \u003e \"$TEST_DIR/test3/1234.txt\"\n\n$CLIPSTACK --storage-dir \"$TEST_DIR/test3\" stats \u003e/dev/null 2\u003e\u00261 \u0026\u0026 \\\n    log_pass \"Old format index loads\" || log_fail \"Should load old format\"\n\n# Test 4: Unpinned count respects limit\nlog_info \"Test 4: Unpinned respects limit\"\nrm -rf \"$TEST_DIR/test4\"\nfor i in {1..15}; do\n    echo \"entry $i\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test4\" --max-entries 10 copy\ndone\n\nTOTAL=$(cat \"$TEST_DIR/test4/index.json\" | grep -c '\"id\"' || echo 0)\n[[ \"$TOTAL\" -le 12 ]] \u0026\u0026 \\\n    log_pass \"Entry limit respected ($TOTAL entries)\" || \\\n    log_fail \"Too many entries: $TOTAL\"\n\n# Test 5: Duplicate preserves pin (manual pin + re-copy)\nlog_info \"Test 5: Duplicate preserves pin\"\nmkdir -p \"$TEST_DIR/test5\"\necho \"duplicate content\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test5\" copy\n\n# Pin the entry\nsed -i 's/\"pinned\":false/\"pinned\":true/' \"$TEST_DIR/test5/index.json\" 2\u003e/dev/null || \\\n    sed -i '' 's/\"pinned\":false/\"pinned\":true/' \"$TEST_DIR/test5/index.json\"\n\n# Re-copy same content\necho \"duplicate content\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test5\" copy\n\n# Should still be pinned\nif grep -q '\"pinned\":true' \"$TEST_DIR/test5/index.json\"; then\n    log_pass \"Duplicate preserved pin status\"\nelse\n    log_fail \"Duplicate lost pin status\"\nfi\n\necho \"\"\necho -e \"${GREEN}All E2E tests passed!${NC}\"\n```\n\n## Acceptance Criteria\n- [ ] Script at tests/e2e_pinned.sh\n- [ ] All 5 tests pass\n- [ ] Tests backwards compatibility\n- [ ] Tests pruning protection","status":"in_progress","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:39:47.67463296-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:22:06.100901749Z","dependencies":[{"issue_id":"clipboard-b6y.27","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:39:47.676474942-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.27","depends_on_id":"clipboard-b6y.26","type":"blocks","created_at":"2026-01-13T15:40:57.745733846-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve","title":"Improvement #4: Preview Scrolling with Focus Mode","description":"Preview pane shows fixed view - no way to see beyond ~30 lines without pasting. Tedious workflow: paste, read, undo if wrong, try another. Solution: add focus mode (Tab toggles between list/preview focus), Ctrl+D/U scrolls focused pane. Scroll position indicator shows line range. Visual scroll arrows when content extends beyond view.","status":"closed","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:35:25.940879085-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:21:40.522110826Z","closed_at":"2026-01-13T22:21:40.522110826Z","close_reason":"Preview scrolling feature complete: Focus enum, Tab toggle, j/k/pgup/pgdn/g/G scroll keys, rendering with scroll indicators, unit tests, E2E tests. All tests pass.","dependencies":[{"issue_id":"clipboard-pve","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:36:36.827178452-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.19","title":"Add Focus enum and scrolling state to PickerState","description":"## Overview\nAdd the Focus enum for mode tracking and scroll state fields to PickerState for preview scrolling support.\n\n## Implementation Details\n\n### Focus Enum\n```rust\n#[derive(Clone, Copy, PartialEq, Default)]\nenum Focus {\n    #[default]\n    List,     // Normal mode - navigate entry list\n    Preview,  // Preview mode - scroll through selected entry content\n}\n```\n\n### PickerState Additional Fields\n```rust\nstruct PickerState {\n    // Existing fields...\n    focus: Focus,                    // Current focus mode\n    preview_scroll: usize,           // Current scroll offset in preview\n    preview_lines: Vec\u003cString\u003e,      // Cached wrapped lines of preview content\n    preview_height: u16,             // Available height for preview area\n}\n```\n\n### Default Values\n```rust\nimpl Default for PickerState {\n    fn default() -\u003e Self {\n        Self {\n            // existing...\n            focus: Focus::List,\n            preview_scroll: 0,\n            preview_lines: Vec::new(),\n            preview_height: 10,  // Updated dynamically during render\n        }\n    }\n}\n```\n\n## Key Design Decisions\n- Focus::List is default (backwards compatible)\n- preview_lines caches wrapped text to avoid re-wrapping on scroll\n- preview_height updated each render cycle for responsive design\n- preview_scroll resets to 0 when selection changes\n\n## Files to Modify\n- src/picker.rs: Add Focus enum, update PickerState struct\n\n## Acceptance Criteria\n- [ ] Focus enum with List and Preview variants\n- [ ] Focus derives Clone, Copy, PartialEq, Default\n- [ ] PickerState has focus, preview_scroll, preview_lines, preview_height fields\n- [ ] Default implementation initializes all new fields\n- [ ] Code compiles without warnings","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:42:57.673324566-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:04:40.884322293Z","closed_at":"2026-01-13T22:04:40.884322293Z","close_reason":"Focus enum and scrolling state fields added to Picker struct. All fields initialized in new(). Code compiles.","dependencies":[{"issue_id":"clipboard-pve.19","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:42:57.675148583-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.20","title":"Implement Tab focus toggle and preview content loading","description":"## Overview\nImplement Tab key to toggle between List and Preview focus modes, with content loading and line wrapping.\n\n## Implementation Details\n\n### Tab Key Handler\n```rust\nKeyCode::Tab =\u003e {\n    self.focus = match self.focus {\n        Focus::List =\u003e {\n            // Entering preview mode - load and wrap content\n            self.load_preview_content(storage)?;\n            Focus::Preview\n        }\n        Focus::Preview =\u003e {\n            // Exiting preview mode - clear cache\n            self.preview_lines.clear();\n            self.preview_scroll = 0;\n            Focus::List\n        }\n    };\n}\n```\n\n### Content Loading and Wrapping\n```rust\nfn load_preview_content(\u0026mut self, storage: \u0026Storage) -\u003e Result\u003c()\u003e {\n    let entry = match self.current_entry() {\n        Some(e) =\u003e e,\n        None =\u003e return Ok(()),\n    };\n    \n    let content = storage.load_content(\u0026entry.id)?;\n    \n    // Wrap lines to preview width (typically terminal width - padding)\n    let wrap_width = 80;  // Or get from terminal size\n    self.preview_lines = content\n        .lines()\n        .flat_map(|line| {\n            if line.len() \u003c= wrap_width {\n                vec![line.to_string()]\n            } else {\n                line.chars()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .chunks(wrap_width)\n                    .map(|c| c.iter().collect::\u003cString\u003e())\n                    .collect()\n            }\n        })\n        .collect();\n    \n    self.preview_scroll = 0;\n    Ok(())\n}\n```\n\n### Selection Change Reset\nWhen selection changes in List mode, reset preview cache:\n```rust\nfn set_selected(\u0026mut self, idx: usize) {\n    if self.selected != idx {\n        self.selected = idx;\n        self.preview_lines.clear();  // Invalidate cache\n        self.preview_scroll = 0;\n    }\n}\n```\n\n## Key Design Decisions\n- Tab is intuitive toggle (like tab between form fields)\n- Content loaded lazily only when entering Preview mode\n- Line wrapping preserves existing line breaks\n- Cache cleared on selection change to avoid stale data\n\n## Files to Modify\n- src/picker.rs: Add Tab handler, load_preview_content method, update set_selected\n\n## Acceptance Criteria\n- [ ] Tab toggles between List and Preview focus\n- [ ] Content loaded when entering Preview mode\n- [ ] Lines wrapped to fit preview width\n- [ ] Preview cache cleared on selection change\n- [ ] Preview scroll resets on mode change","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:43:21.416419841-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:10:16.970197738Z","closed_at":"2026-01-13T22:10:16.970197738Z","close_reason":"Implemented Tab focus toggle and load_preview_content() method. Tab toggles between Focus::List and Focus::Preview, loads wrapped content when entering Preview mode, clears cache on selection change. All tests pass.","dependencies":[{"issue_id":"clipboard-pve.20","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:43:21.418328707-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.20","depends_on_id":"clipboard-pve.19","type":"blocks","created_at":"2026-01-13T15:44:53.26704141-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.21","title":"Implement preview scroll navigation keys","description":"## Overview\nImplement keyboard navigation for scrolling through preview content when in Focus::Preview mode.\n\n## Implementation Details\n\n### Navigation Keys in Preview Mode\n```rust\n// In handle_event match block, when self.focus == Focus::Preview:\nmatch key.code {\n    // Line-by-line scrolling\n    KeyCode::Up | KeyCode::Char('k') =\u003e {\n        self.preview_scroll = self.preview_scroll.saturating_sub(1);\n    }\n    KeyCode::Down | KeyCode::Char('j') =\u003e {\n        let max_scroll = self.preview_lines.len().saturating_sub(self.preview_height as usize);\n        if self.preview_scroll \u003c max_scroll {\n            self.preview_scroll += 1;\n        }\n    }\n    \n    // Page scrolling\n    KeyCode::PageUp =\u003e {\n        self.preview_scroll = self.preview_scroll.saturating_sub(self.preview_height as usize);\n    }\n    KeyCode::PageDown =\u003e {\n        let max_scroll = self.preview_lines.len().saturating_sub(self.preview_height as usize);\n        let page = self.preview_height as usize;\n        self.preview_scroll = (self.preview_scroll + page).min(max_scroll);\n    }\n    \n    // Jump to top/bottom\n    KeyCode::Home | KeyCode::Char('g') =\u003e {\n        self.preview_scroll = 0;\n    }\n    KeyCode::End | KeyCode::Char('G') =\u003e {\n        let max_scroll = self.preview_lines.len().saturating_sub(self.preview_height as usize);\n        self.preview_scroll = max_scroll;\n    }\n    \n    // Exit preview mode\n    KeyCode::Tab | KeyCode::Esc | KeyCode::Char('q') =\u003e {\n        self.focus = Focus::List;\n        self.preview_lines.clear();\n        self.preview_scroll = 0;\n    }\n    \n    _ =\u003e {}\n}\n```\n\n### Scroll Bounds Calculation\n```rust\nfn max_scroll(\u0026self) -\u003e usize {\n    self.preview_lines.len().saturating_sub(self.preview_height as usize)\n}\n```\n\n## Key Design Decisions\n- j/k for vi-style line navigation\n- PageUp/PageDown for fast scrolling\n- g/G for top/bottom (vi-style)\n- Multiple exit keys (Tab, Esc, q) for convenience\n- saturating_sub prevents underflow on boundaries\n\n## Files to Modify\n- src/picker.rs: Update handle_event for Focus::Preview keybindings\n\n## Acceptance Criteria\n- [ ] Up/k scrolls up one line\n- [ ] Down/j scrolls down one line\n- [ ] PageUp/PageDown scroll by page\n- [ ] g/Home jumps to top\n- [ ] G/End jumps to bottom\n- [ ] Tab/Esc/q exits preview mode\n- [ ] Scroll bounds respected (no over-scroll)","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:43:37.23253047-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:11:39.267602498Z","closed_at":"2026-01-13T22:11:39.267602498Z","close_reason":"Implemented handle_preview_mode() with j/k line scrolling, PageUp/PageDown page scrolling, g/G jump to top/bottom, Tab/Esc/q exit. Added max_preview_scroll() helper. All tests pass.","dependencies":[{"issue_id":"clipboard-pve.21","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:43:37.234523674-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.21","depends_on_id":"clipboard-pve.20","type":"blocks","created_at":"2026-01-13T15:44:53.307025597-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.22","title":"Update rendering for preview focus mode with scroll indicators","description":"## Overview\nUpdate the Picker rendering to show scrollable preview with visual indicators for focus mode and scroll position.\n\n## Implementation Details\n\n### Focus Mode Indicator in Title\n```rust\nfn render_title(\u0026self) -\u003e String {\n    match self.focus {\n        Focus::List =\u003e format!(\"ClipStack ({} entries)\", self.entries.len()),\n        Focus::Preview =\u003e format!(\"ClipStack [PREVIEW] - Tab to exit\"),\n    }\n}\n```\n\n### Preview Pane Rendering\n```rust\nfn render_preview(\u0026self, area: Rect, buf: \u0026mut Buffer) {\n    // Update height for scroll calculations\n    self.preview_height = area.height.saturating_sub(2);  // Account for borders\n    \n    // Calculate visible window\n    let start = self.preview_scroll;\n    let end = (start + self.preview_height as usize).min(self.preview_lines.len());\n    \n    // Render visible lines\n    for (i, line) in self.preview_lines[start..end].iter().enumerate() {\n        let y = area.y + i as u16 + 1;  // +1 for border\n        buf.set_string(area.x + 1, y, line, Style::default());\n    }\n    \n    // Scroll position indicator\n    if self.preview_lines.len() \u003e self.preview_height as usize {\n        let indicator = format!(\n            \"Lines {}-{} of {}\",\n            start + 1,\n            end,\n            self.preview_lines.len()\n        );\n        buf.set_string(area.x + 1, area.y + area.height - 1, \u0026indicator, Style::default().dim());\n    }\n}\n```\n\n### Scroll Bar Indicator\n```rust\nfn render_scrollbar(\u0026self, area: Rect, buf: \u0026mut Buffer) {\n    if self.preview_lines.len() \u003c= self.preview_height as usize {\n        return;  // No scrollbar needed\n    }\n    \n    let total = self.preview_lines.len();\n    let visible = self.preview_height as usize;\n    let scroll_ratio = self.preview_scroll as f32 / (total - visible) as f32;\n    \n    let bar_height = ((visible as f32 / total as f32) * area.height as f32).max(1.0) as u16;\n    let bar_y = (scroll_ratio * (area.height - bar_height) as f32) as u16;\n    \n    for y in bar_y..(bar_y + bar_height) {\n        buf.set_string(area.x + area.width - 1, area.y + y, \"█\", Style::default().fg(Color::DarkGray));\n    }\n}\n```\n\n### Help Text for Preview Mode\n```rust\nfn render_help(\u0026self) -\u003e String {\n    match self.focus {\n        Focus::List =\u003e \"/: search | Tab: preview | Enter: paste | d: delete | q: quit\",\n        Focus::Preview =\u003e \"j/k: scroll | PgUp/PgDn: page | g/G: top/bottom | Tab/Esc: back\",\n    }\n}\n```\n\n## Key Design Decisions\n- [PREVIEW] in title clearly indicates mode\n- Line number indicator shows position in content\n- Scrollbar provides visual scroll position\n- Help text contextually shows available keys\n\n## Files to Modify\n- src/picker.rs: Update render_* methods for preview mode\n\n## Acceptance Criteria\n- [ ] Title shows [PREVIEW] indicator in preview mode\n- [ ] Preview shows scrolled window of content\n- [ ] Line position indicator shows current/total lines\n- [ ] Scrollbar appears when content exceeds height\n- [ ] Help text shows preview-mode keybindings","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:43:55.919869587-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:14:54.084080793Z","closed_at":"2026-01-13T22:14:54.084080793Z","close_reason":"Updated render_preview for Focus::Preview mode with scrollable content, line position indicator, yellow border highlight. Updated render_status_line with contextual help for Preview mode. Added 'Tab to scroll' hint in truncated preview title. All tests pass.","dependencies":[{"issue_id":"clipboard-pve.22","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:43:55.921783363-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.22","depends_on_id":"clipboard-pve.21","type":"blocks","created_at":"2026-01-13T15:44:53.345327814-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.23","title":"Unit tests for preview scrolling","description":"## Overview\nComprehensive unit test suite for the preview scrolling and focus mode functionality.\n\n## Test Cases\n\n### Focus Mode Tests\n```rust\n#[test]\nfn test_focus_enum_default() {\n    let state = PickerState::default();\n    assert_eq\\!(state.focus, Focus::List);\n}\n\n#[test]\nfn test_tab_toggles_focus() {\n    let mut state = PickerState::default();\n    // Initial state\n    assert_eq\\!(state.focus, Focus::List);\n    \n    // Toggle to Preview\n    state.handle_key(KeyCode::Tab);\n    assert_eq\\!(state.focus, Focus::Preview);\n    \n    // Toggle back to List\n    state.handle_key(KeyCode::Tab);\n    assert_eq\\!(state.focus, Focus::List);\n}\n```\n\n### Content Loading Tests\n```rust\n#[test]\nfn test_preview_content_loaded_on_focus_change() {\n    let (storage, _dir) = test_storage();\n    storage.save_entry(\"line1\\nline2\\nline3\").unwrap();\n    \n    let mut state = PickerState::new(\u0026storage).unwrap();\n    assert\\!(state.preview_lines.is_empty());\n    \n    state.handle_key(KeyCode::Tab);  // Enter preview\n    assert\\!(\\!state.preview_lines.is_empty());\n    assert_eq\\!(state.preview_lines.len(), 3);\n}\n\n#[test]\nfn test_preview_cache_cleared_on_selection_change() {\n    // Setup with multiple entries\n    // Load preview for first entry\n    // Change selection\n    // Verify preview_lines is empty\n}\n```\n\n### Scroll Navigation Tests\n```rust\n#[test]\nfn test_scroll_down() {\n    let mut state = setup_preview_state(100);  // 100 lines\n    state.preview_height = 10;\n    \n    state.handle_key(KeyCode::Down);\n    assert_eq\\!(state.preview_scroll, 1);\n}\n\n#[test]\nfn test_scroll_up_at_top() {\n    let mut state = setup_preview_state(100);\n    state.preview_scroll = 0;\n    \n    state.handle_key(KeyCode::Up);\n    assert_eq\\!(state.preview_scroll, 0);  // No change, already at top\n}\n\n#[test]\nfn test_scroll_down_at_bottom() {\n    let mut state = setup_preview_state(100);\n    state.preview_height = 10;\n    state.preview_scroll = 90;  // max_scroll = 100 - 10 = 90\n    \n    state.handle_key(KeyCode::Down);\n    assert_eq\\!(state.preview_scroll, 90);  // No change, already at bottom\n}\n\n#[test]\nfn test_page_down_scrolls_by_page() {\n    let mut state = setup_preview_state(100);\n    state.preview_height = 10;\n    \n    state.handle_key(KeyCode::PageDown);\n    assert_eq\\!(state.preview_scroll, 10);\n}\n\n#[test]\nfn test_jump_to_end() {\n    let mut state = setup_preview_state(100);\n    state.preview_height = 10;\n    \n    state.handle_key(KeyCode::End);  // or G\n    assert_eq\\!(state.preview_scroll, 90);\n}\n\n#[test]\nfn test_jump_to_top() {\n    let mut state = setup_preview_state(100);\n    state.preview_scroll = 50;\n    \n    state.handle_key(KeyCode::Home);  // or g\n    assert_eq\\!(state.preview_scroll, 0);\n}\n```\n\n### Line Wrapping Tests\n```rust\n#[test]\nfn test_long_lines_wrapped() {\n    let (storage, _dir) = test_storage();\n    let long_line = \"x\".repeat(200);  // Exceeds wrap width\n    storage.save_entry(\u0026long_line).unwrap();\n    \n    let mut state = PickerState::new(\u0026storage).unwrap();\n    state.handle_key(KeyCode::Tab);\n    \n    assert\\!(state.preview_lines.len() \u003e 1);  // Line was wrapped\n}\n\n#[test]\nfn test_multiline_content_preserved() {\n    let (storage, _dir) = test_storage();\n    storage.save_entry(\"line1\\nline2\\nline3\").unwrap();\n    \n    let mut state = PickerState::new(\u0026storage).unwrap();\n    state.handle_key(KeyCode::Tab);\n    \n    assert\\!(state.preview_lines.iter().any(|l| l.contains(\"line1\")));\n    assert\\!(state.preview_lines.iter().any(|l| l.contains(\"line2\")));\n    assert\\!(state.preview_lines.iter().any(|l| l.contains(\"line3\")));\n}\n```\n\n## Test Utilities\n```rust\nfn setup_preview_state(num_lines: usize) -\u003e PickerState {\n    let mut state = PickerState::default();\n    state.focus = Focus::Preview;\n    state.preview_lines = (0..num_lines).map(|i| format\\!(\"Line {}\", i)).collect();\n    state\n}\n```\n\n## Files to Modify\n- src/picker.rs: Add tests in #[cfg(test)] mod tests\n\n## Acceptance Criteria\n- [ ] All focus mode tests pass\n- [ ] All content loading tests pass\n- [ ] All scroll navigation tests pass\n- [ ] All line wrapping tests pass\n- [ ] Tests cover boundary conditions (top, bottom, empty)","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:44:17.015413899-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:19:06.536347561Z","closed_at":"2026-01-13T22:19:06.536347561Z","close_reason":"Added 14 unit tests for preview scrolling: Focus enum default, focus toggle, load_preview_content wrapping/multiline/scroll reset, max_preview_scroll calculations (short/long/exact fit), scroll bounds (saturating_sub, respects max), line wrapping edge cases (unicode, very long). All tests pass.","dependencies":[{"issue_id":"clipboard-pve.23","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:44:17.017307887-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.23","depends_on_id":"clipboard-pve.19","type":"blocks","created_at":"2026-01-13T15:44:53.385829201-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.24","title":"E2E tests for preview scrolling","description":"## Overview\nEnd-to-end test script for preview scrolling functionality, validating data layer support for full content viewing.\n\n## Test Script: tests/e2e_preview.sh\n\n```bash\n#!/bin/bash\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" \u0026\u0026 pwd)\"\nPROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"\nBINARY=\"$PROJECT_ROOT/target/release/clipstack\"\nTEST_DIR=$(mktemp -d)\ntrap \"rm -rf $TEST_DIR\" EXIT\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\npass() { echo -e \"${GREEN}✓ PASS${NC}: $1\"; }\nfail() { echo -e \"${RED}✗ FAIL${NC}: $1\"; exit 1; }\ninfo() { echo -e \"${YELLOW}INFO${NC}: $1\"; }\n\n# Build release binary\ninfo \"Building release binary...\"\ncargo build --release --manifest-path=\"$PROJECT_ROOT/Cargo.toml\"\n\n# Test 1: Store and retrieve multi-line content\ninfo \"Test 1: Multi-line content storage and retrieval\"\nMULTILINE_CONTENT=$(cat \u003c\u003c'CONTENT'\nLine 1: First line of content\nLine 2: Second line with more text\nLine 3: Third line\nLine 4: Fourth line\nLine 5: Fifth line - this should all be stored\nCONTENT\n)\necho \"$MULTILINE_CONTENT\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\n# Retrieve content and verify all lines present\nENTRY_ID=$(jq -r '.entries[0].id' \"$TEST_DIR/index.json\")\nCONTENT_FILE=\"$TEST_DIR/${ENTRY_ID}.txt\"\n\nif [ -f \"$CONTENT_FILE\" ]; then\n    pass \"Content file created\"\nelse\n    fail \"Content file not created: $CONTENT_FILE\"\nfi\n\nLINE_COUNT=$(wc -l \u003c \"$CONTENT_FILE\")\nif [ \"$LINE_COUNT\" -ge 5 ]; then\n    pass \"All lines stored in content file ($LINE_COUNT lines)\"\nelse\n    fail \"Expected at least 5 lines, got $LINE_COUNT\"\nfi\n\n# Test 2: Long content preserved beyond preview\ninfo \"Test 2: Long content beyond preview length\"\n# Create 200 lines of content\nLONG_CONTENT=\"\"\nfor i in $(seq 1 200); do\n    LONG_CONTENT=\"${LONG_CONTENT}Line $i: This is line number $i with some padding text\\n\"\ndone\necho -e \"$LONG_CONTENT\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\nENTRY_ID=$(jq -r '.entries[0].id' \"$TEST_DIR/index.json\")\nCONTENT_FILE=\"$TEST_DIR/${ENTRY_ID}.txt\"\n\nSTORED_LINES=$(wc -l \u003c \"$CONTENT_FILE\")\nif [ \"$STORED_LINES\" -ge 200 ]; then\n    pass \"Long content fully stored ($STORED_LINES lines)\"\nelse\n    fail \"Long content truncated, expected 200+ lines, got $STORED_LINES\"\nfi\n\n# Verify preview is truncated but content is full\nPREVIEW_LEN=$(jq -r '.entries[0].preview | length' \"$TEST_DIR/index.json\")\nCONTENT_LEN=$(wc -c \u003c \"$CONTENT_FILE\")\nif [ \"$CONTENT_LEN\" -gt \"$PREVIEW_LEN\" ]; then\n    pass \"Full content ($CONTENT_LEN bytes) larger than preview ($PREVIEW_LEN chars)\"\nelse\n    fail \"Content should be larger than preview\"\nfi\n\n# Test 3: Unicode content in preview mode\ninfo \"Test 3: Unicode content handling\"\nUNICODE_CONTENT=\"Line 1: Hello 世界\nLine 2: Emojis 🎉🚀✨\nLine 3: Japanese テスト\nLine 4: Mixed content αβγδ\"\necho \"$UNICODE_CONTENT\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\nENTRY_ID=$(jq -r '.entries[0].id' \"$TEST_DIR/index.json\")\nCONTENT_FILE=\"$TEST_DIR/${ENTRY_ID}.txt\"\n\nif grep -q \"世界\" \"$CONTENT_FILE\" \u0026\u0026 grep -q \"🎉\" \"$CONTENT_FILE\"; then\n    pass \"Unicode content preserved correctly\"\nelse\n    fail \"Unicode content corrupted\"\nfi\n\n# Test 4: Binary-safe content (no null byte corruption)\ninfo \"Test 4: Content with special characters\"\nSPECIAL_CONTENT=\"Tab:\there\nBackslash: \\\\ here\nQuote: \\\"here\\\"\nSingle: 'here'\"\necho \"$SPECIAL_CONTENT\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\nENTRY_ID=$(jq -r '.entries[0].id' \"$TEST_DIR/index.json\")\nCONTENT_FILE=\"$TEST_DIR/${ENTRY_ID}.txt\"\n\nif [ -s \"$CONTENT_FILE\" ]; then\n    pass \"Special characters handled without corruption\"\nelse\n    fail \"Content file empty or missing\"\nfi\n\necho \"\"\necho -e \"${GREEN}All preview E2E tests passed!${NC}\"\n```\n\n## Test Scenarios\n1. **Multi-line Storage**: Verify all lines stored and retrievable\n2. **Long Content**: 200+ lines fully preserved for scroll\n3. **Unicode**: Multi-language content not corrupted\n4. **Special Characters**: Tabs, quotes, backslashes preserved\n\n## Limitations\n- Cannot test interactive preview scrolling in automated tests\n- Tests verify data layer supports full content viewing\n\n## Files to Create\n- tests/e2e_preview.sh: E2E test script\n\n## Acceptance Criteria\n- [ ] Script is executable (chmod +x)\n- [ ] All test scenarios pass\n- [ ] Cleanup removes temp directory\n- [ ] Clear pass/fail output with colors\n- [ ] Script exits with non-zero on failure","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:44:45.978976243-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:22:20.389521547Z","closed_at":"2026-01-13T22:22:20.389521547Z","close_reason":"All 7 E2E tests pass: multi-line storage, long content (200 lines), unicode, special chars, long lines (500+ chars), stats command, list truncation","dependencies":[{"issue_id":"clipboard-pve.24","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:44:45.981000105-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.24","depends_on_id":"clipboard-pve.23","type":"blocks","created_at":"2026-01-13T15:44:53.425684727-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd","title":"Improvement #5: Configurable Max Entries","description":"Enable user customization of history limit via CLI flag and env var. This MUST be implemented FIRST as it changes the Storage::new() signature that all other code depends on. The current hardcoded MAX_ENTRIES=100 doesn't serve all users: power users want 500+, privacy-conscious want fewer. Implementation adds --max-entries flag, CLIPSTACK_MAX_ENTRIES env var, clamping to 1-10000 range, and automatic pruning when limit is reduced.","status":"closed","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:28:52.595506805-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:13:09.985663008Z","closed_at":"2026-01-13T22:13:09.985663008Z","close_reason":"All configurable max entries features complete: CLI flag, env var, clamping 1-10000, dynamic pruning, Storage API, with unit tests and E2E tests passing.","dependencies":[{"issue_id":"clipboard-tsd","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:30:09.278506803-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.16","title":"[#5] Add max_entries infrastructure (constants + Storage field)","description":"## Overview\nAdd the foundational constants and struct field needed for configurable max entries.\n\n## Code Changes in src/storage.rs\n\n### Add Constants (after existing consts)\n```rust\nconst DEFAULT_MAX_ENTRIES: usize = 100;\nconst ABSOLUTE_MAX_ENTRIES: usize = 10000;  // Safety limit\n```\n\n### Add Field to Storage Struct\n```rust\npub struct Storage {\n    base_dir: PathBuf,\n    max_entries: usize,  // NEW: cached limit for CLI/env override\n}\n```\n\n## Rationale\n- DEFAULT_MAX_ENTRIES maintains backwards compatibility (100 was the old hardcoded value)\n- ABSOLUTE_MAX_ENTRIES prevents users from accidentally setting unreasonably high values that would degrade performance\n- Caching max_entries in Storage enables runtime override via CLI/env without modifying stored index\n\n## Files Changed\n- src/storage.rs: Add 2 constants, add 1 struct field\n\n## Acceptance Criteria\n- [ ] Constants defined with correct values\n- [ ] Storage struct has max_entries field\n- [ ] Code compiles (field initialization comes in next bead)","status":"closed","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:12:24.149762803-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:01:13.046206182Z","closed_at":"2026-01-13T22:01:13.046206182Z","close_reason":"Constants and Storage field already implemented","dependencies":[{"issue_id":"clipboard-tsd.16","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:12:24.151526382-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.17","title":"[#5] Update Storage::new() signature with max_entries parameter","description":"## Overview\nChange Storage::new() to accept max_entries parameter. This is the CRITICAL change that affects all call sites.\n\n## Code Changes in src/storage.rs\n\n### Update Storage::new()\n```rust\nimpl Storage {\n    /// Create storage with specified max entries\n    pub fn new(base_dir: PathBuf, max_entries: usize) -\u003e Result\u003cSelf\u003e {\n        fs::create_dir_all(\u0026base_dir)\n            .with_context(|| format!(\"Failed to create storage dir: {:?}\", base_dir))?;\n        \n        // Clamp to valid range\n        let max_entries = max_entries.clamp(1, ABSOLUTE_MAX_ENTRIES);\n        \n        let storage = Self { base_dir, max_entries };\n        \n        // Sync to stored index (prunes if needed)\n        storage.sync_max_entries()?;\n        \n        Ok(storage)\n    }\n    \n    /// Get the configured max entries\n    pub fn max_entries(\u0026self) -\u003e usize {\n        self.max_entries\n    }\n    \n    /// Sync max_entries to stored index and prune if necessary\n    fn sync_max_entries(\u0026self) -\u003e Result\u003c()\u003e {\n        let mut index = self.load_index()?;\n        \n        if index.max_entries != self.max_entries {\n            index.max_entries = self.max_entries;\n            // Prune will be implemented in pinned feature; for now just update\n            self.save_index(\u0026index)?;\n        }\n        \n        Ok(())\n    }\n    \n    /// Convenience constructor with default max_entries\n    pub fn with_defaults(base_dir: PathBuf) -\u003e Result\u003cSelf\u003e {\n        Self::new(base_dir, DEFAULT_MAX_ENTRIES)\n    }\n}\n```\n\n## Why This Is Critical\nALL code that creates Storage must be updated:\n- main.rs: Multiple Storage::new() calls\n- daemon.rs: Daemon::new() creates Storage\n- picker.rs tests: Test fixtures create Storage\n\n## Acceptance Criteria\n- [ ] Storage::new() accepts max_entries parameter\n- [ ] Values clamped to 1-10000 range\n- [ ] max_entries() getter works\n- [ ] with_defaults() convenience constructor added\n- [ ] NOTE: Call sites will break until updated","status":"closed","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:12:31.715254948-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:01:14.061494352Z","closed_at":"2026-01-13T22:01:14.061494352Z","close_reason":"Storage::new signature, with_defaults, max_entries getter, sync_max_entries already implemented","dependencies":[{"issue_id":"clipboard-tsd.17","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:12:31.718609412-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.17","depends_on_id":"clipboard-tsd.16","type":"blocks","created_at":"2026-01-13T15:23:44.193873356-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.18","title":"[#5] Update all Storage::new() call sites (main.rs, daemon.rs)","description":"## Overview\nUpdate every location that creates Storage to use the new signature with max_entries.\n\n## Code Changes\n\n### src/main.rs - Determine max_entries from CLI/env\n```rust\nfn main() -\u003e Result\u003c()\u003e {\n    let cli = Cli::parse();\n    \n    // Determine max_entries: CLI \u003e env \u003e default (100)\n    let max_entries = cli\n        .max_entries\n        .map(|n| n as usize)\n        .or_else(|| {\n            std::env::var(\"CLIPSTACK_MAX_ENTRIES\")\n                .ok()\n                .and_then(|s| s.parse().ok())\n        })\n        .unwrap_or(100)\n        .clamp(1, 10000);\n    \n    // ... later ...\n    let storage = storage::Storage::new(storage_dir, max_entries)?;\n    // ...\n}\n```\n\n### src/main.rs - Update Daemon command\n```rust\nSome(Commands::Daemon) =\u003e {\n    let daemon = daemon::Daemon::new(\n        Some(storage.base_dir().to_path_buf()),\n        max_entries\n    )?;\n    // ...\n}\n```\n\n### src/daemon.rs - Update Daemon::new()\n```rust\nimpl Daemon {\n    pub fn new(storage_dir: Option\u003cPathBuf\u003e, max_entries: usize) -\u003e Result\u003cSelf\u003e {\n        Self::new_with_lock(storage_dir, max_entries, false)\n    }\n    \n    pub fn new_with_lock(\n        storage_dir: Option\u003cPathBuf\u003e,\n        max_entries: usize,\n        use_local_lock: bool,\n    ) -\u003e Result\u003cSelf\u003e {\n        let base_dir = storage_dir.unwrap_or_else(Storage::default_dir);\n        let storage = Storage::new(base_dir.clone(), max_entries)?;\n        // ...\n    }\n}\n```\n\n## Files Changed\n- src/main.rs: Add max_entries CLI/env parsing, update all Storage::new() calls, update Daemon call\n- src/daemon.rs: Update Daemon::new() and new_with_lock() signatures\n\n## Acceptance Criteria\n- [ ] All Storage::new() calls pass max_entries\n- [ ] Daemon::new() accepts and forwards max_entries\n- [ ] CLI flag --max-entries NOT YET ADDED (separate bead)\n- [ ] Code compiles and runs with defaults","status":"closed","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:13:45.541870541-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:02:13.415254024Z","closed_at":"2026-01-13T22:02:13.415254024Z","close_reason":"Updated all Storage::new() and Daemon::new() call sites to pass max_entries parameter, added env var parsing","dependencies":[{"issue_id":"clipboard-tsd.18","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:13:45.543737943-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.18","depends_on_id":"clipboard-tsd.17","type":"blocks","created_at":"2026-01-13T15:23:44.229808375-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.19","title":"[#5] Add --max-entries CLI flag and CLIPSTACK_MAX_ENTRIES env var","description":"## Overview\nAdd the user-facing configuration options: CLI flag and environment variable.\n\n## Code Changes in src/main.rs\n\n### Add CLI Flag to Struct\n```rust\n#[derive(Parser)]\n#[command(name = \"clipstack\")]\n#[command(about = \"Fast clipboard manager with lazy-loading history\")]\n#[command(version)]\nstruct Cli {\n    /// Custom storage directory\n    #[arg(long, global = true)]\n    storage_dir: Option\u003cPathBuf\u003e,\n    \n    /// Maximum entries to store (1-10000, default: 100)\n    /// Can also be set via CLIPSTACK_MAX_ENTRIES environment variable\n    #[arg(long, global = true, value_parser = clap::value_parser!(u32).range(1..=10000))]\n    max_entries: Option\u003cu32\u003e,\n    \n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n}\n```\n\n## Environment Variable\nThe env var is already parsed in the call sites bead. This bead ensures:\n- Help text documents the env var\n- CLI flag takes precedence over env var\n- Both are validated to 1-10000 range\n\n## Configuration Priority (documented in help)\n1. --max-entries N (CLI flag, highest priority)\n2. CLIPSTACK_MAX_ENTRIES (environment variable)\n3. 100 (default)\n\n## Acceptance Criteria\n- [ ] --max-entries flag works: clipstack --max-entries 500 stats\n- [ ] Env var works: CLIPSTACK_MAX_ENTRIES=500 clipstack stats\n- [ ] CLI overrides env: CLIPSTACK_MAX_ENTRIES=100 clipstack --max-entries 200 stats (uses 200)\n- [ ] Help text shows both options","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:13:48.633518462-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:03:57.706182118Z","closed_at":"2026-01-13T22:03:57.706182118Z","close_reason":"Added --max-entries CLI flag with priority over env var, help text documents both options","dependencies":[{"issue_id":"clipboard-tsd.19","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:13:48.635304442-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.19","depends_on_id":"clipboard-tsd.18","type":"blocks","created_at":"2026-01-13T15:23:44.265098619-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.20","title":"[#5] Update Stats and Status commands to show max_entries info","description":"## Overview\nShow configuration information in stats and status commands so users can verify their settings.\n\n## Code Changes in src/main.rs\n\n### Update Stats Command\n```rust\nSome(Commands::Stats) =\u003e {\n    let index = storage.load_index()?;\n    let total_size: usize = index.entries.iter().map(|e| e.size).sum();\n    let pinned_count = index.entries.iter().filter(|e| e.pinned).count();\n    let unpinned_count = index.entries.len() - pinned_count;\n    \n    println!(\"Entries:    {}\", index.entries.len());\n    println!(\"  Pinned:   {} (protected)\", pinned_count);\n    println!(\"  Regular:  {}/{}\", unpinned_count, storage.max_entries());\n    println!(\"Total size: {}\", util::format_size(total_size));\n    \n    if let Some(oldest) = index.entries.last() {\n        println!(\"Oldest:     {}\", util::format_relative_time(oldest.timestamp));\n    }\n    if let Some(newest) = index.entries.first() {\n        println!(\"Newest:     {}\", util::format_relative_time(newest.timestamp));\n    }\n}\n```\n\n### Update Status Command\n```rust\nSome(Commands::Status) =\u003e {\n    print_status(\u0026storage)?;\n    \n    println!();\n    println!(\"Configuration:\");\n    println!(\"  Max entries: {}\", storage.max_entries());\n    \n    if std::env::var(\"CLIPSTACK_MAX_ENTRIES\").is_ok() {\n        println!(\"  (from CLIPSTACK_MAX_ENTRIES env var)\");\n    }\n}\n```\n\n## Files Changed\n- src/main.rs: Update Stats and Status command handlers\n\n## Acceptance Criteria\n- [ ] stats shows Regular: X/Y where Y is max_entries\n- [ ] status shows Configuration section with max entries\n- [ ] status indicates source (env var) when applicable","status":"closed","priority":3,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:14:10.673120121-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:19:18.768870333Z","closed_at":"2026-01-13T22:19:18.768870333Z","close_reason":"Stats shows Entries: X/Y format; Status shows Config section with max_entries and source (default/env). E2E tests updated to match new output formats. All tests pass.","dependencies":[{"issue_id":"clipboard-tsd.20","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:14:10.67486761-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.20","depends_on_id":"clipboard-tsd.18","type":"blocks","created_at":"2026-01-13T15:23:44.300711452-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.21","title":"[#5] Write comprehensive unit tests for configurable max entries","description":"## Overview\nTDD: Write comprehensive unit tests that verify all max_entries functionality.\n\n## Test Cases (copy-paste ready)\n\n```rust\n#[cfg(test)]\nmod max_entries_tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_custom_max_entries() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 5).unwrap();\n        \n        // Fill beyond limit\n        for i in 0..10 {\n            storage.save_entry(\u0026format!(\"entry {}\", i)).unwrap();\n        }\n        \n        let index = storage.load_index().unwrap();\n        assert_eq!(index.entries.len(), 5);\n        assert_eq!(index.max_entries, 5);\n    }\n    \n    #[test]\n    fn test_max_entries_clamps_low() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 0).unwrap();\n        assert_eq!(storage.max_entries(), 1);\n    }\n    \n    #[test]\n    fn test_max_entries_clamps_high() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 999999).unwrap();\n        assert_eq!(storage.max_entries(), 10000);\n    }\n    \n    #[test]\n    fn test_reducing_max_entries_prunes_immediately() {\n        let dir = TempDir::new().unwrap();\n        \n        // Create with high limit\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        for i in 0..50 {\n            storage.save_entry(\u0026format!(\"entry {}\", i)).unwrap();\n        }\n        \n        // Recreate with lower limit - should prune\n        let storage = Storage::new(dir.path().to_path_buf(), 10).unwrap();\n        let index = storage.load_index().unwrap();\n        \n        assert_eq!(index.entries.len(), 10);\n    }\n    \n    #[test]\n    fn test_max_entries_getter() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 42).unwrap();\n        assert_eq!(storage.max_entries(), 42);\n    }\n    \n    #[test]\n    fn test_with_defaults_uses_100() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::with_defaults(dir.path().to_path_buf()).unwrap();\n        assert_eq!(storage.max_entries(), 100);\n    }\n    \n    #[test]\n    fn test_update_test_fixtures() {\n        // All test fixtures in picker.rs and elsewhere should compile\n        // with new Storage::new(path, max_entries) signature\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let _picker = Picker::new(storage).unwrap();\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add test module or update existing\n\n## Acceptance Criteria\n- [ ] All 7 tests pass\n- [ ] Tests run: cargo test max_entries\n- [ ] No test failures block the build","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:14:43.929130523-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:05:32.911613545Z","closed_at":"2026-01-13T22:05:32.911613545Z","close_reason":"All 6 unit tests for configurable max entries pass (custom max, clamp low/high, reducing prunes, getter, with_defaults)","dependencies":[{"issue_id":"clipboard-tsd.21","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:14:43.930916584-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.21","depends_on_id":"clipboard-tsd.17","type":"blocks","created_at":"2026-01-13T15:23:44.335948536-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.22","title":"[#5] Write E2E test script for configurable max entries","description":"## Overview\nCreate an end-to-end test script that verifies the configurable max entries feature works correctly in practice.\n\n## E2E Test Script (tests/e2e_max_entries.sh)\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# E2E Tests for Configurable Max Entries\n# Run from project root: ./tests/e2e_max_entries.sh\n\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nTEST_DIR=$(mktemp -d)\nCLIPSTACK=\"./target/release/clipstack\"\n\nlog_pass() { echo -e \"${GREEN}✓${NC} $1\"; }\nlog_fail() { echo -e \"${RED}✗${NC} $1\"; exit 1; }\nlog_info() { echo -e \"${YELLOW}→${NC} $1\"; }\n\ncleanup() { rm -rf \"$TEST_DIR\"; }\ntrap cleanup EXIT\n\n# Build release if needed\nif [[ ! -f \"$CLIPSTACK\" ]]; then\n    log_info \"Building release binary...\"\n    cargo build --release\nfi\n\nlog_info \"Test directory: $TEST_DIR\"\n\n# Test 1: Default max_entries is 100\nlog_info \"Test 1: Default max_entries\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test1\" stats 2\u003e/dev/null || true\n$CLIPSTACK --storage-dir \"$TEST_DIR/test1\" status | grep -q \"Max entries: 100\" \u0026\u0026 \\\n    log_pass \"Default is 100\" || log_fail \"Default should be 100\"\n\n# Test 2: CLI flag overrides default\nlog_info \"Test 2: CLI flag\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test2\" --max-entries 50 stats \u003e/dev/null\n$CLIPSTACK --storage-dir \"$TEST_DIR/test2\" --max-entries 50 status | grep -q \"Max entries: 50\" \u0026\u0026 \\\n    log_pass \"CLI flag works\" || log_fail \"CLI flag should set max_entries\"\n\n# Test 3: Environment variable works\nlog_info \"Test 3: Environment variable\"\nCLIPSTACK_MAX_ENTRIES=75 $CLIPSTACK --storage-dir \"$TEST_DIR/test3\" stats \u003e/dev/null\nCLIPSTACK_MAX_ENTRIES=75 $CLIPSTACK --storage-dir \"$TEST_DIR/test3\" status | grep -q \"Max entries: 75\" \u0026\u0026 \\\n    log_pass \"Env var works\" || log_fail \"Env var should set max_entries\"\n\n# Test 4: CLI takes precedence over env var\nlog_info \"Test 4: CLI precedence\"\nCLIPSTACK_MAX_ENTRIES=100 $CLIPSTACK --storage-dir \"$TEST_DIR/test4\" --max-entries 200 status | \\\n    grep -q \"Max entries: 200\" \u0026\u0026 \\\n    log_pass \"CLI overrides env\" || log_fail \"CLI should override env var\"\n\n# Test 5: Entries are pruned when limit exceeded\nlog_info \"Test 5: Pruning works\"\nfor i in {1..20}; do\n    echo \"entry $i\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test5\" --max-entries 10 copy\ndone\nCOUNT=$($CLIPSTACK --storage-dir \"$TEST_DIR/test5\" --max-entries 10 list 2\u003e/dev/null | wc -l)\n[[ \"$COUNT\" -le 12 ]] \u0026\u0026 log_pass \"Pruning works ($COUNT entries)\" || \\\n    log_fail \"Should have ~10 entries, got $COUNT\"\n\n# Test 6: Value clamping\nlog_info \"Test 6: Value clamping\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test6\" --max-entries 0 status 2\u003e\u00261 | \\\n    grep -qE \"(Max entries: 1|invalid)\" \u0026\u0026 \\\n    log_pass \"Low values clamped/rejected\" || log_fail \"Should clamp 0 to 1\"\n\necho \"\"\necho -e \"${GREEN}All E2E tests passed!${NC}\"\n```\n\n## Logging Requirements\n- Each test logs what it's testing\n- Pass/fail shown with colored output\n- Temp directory auto-cleaned\n\n## Acceptance Criteria\n- [ ] Script created at tests/e2e_max_entries.sh\n- [ ] Script is executable (chmod +x)\n- [ ] All 6 tests pass on clean install\n- [ ] Script cleans up after itself","status":"closed","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:23:33.498837729-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T22:12:22.796560566Z","closed_at":"2026-01-13T22:12:22.796560566Z","close_reason":"E2E test script created at tests/e2e_max_entries.sh with 8 tests: default value, CLI flag, env var, CLI precedence, pruning, value clamping (low/high), dynamic pruning. All tests pass.","dependencies":[{"issue_id":"clipboard-tsd.22","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:23:33.50059574-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.22","depends_on_id":"clipboard-tsd.21","type":"blocks","created_at":"2026-01-13T15:23:44.371888785-05:00","created_by":"solsystemlabs"}]}
