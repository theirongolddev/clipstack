{"id":"clipboard-0nf","title":"ClipStack v1.1 Upgrade - Comprehensive Enhancement Suite","status":"open","priority":1,"issue_type":"epic","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:27:55.937476986-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T12:27:55.937476986-05:00","comments":[{"id":1,"issue_id":"clipboard-0nf","author":"solsystemlabs","text":"# ClipStack v1.1 Upgrade Epic - Full Documentation\n\n## Executive Overview\n\nThis epic encompasses five strategically-selected improvements to transform ClipStack from a functional clipboard manager into a robust, user-friendly tool that competes with established alternatives. Each improvement addresses a real user need or reliability concern while remaining pragmatic and well-scoped.\n\n## Rationale \u0026 Business Value\n\nClipStack's core value proposition is \"never lose clipboard history\" - yet several gaps undermine this promise:\n\n1. **Usability Gap**: Search only matches 100-char previews, missing content buried deeper\n2. **Feature Gap**: No way to protect important entries from automatic pruning\n3. **Reliability Gap**: Non-atomic writes risk data corruption on interruption\n4. **UX Gap**: Cannot scroll preview content without pasting first\n5. **Flexibility Gap**: Hardcoded 100-entry limit doesn't suit all users\n\n## Design Principles (MUST be followed)\n\n1. **Backwards Compatibility**: Existing storage format remains readable; new fields use `#[serde(default)]`\n2. **Progressive Enhancement**: New features don't change existing workflows unless user opts in\n3. **Minimal Dependencies**: No new crate dependencies unless absolutely necessary\n4. **Test-Driven Development**: Each improvement includes comprehensive tests BEFORE implementation\n\n## Implementation Phases\n\n### Phase 1: Foundation (MUST complete first)\n- Improvement #5: Configurable Max Entries - Changes Storage::new() signature that everything depends on\n- Improvement #3: Atomic File Writes - Adds reliability foundation before other changes\n\n### Phase 2: Storage Features\n- Improvement #2: Pinned/Favorites - Adds pinned field to ClipEntry, modifies pruning logic\n\n### Phase 3: Picker Features\n- Improvement #1: Full Content Search - Major picker refactor (FilteredEntry type)\n- Improvement #4: Preview Scrolling - Adds focus mode and scroll state\n\n## Critical Success Metrics\n\n- All existing tests continue to pass\n- No clippy warnings\n- Release build compiles successfully\n- Performance remains acceptable (\u003c500ms search for 100 entries)\n- Upgrade from old storage format works seamlessly\n\n## Key Files Affected\n\n| File | Scope of Changes |\n|------|------------------|\n| src/storage.rs | pinned field, max_entries param, atomic_write(), toggle_pin(), recovery |\n| src/picker.rs | FilteredEntry, MatchLocation, Focus, preview scroll, focus mode, pin toggle |\n| src/main.rs | --max-entries flag, Recover command, daemon/stats/status updates |\n| src/daemon.rs | new() signature update for max_entries |\n\n## Estimated Total Lines Changed: 800-1000\n\n## References\n\n- docs/IMPLEMENTATION_SPEC.md - Complete, copy-paste-ready code for all features\n- docs/UPGRADE_PLAN.md - Strategic rationale and design decisions\n- AGENTS.md - Workflow instructions and session protocols\n","created_at":"2026-01-13T17:28:36Z"}]}
{"id":"clipboard-0nf.1","title":"Integration test: All v1.1 features work together","description":"Create comprehensive integration test (tests/integration/test_v11_features.sh) that verifies all v1.1 features work correctly together. Tests:\n\nCROSS-FEATURE SCENARIOS:\n1. Configurable limits + Pinned entries\n   - Set max_entries=20, pin 5 entries, add 25 more\n   - Verify: 25 total (5 pinned + 20 unpinned), oldest unpinned pruned\n   \n2. Full content search + Pinned entries\n   - Pin entry with deep content match, search for it\n   - Verify: Found with ★ indicator AND [+] content match indicator\n   \n3. Preview scrolling + Long pinned entries\n   - Pin entry with 500 lines, scroll to line 200\n   - Verify: Scroll works, ★ indicator persists\n   \n4. Atomic writes + Pin toggle\n   - Toggle pin during simulated crash (kill -9 during write)\n   - Verify: Either old or new state (no corruption)\n   \n5. Recovery + Pinned entries\n   - Corrupt index with pinned entries, run recover\n   - Verify: Recovered entries have pinned=false (expected)\n   \n6. All features respect max_entries configuration\n   - Test with CLI flag, env var, and default\n   - Verify: All features obey configured limit\n\nLOGGING: Same format as E2E tests (colored, numbered, summary)\nCLEANUP: Temp data dir per test\nEXIT: 0 if all pass, 1 if any fail","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T13:30:27.23528175-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T14:07:45.451901993-05:00","dependencies":[{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T13:30:27.237288834-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-tsd.15","type":"blocks","created_at":"2026-01-13T13:30:34.676200616-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-8u5.11","type":"blocks","created_at":"2026-01-13T13:30:35.054298974-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-b6y.20","type":"blocks","created_at":"2026-01-13T13:30:35.410364139-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-2wl.15","type":"blocks","created_at":"2026-01-13T13:30:35.782404535-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-pve.18","type":"blocks","created_at":"2026-01-13T13:30:36.145829236-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-tsd.22","type":"blocks","created_at":"2026-01-13T15:45:13.345911965-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-8u5.17","type":"blocks","created_at":"2026-01-13T15:45:13.384499725-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-b6y.27","type":"blocks","created_at":"2026-01-13T15:45:13.423789721-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-2wl.21","type":"blocks","created_at":"2026-01-13T15:45:13.462288244-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.1","depends_on_id":"clipboard-pve.24","type":"blocks","created_at":"2026-01-13T15:45:13.500720302-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-0nf.2","title":"Integration test: Daemon + Picker + Storage interaction","description":"Create integration test (tests/integration/test_component_interaction.sh) verifying daemon+picker+storage component interaction. Tests:\n\nCOMPONENT BOUNDARY SCENARIOS:\n1. Daemon saves → Picker sees immediately\n   - Start daemon, copy text via wl-copy\n   - Open picker within 500ms, verify entry visible\n   \n2. Picker changes → Daemon respects\n   - Open picker, delete entry, close picker\n   - Daemon next poll should see deletion (verify file removed)\n   \n3. Atomic writes during concurrent access\n   - Start daemon, open picker\n   - Rapidly copy 100 items while navigating picker\n   - Verify: No corruption, no .tmp files remaining\n   \n4. Lock file prevents multiple daemons\n   - Start daemon, try to start second\n   - Verify: Second exits with \"already running\" message\n   \n5. Graceful handling when daemon stops\n   - Open picker, stop daemon (kill -TERM)\n   - Navigate in picker (should work, just no new entries)\n   - Copy action should succeed (calls wl-copy directly)\n\nRACE CONDITION TESTS:\n6. Simultaneous pin toggle from two processes\n   - Use flock or similar to test contention\n   - Verify: No corruption, one wins\n\nLOGGING: Same format as E2E tests\nCLEANUP: Temp data dir, kill any stray daemon processes\nEXIT: 0 if all pass, 1 if any fail","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T13:30:27.608504769-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T14:09:54.411050415-05:00","dependencies":[{"issue_id":"clipboard-0nf.2","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T13:30:27.610420482-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-0nf.2","depends_on_id":"clipboard-8u5","type":"blocks","created_at":"2026-01-13T14:01:13.313961839-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-1m3","title":"ClipStack v2.0 Upgrade: 5 Strategic Improvements","description":"# ClipStack v2.0 Upgrade Epic\n\n## Overview\nThis epic encompasses a comprehensive upgrade to ClipStack, transforming it from a functional \nclipboard manager into a polished, feature-rich tool. The upgrade consists of 5 strategic \nimprovements that address real user pain points identified through usage analysis.\n\n## Strategic Goals\n1. **Data Safety**: Prevent data loss from interrupted writes or corruption\n2. **Content Discovery**: Find clipboard entries even when content is buried deep\n3. **Persistence Control**: Protect important entries from automatic pruning\n4. **Content Inspection**: View large clipboard entries without leaving the picker\n5. **Flexibility**: Accommodate different user workflows with configurable limits\n\n## Implementation Philosophy\n- TDD methodology: Tests FIRST, then implementation\n- Atomic commits: One improvement per commit for clean history\n- Backwards compatibility: Old storage formats must continue to work\n- Minimal dependencies: Reuse existing patterns where possible\n\n## Phase Structure\nThe improvements are organized into 3 phases based on dependencies:\n\n### Phase 1: Foundation (MUST be done first)\n- Feature 5: Configurable Max Entries - Changes Storage::new() signature\n- Feature 3: Atomic File Writes - Adds data safety layer\n\n### Phase 2: Storage Features\n- Feature 2: Pinned/Favorites - Depends on new Storage API\n\n### Phase 3: Picker Features  \n- Feature 1: Full Content Search - Major picker refactor\n- Feature 4: Preview Scrolling - Builds on picker changes\n\n## Success Criteria\n- All existing tests continue to pass\n- No clippy warnings\n- Manual integration testing passes all checkpoints\n- Upgrade from old storage format works seamlessly\n- All 5 features work together without conflicts\n\n## Risk Mitigation\n- Phase 1 provides atomic writes BEFORE adding complex features\n- Each feature is independently testable\n- Recovery command provides escape hatch for corruption\n\n## Reference Documents\n- docs/IMPLEMENTATION_SPEC.md - Complete code specifications\n- docs/UPGRADE_PLAN.md - Original analysis and selection rationale","status":"tombstone","priority":1,"issue_type":"epic","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:15:54.788218874-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T12:18:35.332419764-05:00","deleted_at":"2026-01-13T12:18:35.332419764-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"epic"}
{"id":"clipboard-2wl","title":"Improvement #1: Full Content Search","description":"HIGHEST IMPACT improvement. Currently search only matches 100-char preview, missing content buried deeper. User copies 500-line file, searches for function name on line 247 - search finds nothing! This undermines core value prop. Solution: two-phase search - Phase 1 searches previews (fast), Phase 2 loads and searches full content for non-matches. Visual indicator [+] shows content-only matches.","status":"open","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:35:25.658108397-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T12:35:25.658108397-05:00","dependencies":[{"issue_id":"clipboard-2wl","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:36:36.790625926-05:00","created_by":"solsystemlabs"}],"comments":[{"id":5,"issue_id":"clipboard-2wl","author":"solsystemlabs","text":"# Improvement #1: Full Content Search - Detailed Documentation\n\n## Problem Statement - HIGHEST IMPACT FIX\n\nCurrently, ClipStack's fuzzy search only matches against the 100-character preview stored in `index.json`. This creates a CRITICAL usability gap:\n\n```\nUser copies a 500-line code file\nUser wants to find it by searching for \"handleAuthentication\"\nThat function name appears on line 247\nSearch finds nothing because preview only contains lines 1-3\nUser cannot find their content\n```\n\nThis limitation undermines THE CORE VALUE PROPOSITION of a clipboard history manager: **finding content you copied in the past**.\n\n## Current Broken Behavior\n\n```rust\n// picker.rs - BUG: Only searches preview, not full content\nfn update_filter(\u0026mut self) {\n    // ...\n    self.matcher.fuzzy_match(\u0026entry.preview, \u0026self.search_query)\n    // ^ PROBLEM: preview is only first 100 chars!\n}\n```\n\n## Solution Design: Two-Phase Search\n\n### Phase 1 (Fast): Search previews first\n- Already in memory, no I/O\n- Most searches find matches here\n- Returns immediately with results\n\n### Phase 2 (Thorough): For non-matches, load full content\n- Only triggered when preview search fails\n- Loads content files from disk\n- Enforces limits to prevent expensive I/O\n\nThis approach balances performance with completeness.\n\n## Implementation Requirements\n\n### New Types\n\n```rust\n/// Tracks whether a match was found in preview or full content\n#[derive(Clone, Copy, PartialEq)]\nenum MatchLocation {\n    Preview,\n    FullContent,\n}\n\n/// Replaces Vec\u003cusize\u003e - tracks index + match metadata\nstruct FilteredEntry {\n    index: usize,\n    score: i64,\n    match_location: MatchLocation,\n}\n```\n\n### Constants (Performance Limits)\n\n```rust\nconst MAX_CONTENT_SEARCHES: usize = 50;   // Max files to load\nconst MAX_CONTENT_MATCHES: usize = 10;    // Stop after 10 content matches\nconst MIN_QUERY_FOR_CONTENT_SEARCH: usize = 2;  // Need 2+ chars\n```\n\n### Design Decision: Score Penalty for Content Matches\n\nContent-only matches receive 80% of their raw score:\n```rust\nscore: score * 8 / 10,  // Slightly lower for content matches\n```\n\n**Rationale**: When a term appears in both preview and content, the preview match is more relevant (user saw it recently). Content matches are \"found by digging\" - useful but secondary.\n\n### Major Refactor: Picker::filtered Type Change\n\n**This is a BREAKING change within picker.rs.**\n\n```rust\n// OLD\nfiltered: Vec\u003cusize\u003e,\n\n// NEW\nfiltered: Vec\u003cFilteredEntry\u003e,\n```\n\nAll methods that access `self.filtered` must be updated:\n- `selected_entry()` - use `filtered[i].index`\n- `render_list()` - iterate FilteredEntry, show [+] indicator\n- `update_filter()` - return Vec\u003cFilteredEntry\u003e\n- `move_selection()` - no change (still uses filtered.len())\n\n### Visual Indicator for Content Matches\n\n```\n┌─History (2/847) matching 'handleAuth'─────────┐\n│\u003e 2h ago [  12KB] import { auth } from...      │ ← Preview match (normal)\n│  5d ago [  45KB] /** API routes */ ...    [+] │ ← Content match (indicator)\n└───────────────────────────────────────────────┘\n```\n\nThe `[+]` indicator (yellow color) shows this entry matched on full content, not preview.\n\n## Testing Requirements (TDD)\n\n1. `test_search_finds_preview_match()` - Basic preview match works\n2. `test_search_finds_content_match()` - Content beyond preview is found\n3. `test_preview_matches_rank_higher()` - Same term, preview \u003e content\n4. `test_search_performance_large_history()` - \u003c500ms with 100 entries\n5. `test_content_search_limits_respected()` - MAX_CONTENT_SEARCHES enforced\n\n## Performance Considerations\n\n1. **Lazy Loading**: Full content only loaded when preview search fails\n2. **Early Termination**: Stop after MAX_CONTENT_MATCHES content matches\n3. **Query Length Gate**: Only search content for queries ≥2 characters\n4. **Score Threshold**: Consider skipping content search if preview matches are strong\n\n## Edge Cases\n\n### Query Too Short\n- Single character queries don't trigger content search\n- Too many false positives from single chars\n\n### All Entries Already Match Preview\n- No content search needed\n- Phase 2 skipped entirely\n\n### Large Content Files\n- Content search reads full file\n- Consider adding size limit for content search (e.g., skip files \u003e1MB)\n\n## Success Criteria\n\n- [ ] Searches find content beyond the 100-char preview\n- [ ] Preview matches still rank higher than content-only matches\n- [ ] Visual indicator [+] distinguishes match location\n- [ ] Performance remains acceptable (\u003c500ms for 100 entries)\n- [ ] All existing tests pass\n- [ ] New tests cover edge cases\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| src/picker.rs | MatchLocation, FilteredEntry, two-phase search, [+] indicator, update all filtered accessors |\n\n## Dependencies\n\n- **Depends on**: Improvement #2 (for FilteredEntry to include pin status eventually)\n- **Note**: This can technically run in parallel with #4 but should be done first since it changes the filtered type significantly\n","created_at":"2026-01-13T17:36:36Z"}]}
{"id":"clipboard-2wl.1","title":"[#1] Define MatchLocation enum","description":"#[derive(Clone, Copy, PartialEq)] enum MatchLocation { Preview, FullContent }. Tracks whether search match was found in preview or full content. Used for visual indicator and score adjustment.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:05.877555637-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.1","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:05.879155929-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.10","title":"[#1] Write unit tests for preview matching","description":"test_search_finds_preview_match(): save entry with searchable preview, verify filtered contains match with MatchLocation::Preview.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:25.057011184-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.10","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:25.05874797-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.10","depends_on_id":"clipboard-2wl.4","type":"blocks","created_at":"2026-01-13T14:00:05.657797261-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.11","title":"[#1] Write unit tests for content matching","description":"test_search_finds_content_match(): save entry where searchable text is beyond 100-char preview (pad with 200+ chars first). Verify found with MatchLocation::FullContent.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:27.173519303-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.11","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:27.174964474-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.11","depends_on_id":"clipboard-2wl.4","type":"blocks","created_at":"2026-01-13T14:00:05.700893254-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.12","title":"[#1] Write unit tests for ranking (preview \u003e content)","description":"test_preview_matches_rank_higher(): create two entries with same search term, one in preview, one in content. Verify preview match sorts first due to score penalty.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:29.310849832-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.12","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:29.312919281-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.12","depends_on_id":"clipboard-2wl.4","type":"blocks","created_at":"2026-01-13T14:00:05.744102871-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.13","title":"[#1] Write performance tests for search","description":"test_search_performance_large_history(): create 100 entries, search for nonexistent term (triggers full content scan). Assert \u003c2 seconds. Verifies limits work.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:31.658256856-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.13","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:31.65990695-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.13","depends_on_id":"clipboard-2wl.3","type":"blocks","created_at":"2026-01-13T14:00:05.789160226-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.14","title":"[#1] Update selected_entry() for FilteredEntry type","description":"Change from self.entries[self.filtered[i]] to self.entries[self.filtered[i].index]. All index access needs this pattern.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:37.792769499-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.14","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:37.794261768-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.14","depends_on_id":"clipboard-2wl.4","type":"blocks","created_at":"2026-01-13T12:39:20.563263302-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.15","title":"[#1] Write E2E test script for full content search","description":"Create comprehensive E2E test script (tests/e2e/test_full_content_search.sh) that verifies two-phase search behavior via picker. Tests:\n1. Preview matches found quickly (phase 1) - search term in first 100 chars\n2. Content-only matches found (phase 2) - term buried at line 250 of large file\n3. Preview matches rank higher than content matches for same term\n4. [+] indicator shown for content-only matches in picker output\n5. Performance acceptable (\u003c500ms for 100 entries with full content scan)\n6. Content search limits enforced (MAX_CONTENT_SEARCHES=50, verify no more than 50 files read)\n\nLOGGING REQUIREMENTS:\n- Use colored output: GREEN=pass, RED=fail, YELLOW=info, CYAN=timing\n- Each test prints: [TEST N] Description... followed by result\n- For phase tests, show: \"Phase 1 matches: N, Phase 2 matches: M\"\n- For performance tests, show timing: \"Search completed in Xms (limit: 500ms)\"\n- Show match locations: \"Found at: preview|content\"\n- Print summary at end: \"X/Y tests passed\"\n- Exit code: 0 if all pass, 1 if any fail\n\nCLEANUP: Create temp CLIPSTACK_DATA_DIR per test, remove after each test\n\nExample output format:\n[TEST 2] Content-only match (buried deep)...\n  Creating entry with 500 lines, search term on line 250...\n  Running search for \"handleAuthentication\"...\n  Phase 1 matches: 0\n  Phase 2 matches: 1 (scanned 1 files)\n  Match location: content (expected: content)\n  ✓ PASS","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T13:29:59.750380222-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.15","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T13:29:59.75240013-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.15","depends_on_id":"clipboard-2wl.13","type":"blocks","created_at":"2026-01-13T13:30:10.218506195-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.16","title":"Add FilteredEntry type and MatchLocation enum","description":"## Overview\nAdd the core data structures for full content search in src/picker.rs.\n\n## Implementation Details\n\n### MatchLocation Enum\n```rust\n#[derive(Clone, Copy, PartialEq)]\nenum MatchLocation {\n    Preview,   // Match found in preview (fast path)\n    Content,   // Match found in full content (required loading)\n}\n```\n\n### FilteredEntry Struct\n```rust\nstruct FilteredEntry {\n    index: usize,           // Index into original entries list\n    score: i64,             // Fuzzy match score (higher = better)\n    match_location: MatchLocation,  // Where match was found\n}\n```\n\n## Key Design Decisions\n- FilteredEntry wraps index instead of cloning ClipEntry (memory efficient)\n- MatchLocation tracks search phase for UX feedback\n- Score uses i64 to accommodate fuzzy-matcher scoring range\n\n## Files to Modify\n- src/picker.rs: Add types after imports, before PickerState\n\n## Acceptance Criteria\n- [ ] MatchLocation enum with Preview and Content variants\n- [ ] FilteredEntry struct with index, score, match_location fields\n- [ ] Both types derive necessary traits (Clone, Copy for enum)\n- [ ] Code compiles without warnings","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:41:09.741655568-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:41:09.741655568-05:00","dependencies":[{"issue_id":"clipboard-2wl.16","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:41:09.743205212-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.17","title":"Implement two-phase search with scoring","description":"## Overview\nImplement the two-phase search algorithm in PickerState that searches preview first (fast), then falls back to full content search (lazy-loaded).\n\n## Implementation Details\n\n### Phase 1: Preview Search (Fast Path)\n```rust\nfn filter_entries(\u0026mut self, query: \u0026str, storage: \u0026Storage) -\u003e Vec\u003cFilteredEntry\u003e {\n    let matcher = SkimMatcherV2::default();\n    let mut results: Vec\u003cFilteredEntry\u003e = Vec::new();\n    \n    // Phase 1: Search previews (always available, fast)\n    for (idx, entry) in self.entries.iter().enumerate() {\n        if let Some((score, _)) = matcher.fuzzy_match(\u0026entry.preview, query) {\n            results.push(FilteredEntry {\n                index: idx,\n                score,\n                match_location: MatchLocation::Preview,\n            });\n        }\n    }\n    // ... continues to Phase 2\n}\n```\n\n### Phase 2: Content Search (Lazy Load)\n```rust\n    // Phase 2: For entries not matched in preview, search full content\n    let preview_matched: HashSet\u003cusize\u003e = results.iter().map(|r| r.index).collect();\n    \n    for (idx, entry) in self.entries.iter().enumerate() {\n        if preview_matched.contains(\u0026idx) {\n            continue;  // Already matched in preview\n        }\n        \n        // Lazy load content only when needed\n        if let Ok(content) = storage.load_content(\u0026entry.id) {\n            if let Some((score, _)) = matcher.fuzzy_match(\u0026content, query) {\n                results.push(FilteredEntry {\n                    index: idx,\n                    score,\n                    match_location: MatchLocation::Content,\n                });\n            }\n        }\n    }\n    \n    // Sort by score descending\n    results.sort_by(|a, b| b.score.cmp(\u0026a.score));\n    results\n}\n```\n\n## Key Design Decisions\n- Use HashSet for O(1) lookup of already-matched indices\n- Only load content for entries that did not match preview\n- Sort results by score for relevance ranking\n- Gracefully handle content load failures (skip entry)\n\n## Dependencies\n- Requires fuzzy-matcher crate: fuzzy-matcher = \"0.3\"\n- Use SkimMatcherV2 for sublime-text-like fuzzy matching\n\n## Files to Modify\n- src/picker.rs: Add filter_entries method to PickerState impl\n- Cargo.toml: Add fuzzy-matcher dependency if not present\n\n## Acceptance Criteria\n- [ ] filter_entries method implemented with two-phase search\n- [ ] Preview matches found without loading content\n- [ ] Content search only triggers for non-preview-matched entries\n- [ ] Results sorted by score descending\n- [ ] fuzzy-matcher dependency added to Cargo.toml","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:41:25.261377852-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:41:25.261377852-05:00","dependencies":[{"issue_id":"clipboard-2wl.17","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:41:25.263168267-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.17","depends_on_id":"clipboard-2wl.16","type":"blocks","created_at":"2026-01-13T15:42:44.887356442-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.18","title":"Update Picker UI for filtered search mode","description":"## Overview\nIntegrate the two-phase search into the Picker event loop, managing filtered state and search input.\n\n## Implementation Details\n\n### Add PickerState Fields\n```rust\nstruct PickerState {\n    // Existing fields...\n    filter_query: String,           // Current search query\n    filtered: Vec\u003cFilteredEntry\u003e,   // Current filtered results\n    in_filter_mode: bool,           // Whether actively filtering\n}\n```\n\n### Search Mode Entry (/ key)\n```rust\nKeyCode::Char('/') if \\!self.in_filter_mode =\u003e {\n    self.in_filter_mode = true;\n    self.filter_query.clear();\n    self.filtered = self.filter_entries(\"\", storage);\n}\n```\n\n### Character Input During Search\n```rust\nif self.in_filter_mode {\n    match key.code {\n        KeyCode::Char(c) =\u003e {\n            self.filter_query.push(c);\n            self.filtered = self.filter_entries(\u0026self.filter_query, storage);\n            self.selected = 0;  // Reset selection on query change\n        }\n        KeyCode::Backspace =\u003e {\n            self.filter_query.pop();\n            self.filtered = self.filter_entries(\u0026self.filter_query, storage);\n            self.selected = 0;\n        }\n        KeyCode::Esc =\u003e {\n            self.in_filter_mode = false;\n            self.filter_query.clear();\n            self.filtered.clear();\n        }\n        KeyCode::Enter =\u003e {\n            // Select filtered entry and exit filter mode\n            if let Some(fe) = self.filtered.get(self.selected) {\n                self.selected = fe.index;\n            }\n            self.in_filter_mode = false;\n            // Continue with normal Enter handling...\n        }\n        _ =\u003e {}\n    }\n}\n```\n\n### Selection Index Translation\nWhen in filter mode, selection indexes into filtered list, not entries:\n```rust\nfn current_entry(\u0026self) -\u003e Option\u003c\u0026ClipEntry\u003e {\n    if self.in_filter_mode \u0026\u0026 \\!self.filtered.is_empty() {\n        self.filtered.get(self.selected)\n            .and_then(|fe| self.entries.get(fe.index))\n    } else {\n        self.entries.get(self.selected)\n    }\n}\n```\n\n## Key Design Decisions\n- / key enters filter mode (vi-style)\n- Esc exits filter mode and clears query\n- Enter in filter mode selects entry AND exits filter mode\n- Selection resets to 0 when query changes for consistency\n- Up/Down navigate filtered results, not full list\n\n## Files to Modify\n- src/picker.rs: Update PickerState struct, handle_event, current_entry\n\n## Acceptance Criteria\n- [ ] PickerState has filter_query, filtered, in_filter_mode fields\n- [ ] / key enters search mode\n- [ ] Character input updates query and re-filters\n- [ ] Backspace removes last character\n- [ ] Esc exits filter mode\n- [ ] Enter selects filtered entry\n- [ ] Navigation works on filtered list when in filter mode","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:41:43.264912527-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:41:43.264912527-05:00","dependencies":[{"issue_id":"clipboard-2wl.18","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:41:43.266764277-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.18","depends_on_id":"clipboard-2wl.17","type":"blocks","created_at":"2026-01-13T15:42:44.926351185-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.19","title":"Update rendering for search mode and match indicators","description":"## Overview\nUpdate the Picker rendering to display search query input, match count, and indicate where matches were found.\n\n## Implementation Details\n\n### Title Bar with Search Query\n```rust\nfn render_title(\u0026self) -\u003e String {\n    if self.in_filter_mode {\n        format\\!(\"ClipStack - Search: {}_\", self.filter_query)\n    } else {\n        format\\!(\"ClipStack ({} entries)\", self.entries.len())\n    }\n}\n```\n\n### Match Count Status\n```rust\nfn render_status(\u0026self) -\u003e String {\n    if self.in_filter_mode {\n        let content_matches = self.filtered.iter()\n            .filter(|fe| fe.match_location == MatchLocation::Content)\n            .count();\n        if content_matches \u003e 0 {\n            format\\!(\"{} matches ({} in content)\", self.filtered.len(), content_matches)\n        } else {\n            format\\!(\"{} matches\", self.filtered.len())\n        }\n    } else {\n        // Normal status...\n    }\n}\n```\n\n### Match Location Indicator\nShow indicator when match is in content (not preview):\n```rust\nfn render_list_item(\u0026self, fe: \u0026FilteredEntry, entry: \u0026ClipEntry) -\u003e String {\n    let indicator = match fe.match_location {\n        MatchLocation::Preview =\u003e \"\",\n        MatchLocation::Content =\u003e \"[content] \",\n    };\n    format\\!(\"{}{}\", indicator, entry.preview)\n}\n```\n\n### Search Help Text\nShow keybindings in footer during search:\n```rust\nfn render_help(\u0026self) -\u003e String {\n    if self.in_filter_mode {\n        \"Type to search | Enter: select | Esc: cancel\"\n    } else {\n        \"/: search | Enter: paste | d: delete | q: quit\"\n    }\n}\n```\n\n## Key Design Decisions\n- Cursor indicator (_) shows active input\n- Match count helps user know search is working\n- Content match indicator distinguishes deep matches\n- Help text changes contextually for discoverability\n\n## Files to Modify\n- src/picker.rs: Update render methods\n\n## Acceptance Criteria\n- [ ] Title shows search query with cursor indicator\n- [ ] Status shows match count\n- [ ] Status shows content match count when \u003e 0\n- [ ] List items show [content] indicator for content matches\n- [ ] Help text shows search-mode keybindings","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:41:59.443663978-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:41:59.443663978-05:00","dependencies":[{"issue_id":"clipboard-2wl.19","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:41:59.44544212-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.19","depends_on_id":"clipboard-2wl.18","type":"blocks","created_at":"2026-01-13T15:42:44.965043913-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.2","title":"[#1] Define FilteredEntry struct","description":"struct FilteredEntry { index: usize, score: i64, match_location: MatchLocation }. Replaces Vec\u003cusize\u003e as Picker::filtered type. Carries match metadata for each filtered result.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:06.198122487-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.2","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:06.19973959-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.2","depends_on_id":"clipboard-2wl.1","type":"blocks","created_at":"2026-01-13T12:39:20.335372601-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.20","title":"Unit tests for full content search","description":"## Overview\nComprehensive unit test suite for the full content search functionality in storage.rs and picker.rs.\n\n## Test Cases\n\n### FilteredEntry Type Tests\n```rust\n#[test]\nfn test_filtered_entry_creation() {\n    let fe = FilteredEntry {\n        index: 5,\n        score: 100,\n        match_location: MatchLocation::Preview,\n    };\n    assert_eq\\!(fe.index, 5);\n    assert_eq\\!(fe.score, 100);\n    assert_eq\\!(fe.match_location, MatchLocation::Preview);\n}\n\n#[test]\nfn test_match_location_equality() {\n    assert_eq\\!(MatchLocation::Preview, MatchLocation::Preview);\n    assert_eq\\!(MatchLocation::Content, MatchLocation::Content);\n    assert_ne\\!(MatchLocation::Preview, MatchLocation::Content);\n}\n```\n\n### Search Algorithm Tests\n```rust\n#[test]\nfn test_preview_match_found_without_content_load() {\n    // Entry with \"hello world\" preview should match \"hello\"\n    // Verify content was NOT loaded (track load_content calls)\n}\n\n#[test]\nfn test_content_search_finds_non_preview_match() {\n    // Entry with truncated preview but full content containing search term\n    // Should find match with MatchLocation::Content\n}\n\n#[test]\nfn test_search_results_sorted_by_score() {\n    // Multiple matches with different scores\n    // Verify returned in score descending order\n}\n\n#[test]\nfn test_empty_query_returns_all_entries() {\n    // Empty string query should return all entries\n}\n\n#[test]\nfn test_no_matches_returns_empty() {\n    // Query with no matches returns empty vec\n}\n\n#[test]\nfn test_preview_match_prioritized_over_content() {\n    // Same entry matches in both preview and content\n    // Should only appear once with Preview location\n}\n```\n\n### Search UI State Tests\n```rust\n#[test]\nfn test_filter_mode_entry_exit() {\n    // / enters filter mode, Esc exits\n}\n\n#[test]\nfn test_query_updates_filtered_results() {\n    // Typing characters updates filtered list\n}\n\n#[test]\nfn test_backspace_removes_character() {\n    // Backspace shrinks query\n}\n\n#[test]\nfn test_selection_resets_on_query_change() {\n    // Selection goes to 0 when query changes\n}\n```\n\n## Test Utilities\n```rust\nfn create_test_entries(storage: \u0026Storage, contents: \u0026[\u0026str]) -\u003e Vec\u003cClipEntry\u003e {\n    contents.iter().map(|c| storage.save_entry(c).unwrap()).collect()\n}\n```\n\n## Files to Modify\n- src/picker.rs: Add #[cfg(test)] mod tests with search tests\n\n## Acceptance Criteria\n- [ ] All FilteredEntry type tests pass\n- [ ] All search algorithm tests pass\n- [ ] All UI state tests pass\n- [ ] Tests use real storage with tempfile for content loading\n- [ ] No flaky tests (deterministic results)","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:42:18.27505543-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:42:18.27505543-05:00","dependencies":[{"issue_id":"clipboard-2wl.20","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:42:18.27680043-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.20","depends_on_id":"clipboard-2wl.16","type":"blocks","created_at":"2026-01-13T15:42:45.006284415-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.21","title":"E2E tests for full content search","description":"## Overview\nEnd-to-end test script for full content search functionality using real clipboard operations.\n\n## Test Script: tests/e2e_search.sh\n\n```bash\n#\\!/bin/bash\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" \u0026\u0026 pwd)\"\nPROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"\nBINARY=\"$PROJECT_ROOT/target/release/clipstack\"\nTEST_DIR=$(mktemp -d)\ntrap \"rm -rf $TEST_DIR\" EXIT\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\npass() { echo -e \"${GREEN}✓ PASS${NC}: $1\"; }\nfail() { echo -e \"${RED}✗ FAIL${NC}: $1\"; exit 1; }\ninfo() { echo -e \"${YELLOW}INFO${NC}: $1\"; }\n\n# Build release binary\ninfo \"Building release binary...\"\ncargo build --release --manifest-path=\"$PROJECT_ROOT/Cargo.toml\"\n\n# Test 1: Search finds preview match\ninfo \"Test 1: Search finds preview match\"\necho \"unique_preview_text here\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n# Use expect/interact for picker or test via index\nINDEX=\"$TEST_DIR/index.json\"\nif grep -q \"unique_preview_text\" \"$INDEX\"; then\n    pass \"Preview text stored correctly\"\nelse\n    fail \"Preview text not found in index\"\nfi\n\n# Test 2: Search finds content-only match  \ninfo \"Test 2: Search finds content-only match\"\n# Create entry where search term is beyond preview length (100 chars)\nLONG_PREFIX=$(printf 'x%.0s' {1..110})\necho \"${LONG_PREFIX}findme_content_term\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\n# Verify search term is NOT in preview but IS in content file\nif grep -q \"findme_content\" \"$INDEX\"; then\n    fail \"Content-only term should not be in preview\"\nfi\n\n# Find the content file and verify term exists\nCONTENT_FILE=$(ls \"$TEST_DIR\"/*.txt | head -1)\nif grep -q \"findme_content_term\" \"$CONTENT_FILE\"; then\n    pass \"Content-only term stored in file\"\nelse\n    fail \"Content-only term not found in content file\"\nfi\n\n# Test 3: Empty search returns all entries\ninfo \"Test 3: Verify multiple entries stored\"\nENTRY_COUNT=$(jq '.entries | length' \"$INDEX\")\nif [ \"$ENTRY_COUNT\" -ge 2 ]; then\n    pass \"Multiple entries available for search ($ENTRY_COUNT)\"\nelse\n    fail \"Expected at least 2 entries, got $ENTRY_COUNT\"\nfi\n\n# Test 4: Search results are deterministic\ninfo \"Test 4: Verify index structure supports search\"\nif jq -e '.entries[0].preview' \"$INDEX\" \u003e /dev/null; then\n    pass \"Entries have preview field for search\"\nelse\n    fail \"Entries missing preview field\"\nfi\n\necho \"\"\necho -e \"${GREEN}All search E2E tests passed\\!${NC}\"\n```\n\n## Test Scenarios\n1. **Preview Match**: Search term in first 100 chars → found in preview\n2. **Content Match**: Search term beyond preview → requires content load\n3. **Multiple Entries**: Verify search works with multiple entries\n4. **Index Structure**: Verify data structure supports search\n\n## Limitations\n- Cannot test interactive picker in automated tests\n- Tests verify data layer supports search; UI tested via unit tests\n\n## Files to Create\n- tests/e2e_search.sh: E2E test script\n\n## Acceptance Criteria\n- [ ] Script is executable (chmod +x)\n- [ ] All test scenarios pass\n- [ ] Cleanup removes temp directory\n- [ ] Clear pass/fail output with colors\n- [ ] Script exits with non-zero on failure","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:42:39.400152846-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:42:39.400152846-05:00","dependencies":[{"issue_id":"clipboard-2wl.21","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T15:42:39.402072443-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.21","depends_on_id":"clipboard-2wl.20","type":"blocks","created_at":"2026-01-13T15:42:45.043871331-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-2wl.3","title":"[#1] Add search constants (MAX_CONTENT_SEARCHES, etc.)","description":"Add const MAX_CONTENT_SEARCHES: usize = 50 (max files to load), const MAX_CONTENT_MATCHES: usize = 10 (stop after 10), const MIN_QUERY_FOR_CONTENT_SEARCH: usize = 2 (need 2+ chars). Prevents unbounded disk I/O.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:07.525376751-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.3","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:07.531120759-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.4","title":"[#1] Change Picker::filtered type to Vec\u003cFilteredEntry\u003e","description":"BREAKING CHANGE: Change field type from Vec\u003cusize\u003e to Vec\u003cFilteredEntry\u003e. This affects ALL code that accesses self.filtered. Must update update_filter(), render_list(), selected_entry(), etc.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:09.69017291-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.4","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:09.691861156-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.4","depends_on_id":"clipboard-2wl.2","type":"blocks","created_at":"2026-01-13T12:39:20.374732925-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.5","title":"[#1] Implement Phase 1 search (preview matching)","description":"In update_filter(): iterate entries, fuzzy_match against preview. Build Vec\u003cFilteredEntry\u003e with MatchLocation::Preview. Collect unmatched indices for Phase 2. This is the fast path - in-memory only.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:11.934140332-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.5","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:11.936135752-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.5","depends_on_id":"clipboard-2wl.4","type":"blocks","created_at":"2026-01-13T12:39:20.411829497-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.5","depends_on_id":"clipboard-2wl.3","type":"blocks","created_at":"2026-01-13T12:39:20.450133727-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.6","title":"[#1] Implement Phase 2 search (content matching with limits)","description":"For unmatched entries from Phase 1: load full content from storage, fuzzy_match. Enforce limits: stop after MAX_CONTENT_MATCHES found, max MAX_CONTENT_SEARCHES file loads. Apply 80% score penalty. Only if query \u003e= MIN_QUERY_FOR_CONTENT_SEARCH chars.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:14.26276287-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.6","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:14.266864737-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.6","depends_on_id":"clipboard-2wl.5","type":"blocks","created_at":"2026-01-13T12:39:20.487118219-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.6","depends_on_id":"clipboard-2wl.3","type":"blocks","created_at":"2026-01-13T14:00:08.293338302-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.7","title":"[#1] Add selected_filtered() helper method","description":"Add method returning Option\u003c\u0026FilteredEntry\u003e for current selection. Provides access to match_location for UI decisions. Cleaner than repeatedly indexing into filtered.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:18.464686734-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.7","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:18.466116587-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.7","depends_on_id":"clipboard-2wl.4","type":"blocks","created_at":"2026-01-13T12:39:20.524666355-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.8","title":"[#1] Update render_list() for [+] content match indicator","description":"In render_list(): check filtered.match_location. If FullContent, append Span::styled(' [+]', Color::Yellow). Shows user that match was found in content, not preview.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:20.597689405-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.8","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:20.599428807-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.8","depends_on_id":"clipboard-2wl.4","type":"blocks","created_at":"2026-01-13T12:39:20.60089811-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-2wl.9","title":"[#1] Update all methods accessing self.filtered","description":"Audit all self.filtered usages: update_filter(), move_selection(), render_list(), delete_selected(), etc. Each must use .index to get entry index. Comprehensive refactor required.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:37:22.719911582-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.005927993-05:00","dependencies":[{"issue_id":"clipboard-2wl.9","depends_on_id":"clipboard-2wl","type":"parent-child","created_at":"2026-01-13T12:37:22.722375788-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-2wl.9","depends_on_id":"clipboard-2wl.4","type":"blocks","created_at":"2026-01-13T12:39:20.642987886-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.005927993-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5","title":"Improvement #3: Atomic File Writes","description":"CRITICAL reliability fix - current fs::write() is NOT atomic. If interrupted mid-write (Ctrl+C, crash, power loss), files can be corrupted: truncated JSON, partial data, or empty files. This violates ClipStack's core promise of 'never lose clipboard history'. Solution: implement write-to-temp-then-rename pattern with fsync. The rename() syscall is atomic on POSIX filesystems. Also adds cleanup of orphaned temp files on startup and a recovery command for corrupted storage.","status":"open","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:28:52.871570748-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T12:28:52.871570748-05:00","dependencies":[{"issue_id":"clipboard-8u5","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:30:09.313812816-05:00","created_by":"solsystemlabs"}],"comments":[{"id":3,"issue_id":"clipboard-8u5","author":"solsystemlabs","text":"# Improvement #3: Atomic File Writes - Detailed Documentation\n\n## Problem Statement\n\nThe current storage implementation uses non-atomic writes:\n\n```rust\n// storage.rs:76\nfs::write(\u0026path, data).with_context(|| format!(\"Failed to write index: {:?}\", path))\n```\n\nThis is dangerous because `fs::write()` is NOT atomic. If the process is interrupted mid-write:\n\n```\nProcess: fs::write(\"index.json\", data)\n           |\n           |-- 1. Open/create file (truncates existing)\n           |-- 2. Write chunk 1\n           |-- 3. Write chunk 2  \u003c-- CRASH HERE\n           |-- 4. Write chunk 3\n           |-- 5. Close file\n\nResult: index.json contains only chunks 1-2, is invalid JSON\n```\n\nPossible corruption modes:\n- Truncated JSON (parse error on next load)\n- Partially written data (invalid content)\n- Empty file (complete data loss)\n\nFor a tool whose value is \"never lose clipboard history,\" this is an unacceptable reliability gap.\n\n## Solution: Write-and-Rename Pattern\n\nThe atomic pattern guarantees safety:\n\n```\nProcess: atomic_write(\"index.json\", data)\n           |\n           |-- 1. Write to index.json.tmp\n           |-- 2. fsync() temp file (ensure on disk)\n           |-- 3. rename(tmp, final)  \u003c-- ATOMIC\n\nIf crash during steps 1-2: temp file is corrupt, final file untouched\nIf crash during step 3: rename either happens or doesn't (atomic)\n```\n\nThe `rename()` syscall is atomic on POSIX filesystems (ext4, btrfs, APFS, HFS+).\n\n## Implementation Requirements\n\n### 1. atomic_write() Helper Method\n```rust\nfn atomic_write(\u0026self, path: \u0026Path, data: \u0026[u8]) -\u003e Result\u003c()\u003e {\n    let tmp_path = path.with_extension(\"tmp\");\n\n    // Step 1: Write to temp\n    let mut file = fs::File::create(\u0026tmp_path)?;\n    file.write_all(data)?;\n\n    // Step 2: Sync to disk\n    file.sync_all()?;\n    drop(file);  // Close before rename\n\n    // Step 3: Atomic rename\n    fs::rename(\u0026tmp_path, path)?;\n\n    // Step 4: Sync parent directory (full durability)\n    if let Some(parent) = path.parent() {\n        if let Ok(dir) = fs::File::open(parent) {\n            let _ = dir.sync_all();\n        }\n    }\n\n    Ok(())\n}\n```\n\n### 2. Cleanup Orphaned Temp Files\nOn startup, clean up any `.tmp` files left from interrupted operations:\n```rust\nfn cleanup_temp_files(\u0026self) -\u003e Result\u003c()\u003e {\n    for entry in fs::read_dir(\u0026self.base_dir)? {\n        let path = entry?.path();\n        if path.extension() == Some(\"tmp\".as_ref()) {\n            eprintln!(\"Cleaning up orphaned temp file: {:?}\", path);\n            let _ = fs::remove_file(\u0026path);\n        }\n    }\n    Ok(())\n}\n```\n\n### 3. Recovery Command\nFor cases where corruption occurs (from bugs in older versions):\n```rust\npub fn attempt_recovery(\u0026self) -\u003e Result\u003cusize\u003e {\n    // 1. Try to parse existing index\n    // 2. If fails, scan .txt content files\n    // 3. Rebuild index from content files\n    // 4. Deduplicate by hash\n    // 5. Save recovered index\n}\n```\n\n### 4. Update All Write Operations\n- `save_index()` → use atomic_write()\n- `save_entry()` content files → use atomic_write()\n\n## Testing Requirements (TDD)\n\n1. `test_atomic_write_creates_file()` - Basic write works\n2. `test_atomic_write_no_temp_file_remains()` - No .tmp left after success\n3. `test_cleanup_orphaned_temp_files()` - Startup cleans old .tmp\n4. `test_atomic_write_overwrites_existing()` - Overwrite works correctly\n5. `test_recovery_from_missing_index()` - Can rebuild from content files\n6. `test_concurrent_writes_safe()` - Multiple threads don't corrupt\n\n## Platform Considerations\n\n- **Linux/macOS**: `rename()` is atomic on ext4, btrfs, APFS, HFS+\n- **Windows**: `rename()` is atomic on NTFS (Rust handles MoveFileEx)\n- **Network filesystems**: NFS v3 has non-atomic rename; v4 is atomic\n  - Recommendation: Don't store clipboard data on network mounts\n\n## Success Criteria\n\n- [ ] All writes use atomic pattern\n- [ ] Orphaned temp files cleaned up on startup\n- [ ] Recovery command can rebuild index from content files\n- [ ] No data loss possible from interrupted writes\n- [ ] Concurrent access doesn't corrupt storage\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| src/storage.rs | Add atomic_write(), cleanup_temp_files(), attempt_recovery(), update save_* methods |\n| src/main.rs | Add Recover command |\n\n## Dependencies\n\n- **Depends on**: Improvement #5 (for Storage::new signature)\n- **Blocked by**: Nothing after #5 is done\n","created_at":"2026-01-13T17:29:41Z"}]}
{"id":"clipboard-8u5.1","title":"[#3] Implement atomic_write() helper method","description":"Add fn atomic_write(\u0026self, path: \u0026Path, data: \u0026[u8]) -\u003e Result\u003c()\u003e to Storage. Pattern: 1) Write to .tmp file 2) fsync() temp 3) rename to final 4) fsync parent dir. This is the core reliability primitive that eliminates data corruption risk.","status":"tombstone","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:40.282981883-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.1","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:40.284675067-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.10","title":"[#3] Write unit tests for recovery","description":"Write test_recovery_from_missing_index(): create content .txt files without index.json, call attempt_recovery(), verify index is rebuilt with correct entries. Also test_concurrent_writes_safe() for thread safety.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:49.484884347-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.10","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:49.486479037-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.11","title":"[#3] Write E2E test script for atomic file writes","description":"Create comprehensive E2E test script (tests/e2e/test_atomic_writes.sh) that verifies atomic file write reliability. Tests:\n1. Basic atomic write creates file correctly\n2. No .tmp files remain after successful operation\n3. Startup cleanup removes orphaned .tmp files (create fake .tmp, restart daemon)\n4. Atomic write overwrites existing file without corruption\n5. Recovery command rebuilds index from content files (corrupt index.json, run recover)\n6. Concurrent access safety (run daemon + picker simultaneously, verify no corruption)\n\nLOGGING REQUIREMENTS:\n- Use colored output: GREEN=pass, RED=fail, YELLOW=info\n- Each test prints: [TEST N] Description... followed by result\n- For file operations, show: \"Writing Xb to path...\" / \"File size: Xb\"\n- For cleanup tests, show: \"Found N .tmp files before, M after cleanup\"\n- For recovery, show: \"Recovered N/M entries\"\n- Print summary at end: \"X/Y tests passed\"\n- Exit code: 0 if all pass, 1 if any fail\n\nCLEANUP: Create temp data dir per test, remove after each test\n\nSAFETY: Recovery test must backup real data before corrupting test data\n\nExample output format:\n[TEST 5] Recovery from corrupted index...\n  Creating 5 test entries...\n  Corrupting index.json...\n  Running: clipstack recover\n  Recovered 5/5 entries\n  Verifying index integrity...\n  ✓ PASS","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T13:29:48.936137477-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.11","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T13:29:48.938131728-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.11","depends_on_id":"clipboard-8u5.10","type":"blocks","created_at":"2026-01-13T13:30:09.486484325-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.12","title":"[#3] Implement atomic_write() helper method","description":"## Overview\nImplement the core write-then-rename pattern that guarantees atomic file operations.\n\n## Code Changes in src/storage.rs\n\n```rust\nuse std::io::Write;\n\nimpl Storage {\n    /// Atomically write data to a file using write-then-rename pattern.\n    /// \n    /// This guarantees that file writes are atomic:\n    /// 1. Write to temporary file (.tmp extension)\n    /// 2. fsync() to ensure data is on disk\n    /// 3. Atomic rename() to final path\n    /// 4. fsync() parent directory for full durability\n    /// \n    /// If interrupted at any point, the original file remains intact.\n    fn atomic_write(\u0026self, path: \u0026Path, data: \u0026[u8]) -\u003e Result\u003c()\u003e {\n        let tmp_path = path.with_extension(\"tmp\");\n        \n        // Step 1: Write to temporary file\n        let mut file = fs::File::create(\u0026tmp_path)\n            .with_context(|| format!(\"Failed to create temp file: {:?}\", tmp_path))?;\n        \n        file.write_all(data)\n            .with_context(|| format!(\"Failed to write temp file: {:?}\", tmp_path))?;\n        \n        // Step 2: Ensure data is flushed to disk\n        file.sync_all()\n            .with_context(|| format!(\"Failed to sync temp file: {:?}\", tmp_path))?;\n        \n        // Step 3: Close file before rename (required on some platforms)\n        drop(file);\n        \n        // Step 4: Atomic rename (POSIX guarantees atomicity)\n        fs::rename(\u0026tmp_path, path)\n            .with_context(|| format!(\"Failed to rename {:?} to {:?}\", tmp_path, path))?;\n        \n        // Step 5: Sync parent directory for full durability\n        if let Some(parent) = path.parent() {\n            if let Ok(dir) = fs::File::open(parent) {\n                let _ = dir.sync_all();\n            }\n        }\n        \n        Ok(())\n    }\n}\n```\n\n## Why This Pattern\n- fs::write() truncates file BEFORE writing - crash = data loss\n- rename() is atomic on POSIX filesystems (ext4, btrfs, APFS, HFS+, NTFS)\n- If crash during write to .tmp, original file untouched\n- If crash during rename, operation either completes or doesn't (no corruption)\n\n## Files Changed\n- src/storage.rs: Add atomic_write() method\n\n## Acceptance Criteria\n- [ ] atomic_write() method compiles\n- [ ] Uses .tmp extension for temp file\n- [ ] Calls sync_all() before rename\n- [ ] Handles parent directory sync","status":"open","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:24:57.271976987-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:24:57.271976987-05:00","dependencies":[{"issue_id":"clipboard-8u5.12","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:24:57.273798625-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.13","title":"[#3] Update save_index() and save_entry() to use atomic_write()","description":"## Overview\nReplace all non-atomic fs::write() calls with the new atomic_write() method.\n\n## Code Changes in src/storage.rs\n\n### Update save_index()\n```rust\nimpl Storage {\n    pub fn save_index(\u0026self, index: \u0026ClipIndex) -\u003e Result\u003c()\u003e {\n        let path = self.index_path();\n        let data = serde_json::to_string_pretty(index)?;\n        self.atomic_write(\u0026path, data.as_bytes())  // CHANGED from fs::write()\n    }\n}\n```\n\n### Update save_entry() content file writing\nIn save_entry(), find the fs::write() call for content files and replace:\n\n```rust\n// BEFORE (non-atomic):\nfs::write(\u0026content_path, content.as_bytes())\n    .with_context(|| format!(\"Failed to write content: {:?}\", content_path))?;\n\n// AFTER (atomic):\nself.atomic_write(\u0026content_path, content.as_bytes())\n    .with_context(|| format!(\"Failed to write content: {:?}\", content_path))?;\n```\n\n## Critical Change\nThis protects BOTH critical storage files:\n1. index.json - entry metadata (most critical)\n2. *.txt content files - actual clipboard content\n\n## Files Changed\n- src/storage.rs: Update save_index() and save_entry()\n\n## Acceptance Criteria\n- [ ] save_index() uses atomic_write()\n- [ ] save_entry() uses atomic_write() for content files\n- [ ] All tests still pass\n- [ ] No direct fs::write() calls remain for storage files","status":"open","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:25:03.717866535-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:25:03.717866535-05:00","dependencies":[{"issue_id":"clipboard-8u5.13","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:25:03.719689746-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.13","depends_on_id":"clipboard-8u5.12","type":"blocks","created_at":"2026-01-13T15:27:58.514496434-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.14","title":"[#3] Implement temp file cleanup on startup","description":"## Overview\nClean up orphaned .tmp files from interrupted operations when Storage is initialized.\n\n## Code Changes in src/storage.rs\n\n### Add cleanup method\n```rust\nimpl Storage {\n    /// Clean up orphaned temp files from interrupted operations\n    fn cleanup_temp_files(\u0026self) -\u003e Result\u003c()\u003e {\n        if let Ok(entries) = fs::read_dir(\u0026self.base_dir) {\n            for entry in entries.flatten() {\n                let path = entry.path();\n                if path.extension().map_or(false, |ext| ext == \"tmp\") {\n                    eprintln!(\"[cleanup] Removing orphaned temp file: {:?}\", path);\n                    let _ = fs::remove_file(\u0026path);\n                }\n            }\n        }\n        Ok(())\n    }\n}\n```\n\n### Call in Storage::new()\n```rust\nimpl Storage {\n    pub fn new(base_dir: PathBuf, max_entries: usize) -\u003e Result\u003cSelf\u003e {\n        fs::create_dir_all(\u0026base_dir)\n            .with_context(|| format!(\"Failed to create storage dir: {:?}\", base_dir))?;\n        \n        let max_entries = max_entries.clamp(1, ABSOLUTE_MAX_ENTRIES);\n        let storage = Self { base_dir, max_entries };\n        \n        // Clean up any orphaned temp files from interrupted operations\n        storage.cleanup_temp_files()?;\n        \n        storage.sync_max_entries()?;\n        Ok(storage)\n    }\n}\n```\n\n## When This Helps\n- User hits Ctrl+C during clipboard save\n- System crash during write operation\n- Power failure during daemon operation\n- Left over .tmp files from any interruption\n\n## Files Changed\n- src/storage.rs: Add cleanup_temp_files(), call in new()\n\n## Acceptance Criteria\n- [ ] cleanup_temp_files() removes .tmp files\n- [ ] Called during Storage initialization\n- [ ] Logs removed files to stderr\n- [ ] Doesn't fail if no temp files exist","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:25:14.821350807-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:25:14.821350807-05:00","dependencies":[{"issue_id":"clipboard-8u5.14","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:25:14.823113634-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.14","depends_on_id":"clipboard-8u5.12","type":"blocks","created_at":"2026-01-13T15:27:58.551763127-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.15","title":"[#3] Implement attempt_recovery() method and Recover CLI command","description":"## Overview\nAdd recovery functionality that rebuilds index from content files. Useful when index is corrupted.\n\n## Code Changes\n\n### src/storage.rs - Recovery method\n```rust\nimpl Storage {\n    /// Attempt to recover from corrupted storage.\n    /// Rebuilds index from existing content files.\n    pub fn attempt_recovery(\u0026self) -\u003e Result\u003cusize\u003e {\n        eprintln!(\"[recovery] Starting storage recovery...\");\n        \n        let index_path = self.index_path();\n        let mut recovered_entries: Vec\u003cClipEntry\u003e = Vec::new();\n        \n        // Try to load existing index entries first\n        if index_path.exists() {\n            match fs::read_to_string(\u0026index_path) {\n                Ok(data) =\u003e {\n                    match serde_json::from_str::\u003cClipIndex\u003e(\u0026data) {\n                        Ok(index) =\u003e {\n                            eprintln!(\"[recovery] Loaded {} entries from existing index\", \n                                     index.entries.len());\n                            recovered_entries = index.entries;\n                        }\n                        Err(e) =\u003e {\n                            eprintln!(\"[recovery] Index corrupted ({}), scanning files...\", e);\n                        }\n                    }\n                }\n                Err(e) =\u003e {\n                    eprintln!(\"[recovery] Cannot read index ({}), scanning files...\", e);\n                }\n            }\n        }\n        \n        // Collect IDs of entries we already have\n        let known_ids: std::collections::HashSet\u003c_\u003e = \n            recovered_entries.iter().map(|e| e.id.clone()).collect();\n        \n        // Scan for orphaned content files\n        let mut orphan_count = 0;\n        for entry in fs::read_dir(\u0026self.base_dir)? {\n            let entry = entry?;\n            let path = entry.path();\n            \n            if path.extension().map_or(false, |ext| ext == \"txt\") {\n                let id = path.file_stem()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"\").to_string();\n                \n                if known_ids.contains(\u0026id) { continue; }\n                \n                if let Ok(content) = fs::read_to_string(\u0026path) {\n                    let timestamp: i64 = id.parse().unwrap_or(0);\n                    \n                    let mut hasher = Sha256::new();\n                    hasher.update(content.as_bytes());\n                    let hash = format!(\"sha256:{:x}\", hasher.finalize());\n                    \n                    let preview: String = content.chars()\n                        .take(MAX_PREVIEW_LEN)\n                        .map(|c| if c.is_control() { ' ' } else { c })\n                        .collect();\n                    \n                    recovered_entries.push(ClipEntry {\n                        id, timestamp, size: content.len(), \n                        preview, hash, pinned: false,\n                    });\n                    orphan_count += 1;\n                }\n            }\n        }\n        \n        eprintln!(\"[recovery] Found {} orphaned content files\", orphan_count);\n        \n        // Sort by timestamp descending\n        recovered_entries.sort_by(|a, b| b.timestamp.cmp(\u0026a.timestamp));\n        \n        // Deduplicate by hash (keep most recent)\n        let mut seen_hashes = std::collections::HashSet::new();\n        recovered_entries.retain(|e| seen_hashes.insert(e.hash.clone()));\n        \n        let total = recovered_entries.len();\n        eprintln!(\"[recovery] Total entries after dedup: {}\", total);\n        \n        // Save recovered index\n        let index = ClipIndex {\n            max_entries: self.max_entries,\n            entries: recovered_entries,\n        };\n        self.save_index(\u0026index)?;\n        \n        eprintln!(\"[recovery] Recovery complete\");\n        Ok(total)\n    }\n}\n```\n\n### src/main.rs - Add Recover command\n```rust\n#[derive(Subcommand)]\nenum Commands {\n    // ... existing commands ...\n    \n    /// Attempt to recover from corrupted storage\n    Recover,\n}\n\n// In main() match:\nSome(Commands::Recover) =\u003e {\n    match storage.attempt_recovery() {\n        Ok(count) =\u003e {\n            println!(\"Recovery complete. Recovered {} entries.\", count);\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Recovery failed: {}\", e);\n            std::process::exit(1);\n        }\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add attempt_recovery()\n- src/main.rs: Add Recover command variant and handler\n\n## Acceptance Criteria\n- [ ] attempt_recovery() rebuilds index from .txt files\n- [ ] Handles corrupted JSON gracefully\n- [ ] Deduplicates by hash\n- [ ] clipstack recover CLI command works","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:26:58.410770459-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:26:58.410770459-05:00","dependencies":[{"issue_id":"clipboard-8u5.15","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:26:58.412685579-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.15","depends_on_id":"clipboard-8u5.12","type":"blocks","created_at":"2026-01-13T15:27:58.586824506-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.16","title":"[#3] Write comprehensive unit tests for atomic file writes and recovery","description":"## Overview\nTDD: Comprehensive tests for atomic writes, temp cleanup, and recovery.\n\n## Test Cases (copy-paste ready)\n\n```rust\n#[cfg(test)]\nmod atomic_write_tests {\n    use super::*;\n    use tempfile::TempDir;\n    use std::sync::Arc;\n    use std::thread;\n    \n    #[test]\n    fn test_atomic_write_creates_file() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let test_path = dir.path().join(\"test.json\");\n        \n        storage.atomic_write(\u0026test_path, b\"test data\").unwrap();\n        \n        assert!(test_path.exists());\n        assert_eq!(fs::read_to_string(\u0026test_path).unwrap(), \"test data\");\n    }\n    \n    #[test]\n    fn test_atomic_write_no_temp_file_remains() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let test_path = dir.path().join(\"test.json\");\n        \n        storage.atomic_write(\u0026test_path, b\"test data\").unwrap();\n        \n        let tmp_path = test_path.with_extension(\"tmp\");\n        assert!(!tmp_path.exists(), \"Temp file should be removed after write\");\n    }\n    \n    #[test]\n    fn test_atomic_write_overwrites_existing() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let test_path = dir.path().join(\"test.json\");\n        \n        storage.atomic_write(\u0026test_path, b\"initial\").unwrap();\n        assert_eq!(fs::read_to_string(\u0026test_path).unwrap(), \"initial\");\n        \n        storage.atomic_write(\u0026test_path, b\"updated\").unwrap();\n        assert_eq!(fs::read_to_string(\u0026test_path).unwrap(), \"updated\");\n    }\n    \n    #[test]\n    fn test_cleanup_removes_orphaned_temp_files() {\n        let dir = TempDir::new().unwrap();\n        \n        // Create orphaned temp files (simulating interrupted ops)\n        fs::write(dir.path().join(\"index.tmp\"), \"orphaned\").unwrap();\n        fs::write(dir.path().join(\"12345.tmp\"), \"orphaned\").unwrap();\n        fs::write(dir.path().join(\"normal.txt\"), \"keep me\").unwrap();\n        \n        // Storage::new should clean up .tmp files\n        let _storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        \n        assert!(!dir.path().join(\"index.tmp\").exists(), \"index.tmp should be removed\");\n        assert!(!dir.path().join(\"12345.tmp\").exists(), \"12345.tmp should be removed\");\n        assert!(dir.path().join(\"normal.txt\").exists(), \".txt should NOT be removed\");\n    }\n    \n    #[test]\n    fn test_recovery_from_missing_index() {\n        let dir = TempDir::new().unwrap();\n        \n        // Create content files without index\n        fs::write(dir.path().join(\"1000.txt\"), \"content one\").unwrap();\n        fs::write(dir.path().join(\"2000.txt\"), \"content two\").unwrap();\n        \n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let count = storage.attempt_recovery().unwrap();\n        \n        assert_eq!(count, 2);\n        let index = storage.load_index().unwrap();\n        assert_eq!(index.entries.len(), 2);\n    }\n    \n    #[test]\n    fn test_recovery_deduplicates_by_hash() {\n        let dir = TempDir::new().unwrap();\n        \n        // Create content files with same content (same hash)\n        fs::write(dir.path().join(\"1000.txt\"), \"duplicate\").unwrap();\n        fs::write(dir.path().join(\"2000.txt\"), \"duplicate\").unwrap();\n        \n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let count = storage.attempt_recovery().unwrap();\n        \n        // Should keep only one (most recent = 2000)\n        assert_eq!(count, 1);\n    }\n    \n    #[test]\n    fn test_concurrent_saves_dont_corrupt() {\n        let dir = TempDir::new().unwrap();\n        let storage = Arc::new(Storage::new(dir.path().to_path_buf(), 100).unwrap());\n        \n        let mut handles = vec![];\n        for i in 0..10 {\n            let storage = Arc::clone(\u0026storage);\n            handles.push(thread::spawn(move || {\n                storage.save_entry(\u0026format!(\"thread {} content\", i)).unwrap();\n            }));\n        }\n        \n        for handle in handles {\n            handle.join().unwrap();\n        }\n        \n        // All entries should be saved without corruption\n        let index = storage.load_index().unwrap();\n        assert_eq!(index.entries.len(), 10);\n        \n        // Verify index is valid JSON (not corrupted)\n        let json = serde_json::to_string(\u0026index).unwrap();\n        assert!(!json.is_empty());\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add test module\n\n## Acceptance Criteria\n- [ ] All 7 tests pass\n- [ ] Tests run: cargo test atomic_write\n- [ ] Thread safety test verifies no corruption","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:27:37.110814109-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:27:37.110814109-05:00","dependencies":[{"issue_id":"clipboard-8u5.16","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:27:37.112738946-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.16","depends_on_id":"clipboard-8u5.12","type":"blocks","created_at":"2026-01-13T15:27:58.623252934-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.17","title":"[#3] Write E2E test script for atomic file writes and recovery","description":"## Overview\nEnd-to-end test script verifying atomic writes and recovery work in practice.\n\n## E2E Test Script (tests/e2e_atomic_writes.sh)\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# E2E Tests for Atomic File Writes and Recovery\n# Run from project root: ./tests/e2e_atomic_writes.sh\n\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nTEST_DIR=$(mktemp -d)\nCLIPSTACK=\"./target/release/clipstack\"\n\nlog_pass() { echo -e \"${GREEN}✓${NC} $1\"; }\nlog_fail() { echo -e \"${RED}✗${NC} $1\"; exit 1; }\nlog_info() { echo -e \"${YELLOW}→${NC} $1\"; }\n\ncleanup() { rm -rf \"$TEST_DIR\"; }\ntrap cleanup EXIT\n\n# Build release if needed\nif [[ ! -f \"$CLIPSTACK\" ]]; then\n    log_info \"Building release binary...\"\n    cargo build --release\nfi\n\nlog_info \"Test directory: $TEST_DIR\"\n\n# Test 1: No temp files after normal operations\nlog_info \"Test 1: No temp files after normal save\"\necho \"test content\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test1\" copy\nTEMP_COUNT=$(find \"$TEST_DIR/test1\" -name \"*.tmp\" 2\u003e/dev/null | wc -l)\n[[ \"$TEMP_COUNT\" -eq 0 ]] \u0026\u0026 \\\n    log_pass \"No .tmp files remain\" || log_fail \"Found $TEMP_COUNT .tmp files\"\n\n# Test 2: Multiple rapid saves don't corrupt\nlog_info \"Test 2: Rapid concurrent saves\"\nfor i in {1..50}; do\n    echo \"rapid entry $i\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test2\" copy \u0026\ndone\nwait\n\n# Verify index is valid JSON\n$CLIPSTACK --storage-dir \"$TEST_DIR/test2\" stats \u003e/dev/null 2\u003e\u00261 \u0026\u0026 \\\n    log_pass \"Index intact after 50 concurrent saves\" || \\\n    log_fail \"Index corrupted\"\n\n# Test 3: Temp file cleanup on startup\nlog_info \"Test 3: Temp file cleanup\"\ntouch \"$TEST_DIR/test3/index.tmp\"\ntouch \"$TEST_DIR/test3/orphan.tmp\"\nmkdir -p \"$TEST_DIR/test3\"\ntouch \"$TEST_DIR/test3/index.tmp\"\ntouch \"$TEST_DIR/test3/orphan.tmp\"\necho \"first\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test3\" copy\nTEMP_COUNT=$(find \"$TEST_DIR/test3\" -name \"*.tmp\" 2\u003e/dev/null | wc -l)\n[[ \"$TEMP_COUNT\" -eq 0 ]] \u0026\u0026 \\\n    log_pass \"Orphaned .tmp files cleaned up\" || \\\n    log_fail \"Found $TEMP_COUNT .tmp files\"\n\n# Test 4: Recovery from missing index\nlog_info \"Test 4: Recovery from missing index\"\nmkdir -p \"$TEST_DIR/test4\"\necho \"orphan 1\" \u003e \"$TEST_DIR/test4/1000.txt\"\necho \"orphan 2\" \u003e \"$TEST_DIR/test4/2000.txt\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test4\" recover\nCOUNT=$($CLIPSTACK --storage-dir \"$TEST_DIR/test4\" list 2\u003e/dev/null | wc -l)\n[[ \"$COUNT\" -ge 2 ]] \u0026\u0026 \\\n    log_pass \"Recovered $COUNT entries\" || \\\n    log_fail \"Recovery failed\"\n\n# Test 5: Recovery from corrupted index\nlog_info \"Test 5: Recovery from corrupted index\"\nmkdir -p \"$TEST_DIR/test5\"\necho \"valid content\" \u003e \"$TEST_DIR/test5/3000.txt\"\necho \"not valid json{{{\" \u003e \"$TEST_DIR/test5/index.json\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test5\" recover\n$CLIPSTACK --storage-dir \"$TEST_DIR/test5\" stats \u003e/dev/null 2\u003e\u00261 \u0026\u0026 \\\n    log_pass \"Recovered from corrupted index\" || \\\n    log_fail \"Could not recover from corruption\"\n\necho \"\"\necho -e \"${GREEN}All E2E tests passed!${NC}\"\n```\n\n## Logging\n- Clear pass/fail status for each test\n- Temp directory cleanup on exit\n\n## Acceptance Criteria\n- [ ] Script at tests/e2e_atomic_writes.sh\n- [ ] All 5 tests pass\n- [ ] Script handles cleanup properly","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:27:48.390755672-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:27:48.390755672-05:00","dependencies":[{"issue_id":"clipboard-8u5.17","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T15:27:48.393012983-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.17","depends_on_id":"clipboard-8u5.16","type":"blocks","created_at":"2026-01-13T15:27:58.660174358-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-8u5.2","title":"[#3] Update save_index() to use atomic_write()","description":"Replace fs::write() call in save_index() with self.atomic_write(). The index.json file is critical - corruption here loses ALL metadata. Atomic writes ensure the index is always valid.","status":"tombstone","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:40.63430538-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.2","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:40.63575567-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.2","depends_on_id":"clipboard-8u5.1","type":"blocks","created_at":"2026-01-13T12:32:01.69190719-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.3","title":"[#3] Update save_entry() to use atomic_write() for content files","description":"Replace fs::write() in save_entry() for *.txt content files with atomic_write(). While content file corruption is less severe (only one entry lost), consistency requires atomic writes everywhere.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:40.960310136-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.3","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:40.961898684-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.3","depends_on_id":"clipboard-8u5.1","type":"blocks","created_at":"2026-01-13T12:32:01.726603576-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.4","title":"[#3] Implement cleanup_temp_files() method","description":"Add method to scan base_dir for *.tmp files and remove them. These are orphaned from interrupted operations. Log to stderr when cleaning: helps debugging but isn't an error condition.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:41.296286926-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.4","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:41.29778208-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.5","title":"[#3] Call cleanup_temp_files() in Storage::new()","description":"Add cleanup_temp_files()? call during Storage initialization, after create_dir_all but before returning Self. Ensures clean state on every startup.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:41.61389345-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.5","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:41.615438397-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.5","depends_on_id":"clipboard-8u5.4","type":"blocks","created_at":"2026-01-13T12:32:01.760286889-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.6","title":"[#3] Implement attempt_recovery() method","description":"Add pub fn attempt_recovery(\u0026self) -\u003e Result\u003cusize\u003e. Steps: 1) Try loading existing index 2) If fails, scan *.txt content files 3) Rebuild ClipEntry for each content file 4) Deduplicate by hash 5) Sort by timestamp 6) Save recovered index. Returns count of recovered entries.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:41.935730409-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.6","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:41.937152947-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.6","depends_on_id":"clipboard-8u5.1","type":"blocks","created_at":"2026-01-13T12:32:01.795095685-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.7","title":"[#3] Add Recover CLI command","description":"Add Commands::Recover variant. Handler calls storage.attempt_recovery() and reports recovered entry count. On error, advise user to manually delete ~/.local/share/clipd/index.json as last resort.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:43.225584801-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.7","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:43.231039534-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-8u5.7","depends_on_id":"clipboard-8u5.6","type":"blocks","created_at":"2026-01-13T12:32:01.834610355-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.8","title":"[#3] Write unit tests for atomic_write()","description":"Write tests: test_atomic_write_creates_file(), test_atomic_write_no_temp_file_remains(), test_atomic_write_overwrites_existing(). Verify basic functionality and that no .tmp files remain after success.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:45.306493891-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.8","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:45.315766889-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-8u5.9","title":"[#3] Write unit tests for temp file cleanup","description":"Write test_cleanup_orphaned_temp_files(): create orphaned .tmp files, then Storage::new() and verify they're cleaned up. Simulates recovery from interrupted operations.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:31:47.386617306-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.428567549-05:00","dependencies":[{"issue_id":"clipboard-8u5.9","depends_on_id":"clipboard-8u5","type":"parent-child","created_at":"2026-01-13T12:31:47.388436265-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.428567549-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y","title":"Improvement #2: Pinned/Favorites System","description":"Add ability to pin entries to protect them from automatic pruning. Users need to keep frequently-used text permanently: email signatures, code snippets, template responses. Currently no way to prevent important entries from being pruned when history exceeds limit. Solution: pinned boolean field with separate limit (MAX_PINNED=25), star indicator, 'p' keybinding to toggle. Pinned entries shown at top of list.","status":"open","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:32:16.057451575-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T12:32:16.057451575-05:00","dependencies":[{"issue_id":"clipboard-b6y","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:32:52.56484425-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y","depends_on_id":"clipboard-8u5","type":"blocks","created_at":"2026-01-13T12:32:52.83749412-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y","depends_on_id":"clipboard-tsd","type":"blocks","created_at":"2026-01-13T13:31:09.695561262-05:00","created_by":"solsystemlabs"}],"comments":[{"id":4,"issue_id":"clipboard-b6y","author":"solsystemlabs","text":"# Improvement #2: Pinned/Favorites System - Detailed Documentation\n\n## Problem Statement\n\nClipStack enforces a maximum of 100 entries. Older entries are automatically pruned when this limit is reached. This creates a problem for frequently-used text that users want to keep permanently:\n\n- Email signatures\n- Code snippets (import statements, boilerplate)\n- Template responses\n- API keys/tokens (though these should arguably be in a password manager)\n\nUsers currently have NO way to prevent important entries from being pruned. They must re-copy these items periodically or use a separate tool - unacceptable UX.\n\n## Solution Design\n\nAdd a \"pin\" capability that:\n\n1. **Marks entries as protected** from automatic pruning\n2. **Shows pinned entries prominently** (top of list with `★` indicator)\n3. **Limits pinned entries** to prevent abuse (MAX_PINNED = 25)\n4. **Persists pin status** in storage index (with #[serde(default)] for backwards compat)\n\n## User Experience\n\n### Keybindings\n- `p` in Normal mode: Toggle pin status of selected entry\n- Pinned entries show `★` prefix in list\n- Status bar shows confirmation: \"Pinned\" / \"Unpinned\"\n\n### Visual Design\n```\n┌─History (5/105) - 3 pinned────────────────────┐\n│\u003e ★ 2d ago [   45B] My email signature...      │ ← Pinned (at top)\n│  ★ 5d ago [  128B] import { useState }...     │ ← Pinned\n│  ★ 1w ago [   32B] const API_BASE = ...       │ ← Pinned\n│  ──────────────────────────────────────────── │ ← Visual separator\n│  10s [  1.2KB] function handleClick()...      │ ← Regular entry\n└───────────────────────────────────────────────┘\n[NORMAL] p:Pin  j/k:Nav  /:Search  Enter:Paste  d:Delete\n```\n\n## Implementation Requirements\n\n### Constants\n```rust\nconst MAX_PINNED: usize = 25;\n```\n\n### ClipEntry Changes\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ClipEntry {\n    pub id: String,\n    pub timestamp: i64,\n    pub size: usize,\n    pub preview: String,\n    pub hash: String,\n    #[serde(default)]  // Backwards compatible!\n    pub pinned: bool,\n}\n```\n\n### Storage Methods\n```rust\npub fn toggle_pin(\u0026self, id: \u0026str) -\u003e Result\u003cbool\u003e;\npub fn set_pinned(\u0026self, id: \u0026str, pinned: bool) -\u003e Result\u003c()\u003e;\npub fn pinned_count(\u0026self) -\u003e Result\u003cusize\u003e;\n```\n\n### Pruning Logic Changes\n```rust\n// In prune_entries(): skip pinned entries\n// In save_entry(): count only unpinned entries against limit\n// When duplicate found: preserve pin status of existing entry\n```\n\n### DeletedEntry Changes (for undo)\n```rust\npub struct DeletedEntry {\n    pub entry: ClipEntry,\n    pub content: String,\n    pub pinned: bool,  // NEW: preserve pin state for undo\n}\n```\n\n### Picker Changes\n- `toggle_pin_selected()` method\n- `sort_entries_by_pin()` - pinned first, then by timestamp\n- Handle pin state in delete/undo cycle\n- Render `★` indicator\n- Update title to show pinned count\n\n## Testing Requirements (TDD)\n\n1. `test_pin_entry()` - Verify toggle works\n2. `test_unpin_entry()` - Verify toggle returns to unpinned\n3. `test_pinned_entries_not_pruned()` - Fill to max+, verify pinned survives\n4. `test_pin_limit()` - Verify MAX_PINNED enforced\n5. `test_backwards_compatibility()` - Old index.json without pinned field loads correctly\n\n## Edge Cases\n\n### Pin + Duplicate Detection\nWhen user copies content that matches an existing pinned entry:\n- Move existing entry to front (update timestamp)\n- Preserve pinned=true status\n- Don't create duplicate\n\n### Pin + Delete\nWhen pinned entry is deleted:\n- Store pinned state in DeletedEntry\n- Undo restores pinned state\n\n### Pin + Reduce Max Entries\nWhen max_entries is reduced:\n- Only prune unpinned entries\n- Pinned entries survive regardless\n\n## Design Decision: Why 25 Max Pinned?\n\n- Prevents users from pinning everything (defeating the purpose)\n- 25 is enough for common use cases (signatures, snippets, templates)\n- Total can be: 25 pinned + 100 unpinned = 125 entries\n- Can be adjusted later if users request more\n\n## Success Criteria\n\n- [ ] `p` key toggles pin status with visual feedback\n- [ ] Pinned entries show `★` indicator\n- [ ] Pinned entries appear at top of list\n- [ ] Pinned entries survive pruning\n- [ ] Maximum 25 pinned entries enforced\n- [ ] `stats` command shows pinned count\n- [ ] Backwards compatible with existing storage\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| src/storage.rs | pinned field, toggle_pin(), set_pinned(), pinned_count(), pruning logic |\n| src/picker.rs | toggle_pin_selected(), sort_by_pin(), render star indicator, update title |\n| src/main.rs | Update stats command for pinned count |\n\n## Dependencies\n\n- **Depends on**: Improvement #5 (Storage::new signature)\n- **Depends on**: Improvement #3 (for atomic saves of pin state changes)\n","created_at":"2026-01-13T17:32:52Z"}]}
{"id":"clipboard-b6y.1","title":"[#2] Add pinned field to ClipEntry with serde default","description":"Add #[serde(default)] pub pinned: bool to ClipEntry struct. The serde(default) attribute ensures backwards compatibility - existing index.json files without this field will load with pinned=false.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:33:09.488583243-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.1","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:33:09.490285645-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.10","title":"[#2] Add sort_entries_by_pin() to Picker","description":"Add method to sort entries: pinned first (by timestamp desc), then unpinned (by timestamp desc). Call after toggle_pin and on initial load. Preserve current selection by ID.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:36.79995594-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.10","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:36.801729696-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.10","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.328074116-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.11","title":"[#2] Update delete_selected() to track pin state","description":"When creating DeletedEntry in delete_selected(), include entry.pinned value. This preserves pin state for potential undo operation.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:37.149045184-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.11","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:37.150483021-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.11","depends_on_id":"clipboard-b6y.8","type":"blocks","created_at":"2026-01-13T12:35:07.36351568-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.12","title":"[#2] Update undo_delete() to restore pin state","description":"After recreating entry from DeletedEntry, call storage.set_pinned(id, deleted.pinned) to restore original pin state. User shouldn't lose pin decision due to accidental delete/undo.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:37.484839248-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.12","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:37.486302583-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.12","depends_on_id":"clipboard-b6y.4","type":"blocks","created_at":"2026-01-13T12:35:07.399105441-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.13","title":"[#2] Add 'p' keybinding handler in handle_normal_mode()","description":"Add KeyCode::Char('p') case to handle_normal_mode() that calls self.toggle_pin_selected(). Return Ok(None) to continue event loop.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:37.868436169-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.13","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:37.870038704-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.13","depends_on_id":"clipboard-b6y.9","type":"blocks","created_at":"2026-01-13T12:35:07.435569005-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.14","title":"[#2] Update render_list() with pin indicator (★)","description":"In render_list(), add pin indicator span: if entry.pinned then '★ ' else '  '. Use Color::Yellow for star. Ensures visual alignment for all entries.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:39.215330349-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.14","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:39.220632489-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.14","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.471388235-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.15","title":"[#2] Update render_list() title to show pinned count","description":"Update list title format: 'History (filtered/total) - N pinned'. Only show pinned count if \u003e0. Gives users visibility into their pinned items.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:41.32024288-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.15","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:41.322039057-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.16","title":"[#2] Update Stats command to show pinned count","description":"In Stats handler, add line: Pinned: {} (not counted against limit). Clarifies that pinned entries don't count towards max_entries limit.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:45.36004701-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.16","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:45.361556992-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.17","title":"[#2] Write unit tests for pin operations","description":"Write tests: test_pin_entry(), test_unpin_entry(), test_pinned_entries_not_pruned() (fill to max+, verify pinned survives), test_pin_limit() (verify MAX_PINNED enforced, error on exceed).","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:47.469907715-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.17","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:47.471374307-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.17","depends_on_id":"clipboard-b6y.3","type":"blocks","created_at":"2026-01-13T12:35:07.50637028-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.17","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T14:00:50.707405359-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.18","title":"[#2] Write backwards compatibility test for pinned field","description":"Write test_backwards_compatibility(): create JSON without pinned field, load via Storage, verify pinned defaults to false. Proves old storage format still works.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:49.5697848-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.18","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:49.571233879-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.18","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.542786666-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.19","title":"[#2] Update render_status_line() to show p:Pin in help","description":"Add 'p:Pin' to the help text in status line. Users need to discover this feature.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:55.930935923-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.19","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:55.932524923-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.2","title":"[#2] Add MAX_PINNED constant (25)","description":"Add const MAX_PINNED: usize = 25 to storage.rs. This limits pinned entries to prevent users from pinning everything (which defeats the purpose). 25 is enough for common use cases.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:33:09.794749271-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.2","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:33:09.796384627-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.20","title":"[#2] Write E2E test script for pinned entries","description":"Create comprehensive E2E test script (tests/e2e/test_pinned_entries.sh) that verifies pinned/favorites functionality. Tests:\n1. Pin toggle works (p key in picker)\n2. Pinned entries show ★ indicator\n3. Pinned entries appear at top of list (before unpinned)\n4. Pinned entries survive pruning (fill to max+10, verify pinned survive)\n5. Maximum 25 pinned entries enforced (try to pin 26th)\n6. Stats command shows pinned count correctly\n7. Backwards compatibility (load old index.json without pinned field)\n8. Pin state survives delete+undo cycle\n\nLOGGING REQUIREMENTS:\n- Use colored output: GREEN=pass, RED=fail, YELLOW=info\n- Each test prints: [TEST N] Description... followed by result\n- For pin operations, show: \"Entry X: pinned=true/false\"\n- For list display, show: \"Entry order: [★entry1, ★entry2, entry3, ...]\"\n- For pruning tests, show: \"Before: N entries (P pinned), After: M entries (P pinned)\"\n- Print summary at end: \"X/Y tests passed\"\n- Exit code: 0 if all pass, 1 if any fail\n\nCLEANUP: Create temp CLIPSTACK_DATA_DIR per test, remove after each test\n\nExample output format:\n[TEST 4] Pinned entries survive pruning...\n  Creating 3 pinned + 100 unpinned entries (103 total, limit 100)...\n  Before pruning: 103 entries (3 pinned)\n  Running daemon to trigger pruning...\n  After pruning: 100 entries (3 pinned)\n  Pinned entries preserved: [id1, id2, id3]\n  ✓ PASS","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T13:29:49.297447716-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.20","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T13:29:49.300320019-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.20","depends_on_id":"clipboard-b6y.18","type":"blocks","created_at":"2026-01-13T13:30:09.856220413-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.21","title":"[#2] Add pinned field to ClipEntry and MAX_PINNED constant","description":"## Overview\nAdd the core data structure changes needed for the pinned feature.\n\n## Code Changes in src/storage.rs\n\n### Add Constant\n```rust\nconst MAX_PINNED: usize = 25;  // Prevents users from pinning everything\n```\n\n### Update ClipEntry Struct\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ClipEntry {\n    pub id: String,\n    pub timestamp: i64,\n    pub size: usize,\n    pub preview: String,\n    pub hash: String,\n    /// Whether this entry is protected from automatic pruning\n    #[serde(default)]  // Critical for backwards compatibility!\n    pub pinned: bool,\n}\n```\n\n## Why #[serde(default)]\nExisting index.json files don't have a \"pinned\" field. The #[serde(default)] attribute:\n- Makes the field optional during deserialization\n- Defaults to false for existing entries\n- Enables seamless upgrades without data migration\n\n## Why MAX_PINNED = 25\n- Prevents abuse (pinning everything defeats the purpose)\n- 25 is plenty for common use cases (signatures, snippets, templates)\n- Total capacity: 25 pinned + 100 regular = 125 entries\n\n## Files Changed\n- src/storage.rs: Add constant, add field with serde attribute\n\n## Acceptance Criteria\n- [ ] MAX_PINNED constant = 25\n- [ ] ClipEntry has pinned: bool field\n- [ ] #[serde(default)] attribute present\n- [ ] Old index.json files load without error","status":"open","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:28:35.695406394-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:28:35.695406394-05:00","dependencies":[{"issue_id":"clipboard-b6y.21","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:28:35.697054771-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.22","title":"[#2] Implement pin methods: toggle_pin(), set_pinned(), pinned_count()","description":"## Overview\nAdd Storage methods for managing pin state.\n\n## Code Changes in src/storage.rs\n\n```rust\nimpl Storage {\n    /// Toggle pin status of an entry.\n    /// Returns new pinned state, or error if at pin limit.\n    pub fn toggle_pin(\u0026self, id: \u0026str) -\u003e Result\u003cbool\u003e {\n        let mut index = self.load_index()?;\n        \n        let entry = index.entries.iter_mut().find(|e| e.id == id);\n        \n        match entry {\n            Some(entry) =\u003e {\n                // Check limit only when pinning (not unpinning)\n                if !entry.pinned {\n                    let pinned_count = index.entries.iter().filter(|e| e.pinned).count();\n                    if pinned_count \u003e= MAX_PINNED {\n                        anyhow::bail!(\n                            \"Maximum pinned entries ({}) reached. Unpin something first.\",\n                            MAX_PINNED\n                        );\n                    }\n                }\n                \n                entry.pinned = !entry.pinned;\n                let new_status = entry.pinned;\n                self.save_index(\u0026index)?;\n                Ok(new_status)\n            }\n            None =\u003e anyhow::bail!(\"Entry not found: {}\", id),\n        }\n    }\n    \n    /// Explicitly set pin status (used for undo restore)\n    pub fn set_pinned(\u0026self, id: \u0026str, pinned: bool) -\u003e Result\u003c()\u003e {\n        let mut index = self.load_index()?;\n        \n        if let Some(entry) = index.entries.iter_mut().find(|e| e.id == id) {\n            // Check limit if pinning\n            if pinned \u0026\u0026 !entry.pinned {\n                let pinned_count = index.entries.iter().filter(|e| e.pinned).count();\n                if pinned_count \u003e= MAX_PINNED {\n                    anyhow::bail!(\"Maximum pinned entries reached\");\n                }\n            }\n            entry.pinned = pinned;\n            self.save_index(\u0026index)?;\n        }\n        Ok(())\n    }\n    \n    /// Get count of pinned entries\n    pub fn pinned_count(\u0026self) -\u003e Result\u003cusize\u003e {\n        let index = self.load_index()?;\n        Ok(index.entries.iter().filter(|e| e.pinned).count())\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add 3 public methods\n\n## Acceptance Criteria\n- [ ] toggle_pin() toggles and enforces limit\n- [ ] set_pinned() allows explicit state setting\n- [ ] pinned_count() returns correct count\n- [ ] All methods save index after changes","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:29:22.458786765-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:29:22.458786765-05:00","dependencies":[{"issue_id":"clipboard-b6y.22","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:29:22.460578009-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.22","depends_on_id":"clipboard-b6y.21","type":"blocks","created_at":"2026-01-13T15:40:57.561320565-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.23","title":"[#2] Update prune_entries() and save_entry() for pin-aware behavior","description":"## Overview\nModify pruning logic to skip pinned entries and handle pin-preservation for duplicates.\n\n## Code Changes in src/storage.rs\n\n### Update prune logic\n```rust\nimpl Storage {\n    /// Remove oldest unpinned entries when over limit.\n    /// Pinned entries are NEVER pruned.\n    fn prune_unpinned_entries(\u0026self, index: \u0026mut ClipIndex) -\u003e Result\u003c()\u003e {\n        // Only count unpinned entries against the limit\n        while index.entries.iter().filter(|e| !e.pinned).count() \u003e self.max_entries {\n            // Find oldest (last) unpinned entry\n            if let Some(pos) = index.entries.iter().rposition(|e| !e.pinned) {\n                let old = index.entries.remove(pos);\n                let old_path = self.content_path(\u0026old.id);\n                let _ = fs::remove_file(old_path);\n            } else {\n                // All entries are pinned - nothing more to prune\n                break;\n            }\n        }\n        Ok(())\n    }\n}\n```\n\n### Update save_entry() for duplicate handling\n```rust\nimpl Storage {\n    pub fn save_entry(\u0026self, content: \u0026str) -\u003e Result\u003cClipEntry\u003e {\n        // ... hash computation ...\n        \n        let mut index = self.load_index()?;\n        \n        // Check for duplicate by hash\n        if let Some(pos) = index.entries.iter().position(|e| e.hash == hash) {\n            // Move existing entry to front, PRESERVING pin status\n            let existing = index.entries.remove(pos);\n            index.entries.insert(0, existing.clone());\n            self.save_index(\u0026index)?;\n            return Ok(existing);  // Important: return existing entry (keeps pinned=true)\n        }\n        \n        // Create new entry (new entries are NEVER pinned)\n        let entry = ClipEntry {\n            id: id.clone(),\n            timestamp,\n            size: content.len(),\n            preview,\n            hash,\n            pinned: false,  // New entries start unpinned\n        };\n        \n        // ... save content file ...\n        \n        index.entries.insert(0, entry.clone());\n        \n        // Prune old UNPINNED entries only\n        self.prune_unpinned_entries(\u0026mut index)?;\n        \n        self.save_index(\u0026index)?;\n        Ok(entry)\n    }\n}\n```\n\n## Key Behaviors\n1. Pinned entries NEVER get pruned\n2. Only unpinned count against max_entries limit\n3. Duplicate content preserves existing pin status\n4. New entries always start unpinned\n\n## Files Changed\n- src/storage.rs: Update prune and save logic\n\n## Acceptance Criteria\n- [ ] Pinned entries survive when unpinned count exceeds limit\n- [ ] Duplicate detection preserves pinned=true\n- [ ] New entries have pinned=false\n- [ ] Pruning only removes oldest unpinned","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:29:28.216389794-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:29:28.216389794-05:00","dependencies":[{"issue_id":"clipboard-b6y.23","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:29:28.218220001-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.23","depends_on_id":"clipboard-b6y.21","type":"blocks","created_at":"2026-01-13T15:40:57.597736065-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.24","title":"[#2] Update Picker with pin toggle, sorting, and delete/undo pin state","description":"## Overview\nAdd all Picker-side pin functionality: toggle, sorting, delete/undo tracking.\n\n## Code Changes in src/picker.rs\n\n### Update DeletedEntry for pin restore\n```rust\nstruct DeletedEntry {\n    entry: ClipEntry,\n    content: String,\n    was_pinned: bool,  // NEW: Track pin state for restoration\n    deleted_at: Instant,\n}\n```\n\n### Add pin toggle method\n```rust\nimpl Picker {\n    /// Toggle pin status of selected entry\n    fn toggle_pin_selected(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if let Some(idx) = self.selected_entry_index() {\n            let entry_id = self.entries[idx].id.clone();\n            \n            match self.storage.toggle_pin(\u0026entry_id) {\n                Ok(is_pinned) =\u003e {\n                    // Update local state\n                    self.entries[idx].pinned = is_pinned;\n                    \n                    // Re-sort: pinned entries first\n                    self.sort_entries_by_pin();\n                    \n                    let msg = if is_pinned { \"★ Pinned\" } else { \"Unpinned\" };\n                    self.set_status(msg.to_string(), StatusLevel::Success);\n                }\n                Err(e) =\u003e {\n                    self.set_status(e.to_string(), StatusLevel::Warning);\n                }\n            }\n        }\n        Ok(())\n    }\n    \n    /// Sort entries: pinned first (by timestamp), then unpinned (by timestamp)\n    fn sort_entries_by_pin(\u0026mut self) {\n        let selected_id = self.selected_entry().map(|e| e.id.clone());\n        \n        self.entries.sort_by(|a, b| {\n            match (a.pinned, b.pinned) {\n                (true, false) =\u003e std::cmp::Ordering::Less,\n                (false, true) =\u003e std::cmp::Ordering::Greater,\n                _ =\u003e b.timestamp.cmp(\u0026a.timestamp),  // Most recent first\n            }\n        });\n        \n        self.update_filter();\n        \n        // Restore selection by ID\n        if let Some(id) = selected_id {\n            for (i, filtered) in self.filtered.iter().enumerate() {\n                if self.entries[filtered.index].id == id {\n                    self.selected.select(Some(i));\n                    break;\n                }\n            }\n        }\n        self.update_scroll_state();\n        self.load_preview();\n    }\n}\n```\n\n### Update delete_selected() to track pin state\n```rust\nfn delete_selected(\u0026mut self) -\u003e Result\u003c()\u003e {\n    if let Some(entry) = self.selected_entry().cloned() {\n        let content = self.storage.load_content(\u0026entry.id)?;\n        let preview: String = entry.preview.chars().take(30).collect();\n        let was_pinned = entry.pinned;  // NEW: Track pin state\n        \n        self.last_deleted = Some(DeletedEntry {\n            entry: entry.clone(),\n            content,\n            was_pinned,  // NEW\n            deleted_at: Instant::now(),\n        });\n        \n        self.storage.delete_entry(\u0026entry.id)?;\n        self.entries.retain(|e| e.id != entry.id);\n        self.update_filter();\n        self.load_preview();\n        \n        let msg = if was_pinned {\n            format!(\"Deleted ★ '{}' - 'u' to undo (5s)\", preview)\n        } else {\n            format!(\"Deleted '{}' - 'u' to undo (5s)\", preview)\n        };\n        self.set_status(msg, StatusLevel::Warning);\n    }\n    Ok(())\n}\n```\n\n### Update undo_delete() to restore pin state\n```rust\nfn undo_delete(\u0026mut self) -\u003e Result\u003c()\u003e {\n    if let Some(deleted) = self.last_deleted.take() {\n        if deleted.deleted_at.elapsed() \u003c Duration::from_secs(5) {\n            let preview: String = deleted.entry.preview.chars().take(30).collect();\n            \n            let restored = self.storage.save_entry(\u0026deleted.content)?;\n            \n            // Restore pin state if it was pinned\n            if deleted.was_pinned {\n                let _ = self.storage.set_pinned(\u0026restored.id, true);\n            }\n            \n            // Reload entries\n            let index = self.storage.load_index()?;\n            self.entries = index.entries;\n            self.sort_entries_by_pin();\n            self.update_filter();\n            self.load_preview();\n            \n            let msg = if deleted.was_pinned {\n                format!(\"Restored ★ '{}'\", preview)\n            } else {\n                format!(\"Restored '{}'\", preview)\n            };\n            self.set_status(msg, StatusLevel::Success);\n        } else {\n            self.set_status(\"Undo expired\".to_string(), StatusLevel::Warning);\n        }\n    }\n    Ok(())\n}\n```\n\n### Add 'p' keybinding in handle_normal_mode()\n```rust\nKeyCode::Char('p') =\u003e {\n    self.toggle_pin_selected()?;\n}\n```\n\n## Files Changed\n- src/picker.rs: Update DeletedEntry, add methods, add keybinding\n\n## Acceptance Criteria\n- [ ] 'p' key toggles pin\n- [ ] Pinned entries sort to top\n- [ ] Delete tracks was_pinned\n- [ ] Undo restores pin state","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:31:32.377498028-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:31:32.377498028-05:00","dependencies":[{"issue_id":"clipboard-b6y.24","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:31:32.381007294-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.24","depends_on_id":"clipboard-b6y.22","type":"blocks","created_at":"2026-01-13T15:40:57.633789868-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.25","title":"[#2] Update rendering: star indicator, pinned count in title, status line help","description":"## Overview\nAdd visual feedback for pinned entries throughout the UI.\n\n## Code Changes in src/picker.rs\n\n### Update render_list() with pin indicator\nIn the list item rendering loop, add star for pinned entries:\n\n```rust\n// Pin indicator (★ for pinned, space for not)\nlet pin_indicator = if entry.pinned {\n    Span::styled(\"★ \", Style::default().fg(Color::Yellow))\n} else {\n    Span::raw(\"  \")\n};\n\nlet mut spans = vec![\n    pin_indicator,  // NEW: Pin star first\n    Span::styled(\n        format!(\"{:\u003e3} \", time),\n        Style::default().fg(Color::DarkGray),\n    ),\n    // ... rest of spans\n];\n```\n\n### Update title to show pinned count\n```rust\nlet pinned_count = self.entries.iter().filter(|e| e.pinned).count();\n\nlet title = if !self.search_query.is_empty() {\n    format!(\n        \"History ({}/{}) matching '{}'\",\n        self.filtered.len(), self.entries.len(), self.search_query\n    )\n} else if pinned_count \u003e 0 {\n    format!(\n        \"History ({}/{}) - {} pinned\",\n        self.filtered.len(), self.entries.len(), pinned_count\n    )\n} else {\n    format!(\"History ({}/{})\", self.filtered.len(), self.entries.len())\n};\n```\n\n### Update status line help\n```rust\n// In render_status_line()\n\"[NORMAL] Tab:Switch  j/k:Nav  p:Pin  d:Del  /:Search  Enter:Paste\"\n```\n\n### Update Stats command in main.rs\n```rust\nSome(Commands::Stats) =\u003e {\n    let index = storage.load_index()?;\n    let total_size: usize = index.entries.iter().map(|e| e.size).sum();\n    let pinned_count = index.entries.iter().filter(|e| e.pinned).count();\n    let unpinned_count = index.entries.len() - pinned_count;\n    \n    println!(\"Entries:    {}\", index.entries.len());\n    println!(\"  Pinned:   {} (protected)\", pinned_count);\n    println!(\"  Regular:  {}/{}\", unpinned_count, storage.max_entries());\n    println!(\"Total size: {}\", util::format_size(total_size));\n    // ... rest of stats\n}\n```\n\n## Visual Result\n```\n┌─History (5/105) - 3 pinned────────────────────┐\n│\u003e ★ 2d ago [   45B] My email signature...      │\n│  ★ 5d ago [  128B] import { useState }...     │\n│  ★ 1w ago [   32B] const API_BASE = ...       │\n│  10s ago [  1.2KB] function handleClick()...  │\n└───────────────────────────────────────────────┘\n[NORMAL] Tab:Switch  j/k:Nav  p:Pin  d:Del  /:Search  Enter:Paste\n```\n\n## Files Changed\n- src/picker.rs: Update render_list(), render_status_line()\n- src/main.rs: Update Stats command\n\n## Acceptance Criteria\n- [ ] Yellow ★ shows for pinned entries\n- [ ] Title shows pinned count when \u003e0\n- [ ] Status line shows p:Pin hint\n- [ ] stats command shows pinned breakdown","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:32:46.577621755-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:32:46.577621755-05:00","dependencies":[{"issue_id":"clipboard-b6y.25","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:32:46.579625975-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.25","depends_on_id":"clipboard-b6y.21","type":"blocks","created_at":"2026-01-13T15:40:57.671141714-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.26","title":"[#2] Write comprehensive unit tests for pin functionality","description":"## Overview\nTDD: Comprehensive tests for all pin functionality including edge cases.\n\n## Test Cases (copy-paste ready)\n\n```rust\n#[cfg(test)]\nmod pin_tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    fn test_storage() -\u003e (Storage, TempDir) {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        (storage, dir)\n    }\n    \n    #[test]\n    fn test_new_entry_not_pinned() {\n        let (storage, _dir) = test_storage();\n        let entry = storage.save_entry(\"test\").unwrap();\n        assert!(!entry.pinned, \"New entries should not be pinned\");\n    }\n    \n    #[test]\n    fn test_toggle_pin_on() {\n        let (storage, _dir) = test_storage();\n        let entry = storage.save_entry(\"pin me\").unwrap();\n        \n        let is_pinned = storage.toggle_pin(\u0026entry.id).unwrap();\n        assert!(is_pinned, \"Should return true after pinning\");\n        \n        // Verify persistence\n        let index = storage.load_index().unwrap();\n        let loaded = index.entries.iter().find(|e| e.id == entry.id).unwrap();\n        assert!(loaded.pinned, \"Pin state should persist\");\n    }\n    \n    #[test]\n    fn test_toggle_pin_off() {\n        let (storage, _dir) = test_storage();\n        let entry = storage.save_entry(\"toggle me\").unwrap();\n        \n        storage.toggle_pin(\u0026entry.id).unwrap();  // Pin\n        let is_pinned = storage.toggle_pin(\u0026entry.id).unwrap();  // Unpin\n        assert!(!is_pinned, \"Should return false after unpinning\");\n    }\n    \n    #[test]\n    fn test_pinned_survives_pruning() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 10).unwrap();\n        \n        // Create and pin an entry\n        let pinned_entry = storage.save_entry(\"keep me\").unwrap();\n        storage.toggle_pin(\u0026pinned_entry.id).unwrap();\n        \n        // Fill beyond limit\n        for i in 0..20 {\n            storage.save_entry(\u0026format!(\"filler {}\", i)).unwrap();\n        }\n        \n        // Verify pinned entry still exists\n        let index = storage.load_index().unwrap();\n        let found = index.entries.iter().find(|e| e.id == pinned_entry.id);\n        assert!(found.is_some(), \"Pinned entry should survive pruning\");\n        assert!(found.unwrap().pinned, \"Should still be pinned\");\n        \n        // Verify unpinned count is at limit\n        let unpinned = index.entries.iter().filter(|e| !e.pinned).count();\n        assert_eq!(unpinned, 10, \"Unpinned should be capped at max_entries\");\n    }\n    \n    #[test]\n    fn test_pin_limit_enforced() {\n        let (storage, _dir) = test_storage();\n        \n        // Pin MAX_PINNED entries\n        for i in 0..MAX_PINNED {\n            let entry = storage.save_entry(\u0026format!(\"pinned {}\", i)).unwrap();\n            storage.toggle_pin(\u0026entry.id).unwrap();\n        }\n        \n        // Try to pin one more\n        let extra = storage.save_entry(\"one too many\").unwrap();\n        let result = storage.toggle_pin(\u0026extra.id);\n        \n        assert!(result.is_err(), \"Should fail at pin limit\");\n        assert!(result.unwrap_err().to_string().contains(\"Maximum\"), \n                \"Error should mention maximum\");\n    }\n    \n    #[test]\n    fn test_duplicate_preserves_pin_status() {\n        let (storage, _dir) = test_storage();\n        \n        // Create and pin an entry\n        let original = storage.save_entry(\"duplicate me\").unwrap();\n        storage.toggle_pin(\u0026original.id).unwrap();\n        \n        // Add other entries\n        storage.save_entry(\"other 1\").unwrap();\n        storage.save_entry(\"other 2\").unwrap();\n        \n        // Re-copy same content\n        let dup = storage.save_entry(\"duplicate me\").unwrap();\n        \n        // Should be same entry, moved to front, still pinned\n        assert_eq!(dup.id, original.id, \"Should return same entry ID\");\n        \n        let index = storage.load_index().unwrap();\n        assert_eq!(index.entries[0].id, original.id, \"Should be moved to front\");\n        assert!(index.entries[0].pinned, \"Pin status should be preserved\");\n    }\n    \n    #[test]\n    fn test_backwards_compat_missing_pinned_field() {\n        let dir = TempDir::new().unwrap();\n        let index_path = dir.path().join(\"index.json\");\n        \n        // Write old-format index (no pinned field)\n        std::fs::write(\u0026index_path, r#\"{\n            \"max_entries\": 100,\n            \"entries\": [{\n                \"id\": \"12345\",\n                \"timestamp\": 12345,\n                \"size\": 4,\n                \"preview\": \"test\",\n                \"hash\": \"sha256:abc\"\n            }]\n        }\"#).unwrap();\n        \n        std::fs::write(dir.path().join(\"12345.txt\"), \"test\").unwrap();\n        \n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let index = storage.load_index().unwrap();\n        \n        assert_eq!(index.entries.len(), 1, \"Should load old format\");\n        assert!(!index.entries[0].pinned, \"Should default to false\");\n    }\n    \n    #[test]\n    fn test_set_pinned_explicit() {\n        let (storage, _dir) = test_storage();\n        let entry = storage.save_entry(\"test\").unwrap();\n        \n        storage.set_pinned(\u0026entry.id, true).unwrap();\n        let index = storage.load_index().unwrap();\n        assert!(index.entries[0].pinned);\n        \n        storage.set_pinned(\u0026entry.id, false).unwrap();\n        let index = storage.load_index().unwrap();\n        assert!(!index.entries[0].pinned);\n    }\n    \n    #[test]\n    fn test_pinned_count() {\n        let (storage, _dir) = test_storage();\n        \n        assert_eq!(storage.pinned_count().unwrap(), 0);\n        \n        let e1 = storage.save_entry(\"one\").unwrap();\n        let e2 = storage.save_entry(\"two\").unwrap();\n        storage.toggle_pin(\u0026e1.id).unwrap();\n        storage.toggle_pin(\u0026e2.id).unwrap();\n        \n        assert_eq!(storage.pinned_count().unwrap(), 2);\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add test module\n\n## Acceptance Criteria\n- [ ] All 10 tests pass\n- [ ] Tests run: cargo test pin_tests\n- [ ] Backwards compatibility verified","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:36:06.39915299-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:36:06.39915299-05:00","dependencies":[{"issue_id":"clipboard-b6y.26","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:36:06.401289757-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.26","depends_on_id":"clipboard-b6y.21","type":"blocks","created_at":"2026-01-13T15:40:57.708637028-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.27","title":"[#2] Write E2E test script for pinned entries","description":"## Overview\nEnd-to-end test script verifying pinned functionality in practice.\n\n## E2E Test Script (tests/e2e_pinned.sh)\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# E2E Tests for Pinned/Favorites Feature\n# Run from project root: ./tests/e2e_pinned.sh\n\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nTEST_DIR=$(mktemp -d)\nCLIPSTACK=\"./target/release/clipstack\"\n\nlog_pass() { echo -e \"${GREEN}✓${NC} $1\"; }\nlog_fail() { echo -e \"${RED}✗${NC} $1\"; exit 1; }\nlog_info() { echo -e \"${YELLOW}→${NC} $1\"; }\n\ncleanup() { rm -rf \"$TEST_DIR\"; }\ntrap cleanup EXIT\n\n# Build release if needed\n[[ -f \"$CLIPSTACK\" ]] || cargo build --release\n\nlog_info \"Test directory: $TEST_DIR\"\n\n# Test 1: Stats shows pinned count\nlog_info \"Test 1: Pinned count in stats\"\necho \"entry1\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test1\" copy\n$CLIPSTACK --storage-dir \"$TEST_DIR/test1\" stats | grep -q \"Pinned:.*0\" \u0026\u0026 \\\n    log_pass \"Stats shows 0 pinned initially\" || log_fail \"Stats should show pinned count\"\n\n# Test 2: Pinned entries survive pruning\nlog_info \"Test 2: Pinned survive pruning\"\n# Create entry and manually mark as pinned (we can't use picker in script)\necho \"keep me forever\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test2\" --max-entries 5 copy\nKEEP_ID=$(cat \"$TEST_DIR/test2/index.json\" | grep -o '\"id\":\"[^\"]*\"' | head -1 | cut -d'\"' -f4)\n\n# Manually pin by editing JSON (simulating picker 'p' key)\nsed -i 's/\"pinned\":false/\"pinned\":true/' \"$TEST_DIR/test2/index.json\" 2\u003e/dev/null || \\\n    sed -i '' 's/\"pinned\":false/\"pinned\":true/' \"$TEST_DIR/test2/index.json\"\n\n# Fill beyond limit\nfor i in {1..10}; do\n    echo \"filler $i\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test2\" --max-entries 5 copy\ndone\n\n# Check pinned entry survives\nif grep -q \"$KEEP_ID\" \"$TEST_DIR/test2/index.json\" 2\u003e/dev/null; then\n    log_pass \"Pinned entry survived pruning\"\nelse\n    log_fail \"Pinned entry was incorrectly pruned\"\nfi\n\n# Test 3: Backwards compatibility (old index without pinned field)\nlog_info \"Test 3: Backwards compatibility\"\nmkdir -p \"$TEST_DIR/test3\"\ncat \u003e \"$TEST_DIR/test3/index.json\" \u003c\u003c 'EOF'\n{\n  \"max_entries\": 100,\n  \"entries\": [\n    {\"id\":\"1234\",\"timestamp\":1234,\"size\":4,\"preview\":\"test\",\"hash\":\"sha256:abc\"}\n  ]\n}\nEOF\necho \"test\" \u003e \"$TEST_DIR/test3/1234.txt\"\n\n$CLIPSTACK --storage-dir \"$TEST_DIR/test3\" stats \u003e/dev/null 2\u003e\u00261 \u0026\u0026 \\\n    log_pass \"Old format index loads\" || log_fail \"Should load old format\"\n\n# Test 4: Unpinned count respects limit\nlog_info \"Test 4: Unpinned respects limit\"\nrm -rf \"$TEST_DIR/test4\"\nfor i in {1..15}; do\n    echo \"entry $i\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test4\" --max-entries 10 copy\ndone\n\nTOTAL=$(cat \"$TEST_DIR/test4/index.json\" | grep -c '\"id\"' || echo 0)\n[[ \"$TOTAL\" -le 12 ]] \u0026\u0026 \\\n    log_pass \"Entry limit respected ($TOTAL entries)\" || \\\n    log_fail \"Too many entries: $TOTAL\"\n\n# Test 5: Duplicate preserves pin (manual pin + re-copy)\nlog_info \"Test 5: Duplicate preserves pin\"\nmkdir -p \"$TEST_DIR/test5\"\necho \"duplicate content\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test5\" copy\n\n# Pin the entry\nsed -i 's/\"pinned\":false/\"pinned\":true/' \"$TEST_DIR/test5/index.json\" 2\u003e/dev/null || \\\n    sed -i '' 's/\"pinned\":false/\"pinned\":true/' \"$TEST_DIR/test5/index.json\"\n\n# Re-copy same content\necho \"duplicate content\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test5\" copy\n\n# Should still be pinned\nif grep -q '\"pinned\":true' \"$TEST_DIR/test5/index.json\"; then\n    log_pass \"Duplicate preserved pin status\"\nelse\n    log_fail \"Duplicate lost pin status\"\nfi\n\necho \"\"\necho -e \"${GREEN}All E2E tests passed!${NC}\"\n```\n\n## Acceptance Criteria\n- [ ] Script at tests/e2e_pinned.sh\n- [ ] All 5 tests pass\n- [ ] Tests backwards compatibility\n- [ ] Tests pruning protection","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:39:47.67463296-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:39:47.67463296-05:00","dependencies":[{"issue_id":"clipboard-b6y.27","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T15:39:47.676474942-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.27","depends_on_id":"clipboard-b6y.26","type":"blocks","created_at":"2026-01-13T15:40:57.745733846-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-b6y.3","title":"[#2] Implement toggle_pin() method","description":"Add pub fn toggle_pin(\u0026self, id: \u0026str) -\u003e Result\u003cbool\u003e to Storage. Returns new pin state. Must check MAX_PINNED limit when pinning. Save index after toggle (uses atomic write).","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:33:10.112748944-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.3","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:33:10.114376576-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.3","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.006472648-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.3","depends_on_id":"clipboard-b6y.2","type":"blocks","created_at":"2026-01-13T12:35:07.043639647-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.4","title":"[#2] Implement set_pinned() method","description":"Add pub fn set_pinned(\u0026self, id: \u0026str, pinned: bool) -\u003e Result\u003c()\u003e to Storage. Direct setter for pin state. Check MAX_PINNED when setting to true. Used by undo to restore exact state.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:05.69627743-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.4","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:05.697785429-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.4","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.079517868-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.5","title":"[#2] Implement pinned_count() method","description":"Add pub fn pinned_count(\u0026self) -\u003e Result\u003cusize\u003e to Storage. Returns count of entries where pinned=true. Used by toggle_pin to check limit and by stats command for display.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:06.069656839-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.5","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:06.071440502-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.5","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.113991593-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.6","title":"[#2] Update prune_entries() to skip pinned entries","description":"Modify prune logic: when counting entries against max_entries, only count unpinned entries. When removing oldest, use rposition to find oldest UNPINNED entry. Pinned entries are exempt from pruning.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:06.39750453-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.6","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:06.399104029-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.6","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.148589099-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.7","title":"[#2] Update save_entry() duplicate handling for pin preservation","description":"When save_entry detects duplicate by hash: if existing entry is pinned, preserve pin status when moving to front. If unpinned, keep unpinned. Never auto-unpin on re-copy.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:06.729756151-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.7","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:06.731319834-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.7","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.184488789-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.8","title":"[#2] Update DeletedEntry to preserve pin state","description":"Add pinned: bool field to DeletedEntry struct. When deleting entry, store its pin state. When undoing, restore the exact pin state - don't lose user's pin decision.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:08.039608452-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.8","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:08.045188671-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.8","depends_on_id":"clipboard-b6y.1","type":"blocks","created_at":"2026-01-13T12:35:07.219409741-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-b6y.9","title":"[#2] Add toggle_pin_selected() to Picker","description":"Add method to toggle pin on currently selected entry. Call storage.toggle_pin(id), update local entries state, re-sort list, set status message 'Pinned'/'Unpinned'. Handle errors gracefully (show in status).","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:34:36.468148888-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:53.716029182-05:00","dependencies":[{"issue_id":"clipboard-b6y.9","depends_on_id":"clipboard-b6y","type":"parent-child","created_at":"2026-01-13T12:34:36.469606913-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.9","depends_on_id":"clipboard-b6y.3","type":"blocks","created_at":"2026-01-13T12:35:07.254170091-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-b6y.9","depends_on_id":"clipboard-b6y.10","type":"blocks","created_at":"2026-01-13T12:35:07.290923477-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:53.716029182-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve","title":"Improvement #4: Preview Scrolling with Focus Mode","description":"Preview pane shows fixed view - no way to see beyond ~30 lines without pasting. Tedious workflow: paste, read, undo if wrong, try another. Solution: add focus mode (Tab toggles between list/preview focus), Ctrl+D/U scrolls focused pane. Scroll position indicator shows line range. Visual scroll arrows when content extends beyond view.","status":"open","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:35:25.940879085-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T14:01:11.579085701-05:00","dependencies":[{"issue_id":"clipboard-pve","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:36:36.827178452-05:00","created_by":"solsystemlabs"}],"comments":[{"id":6,"issue_id":"clipboard-pve","author":"solsystemlabs","text":"# Improvement #4: Preview Scrolling with Focus Mode - Detailed Documentation\n\n## Problem Statement\n\nThe preview pane shows a fixed view of clipboard content. For long entries, users see only the first ~30 lines with a \"[+N lines]\" indicator. There's NO way to view the rest without:\n\n1. Selecting the entry\n2. Pasting somewhere\n3. Reading the pasted content\n4. Deciding if it's the right entry\n5. Undoing the paste if wrong\n6. Trying another entry\n\nThis workflow is **tedious and disruptive**. Users should be able to scroll through content BEFORE committing to a selection.\n\n## Solution Design: Focus Mode + Scrolling\n\n### Focus Mode\n- `Tab` key toggles focus between List and Preview panes\n- Focused pane has highlighted border (Color::Cyan)\n- Unfocused pane has dimmed border (Color::DarkGray)\n\n### Scrolling (in focused pane)\n- `Ctrl+D`: Scroll down half page (~15 lines)\n- `Ctrl+U`: Scroll up half page (~15 lines)\n- `j/k`: Move by 1 line (when preview focused) OR navigate list (when list focused)\n\n### Visual Feedback\n- Scroll position in title: `[lines 45-75/150]`\n- Scroll indicators: `▲` at top, `▼` at bottom when more content exists\n\n## Implementation Requirements\n\n### New Types\n\n```rust\n#[derive(Clone, Copy, PartialEq, Default)]\nenum Focus {\n    #[default]\n    List,\n    Preview,\n}\n```\n\n### New Picker Fields\n\n```rust\npub struct Picker {\n    // ... existing fields ...\n    preview_scroll: usize,  // NEW: scroll offset in lines\n    focus: Focus,           // NEW: which pane has focus\n}\n```\n\n### Key Methods\n\n```rust\n/// Scroll preview by delta lines (positive = down, negative = up)\nfn scroll_preview(\u0026mut self, delta: i32) {\n    if let Some(content) = \u0026self.preview_content {\n        let total_lines = content.lines().count();\n        // Clamp to valid range\n        self.preview_scroll = new_scroll.min(total_lines.saturating_sub(1));\n    }\n}\n\n/// Toggle focus between List and Preview\nfn toggle_focus(\u0026mut self) {\n    self.focus = match self.focus {\n        Focus::List =\u003e Focus::Preview,\n        Focus::Preview =\u003e Focus::List,\n    };\n}\n```\n\n### load_preview() Changes\n\nCRITICAL: Reset scroll to 0 when selection changes!\n\n```rust\nfn load_preview(\u0026mut self) {\n    // ... existing logic ...\n    self.preview_scroll = 0;  // Reset on new selection\n}\n```\n\n### render_preview() Changes\n\n```rust\nfn render_preview(\u0026self, frame: \u0026mut Frame, area: Rect) {\n    // Apply scroll offset\n    let visible_lines: Vec\u003c\u0026str\u003e = lines\n        .iter()\n        .skip(self.preview_scroll)  // Skip scrolled lines\n        .take(visible_height)\n        .collect();\n\n    // Build title with scroll position\n    let title = format!(\n        \"Preview - {} [lines {}-{}/{}]\",\n        metadata, start_line, end_line, total_lines\n    );\n\n    // Focus-aware border style\n    let border_color = if self.focus == Focus::Preview {\n        Color::Cyan\n    } else {\n        Color::DarkGray\n    };\n}\n```\n\n### Key Handler Changes\n\n```rust\nKeyCode::Tab =\u003e {\n    self.toggle_focus();\n}\n\nKeyCode::Char('j') =\u003e {\n    match self.focus {\n        Focus::List =\u003e self.move_selection(1),\n        Focus::Preview =\u003e self.scroll_preview(1),\n    }\n}\n\nKeyCode::Char('d') if key.modifiers.contains(KeyModifiers::CONTROL) =\u003e {\n    match self.focus {\n        Focus::List =\u003e self.move_selection(15),  // Page down list\n        Focus::Preview =\u003e self.scroll_preview(15),  // Scroll preview\n    }\n}\n```\n\n## Design Decision: Tab for Focus Toggle\n\nWhy Tab instead of other keys?\n\n1. **Intuitive**: Tab commonly switches focus in UIs\n2. **Available**: Not used for anything else in picker\n3. **Discoverable**: Users try Tab naturally\n4. **Non-destructive**: Doesn't conflict with typing\n\n## Testing Requirements (TDD)\n\n1. `test_preview_scroll_down()` - Basic scroll works\n2. `test_preview_scroll_clamps_to_content()` - Can't scroll past end\n3. `test_preview_scroll_negative_clamps_to_zero()` - Can't scroll before start\n4. `test_preview_scroll_resets_on_selection_change()` - New selection resets scroll\n5. `test_focus_toggle()` - Tab switches focus correctly\n6. `test_focus_aware_navigation()` - j/k behavior depends on focus\n\n## Visual Mockup\n\n```\n┌─Preview - 2.3KB - 5m ago [lines 45-75/150]────┐  ← Cyan border (focused)\n│    return {                                    │\n│      user: data.user,                          │\n│      token: generateToken(data.user.id),       │\n│      permissions: await getPermissions(        │\n│        data.user.role                          │\n│      ),                                        │\n│    };                                          │\n│  } catch (error) {                             │\n│    logger.error('Auth failed', { error });     │\n│    throw new AuthenticationError(error);       │\n│  }                                             │\n│}                                              ▼│ ← Scroll indicator\n└───────────────────────────────────────────────┘\n[NORMAL] Tab:Focus  Ctrl+D/U:Scroll  j/k:Nav  Enter:Paste\n```\n\n## Success Criteria\n\n- [ ] Tab toggles focus between list and preview\n- [ ] Ctrl+D/U scrolls the focused pane\n- [ ] j/k navigation is focus-aware\n- [ ] Scroll position indicator shows line range\n- [ ] Visual scroll indicators (▲/▼) show when more content exists\n- [ ] Scroll resets when selection changes\n- [ ] Focused pane has distinct border color\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| src/picker.rs | Focus enum, preview_scroll field, scroll_preview(), toggle_focus(), focus-aware key handlers, updated render functions |\n\n## Dependencies\n\n- **Depends on**: Improvement #2 (Pinned system affects entry display)\n- **Can run parallel to**: Improvement #1 (but #1 should be done first as it changes filtered type)\n","created_at":"2026-01-13T17:36:36Z"}]}
{"id":"clipboard-pve.1","title":"[#4] Define Focus enum (List, Preview)","description":"#[derive(Clone, Copy, PartialEq, Default)] enum Focus { #[default] List, Preview }. Tracks which pane has keyboard focus. Default to List for backwards-compatible behavior.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:39:53.010068556-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.1","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:39:53.011771149-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.10","title":"[#4] Update render_list() with focus-aware border style","description":"List pane border: Color::Cyan when focus==List, Color::DarkGray otherwise. Visual feedback for which pane will respond to navigation.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:12.991863442-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.10","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:12.993356633-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.10","depends_on_id":"clipboard-pve.3","type":"blocks","created_at":"2026-01-13T12:40:39.199171147-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.11","title":"[#4] Update render_preview() with focus-aware border style","description":"Preview pane border: Color::Cyan when focus==Preview, Color::DarkGray otherwise. Matches list pane focus styling.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:15.133606779-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.11","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:15.13534029-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.11","depends_on_id":"clipboard-pve.3","type":"blocks","created_at":"2026-01-13T12:40:39.239481691-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.12","title":"[#4] Add Tab key handler for focus toggle","description":"In handle_normal_mode(): KeyCode::Tab =\u003e self.toggle_focus(). Simple and intuitive keybinding.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:17.268838727-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.12","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:17.270522155-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.12","depends_on_id":"clipboard-pve.5","type":"blocks","created_at":"2026-01-13T12:40:39.279794639-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.13","title":"[#4] Update j/k navigation to be focus-aware","description":"j/k handlers: if focus==List then move_selection(), if focus==Preview then scroll_preview(1/-1). Same keys, different targets based on focus.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:19.404682525-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.13","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:19.406251768-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.13","depends_on_id":"clipboard-pve.4","type":"blocks","created_at":"2026-01-13T12:40:39.320470426-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.13","depends_on_id":"clipboard-pve.3","type":"blocks","created_at":"2026-01-13T12:40:39.361466632-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.14","title":"[#4] Update Ctrl+D/U to be focus-aware","description":"Ctrl+D/U: if focus==List then page navigation (move_selection(15)), if focus==Preview then scroll_preview(15/-15). Half-page scrolling.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:21.573643962-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.14","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:21.575370861-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.14","depends_on_id":"clipboard-pve.4","type":"blocks","created_at":"2026-01-13T12:40:39.402681516-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.14","depends_on_id":"clipboard-pve.3","type":"blocks","created_at":"2026-01-13T12:40:39.445253218-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.15","title":"[#4] Update status line to show focus state","description":"Update help text: 'Tab:Focus Ctrl+D/U:Scroll j/k:Nav'. Shows available commands. Consider showing current focus: '[LIST]' or '[PREVIEW]' mode indicator.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:23.724884274-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.15","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:23.726676414-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.16","title":"[#4] Write unit tests for scroll operations","description":"test_preview_scroll_down(), test_preview_scroll_clamps_to_content() (can't scroll past end), test_preview_scroll_negative_clamps_to_zero() (can't scroll before start).","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:26.109296601-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.16","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:26.11093794-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.16","depends_on_id":"clipboard-pve.2","type":"blocks","created_at":"2026-01-13T14:00:52.36367847-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.17","title":"[#4] Write unit tests for focus toggle","description":"test_focus_toggle(): verify toggle_focus() switches between List and Preview correctly. test_preview_scroll_resets_on_selection_change(): verify scroll=0 after changing selection.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:28.248980317-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.17","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:28.250889166-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.17","depends_on_id":"clipboard-pve.1","type":"blocks","created_at":"2026-01-13T14:01:02.215331854-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.17","depends_on_id":"clipboard-pve.3","type":"blocks","created_at":"2026-01-13T15:00:03.400885657-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.18","title":"[#4] Write E2E test script for preview scrolling","description":"Create comprehensive E2E test script (tests/e2e/test_preview_scrolling.sh) that verifies preview scrolling with focus mode. Tests:\n1. Tab toggles focus between List and Preview panes\n2. Ctrl+D scrolls down half page (~15 lines) in focused pane\n3. Ctrl+U scrolls up half page (~15 lines) in focused pane\n4. j/k navigation respects focus (list nav vs preview scroll)\n5. Scroll position indicator shows correct line range [lines X-Y/Z]\n6. Visual scroll indicators (▲/▼) appear when content extends beyond view\n7. Scroll resets to 0 when selection changes\n8. Focused pane has distinct border color (Cyan vs DarkGray)\n\nLOGGING REQUIREMENTS:\n- Use colored output: GREEN=pass, RED=fail, YELLOW=info\n- Each test prints: [TEST N] Description... followed by result\n- For focus tests, show: \"Focus: List -\u003e Preview -\u003e List\"\n- For scroll tests, show: \"Scroll position: 0 -\u003e 15 -\u003e 30\"\n- For indicator tests, show: \"Title shows: [lines 45-75/150]\"\n- Print summary at end: \"X/Y tests passed\"\n- Exit code: 0 if all pass, 1 if any fail\n\nCLEANUP: Create temp CLIPSTACK_DATA_DIR per test, remove after each test\n\nNOTE: Some tests require simulating keypresses - use expect or similar tool\n\nExample output format:\n[TEST 2] Ctrl+D scrolls preview down...\n  Creating entry with 200 lines...\n  Initial scroll position: 0\n  Sending Ctrl+D...\n  Expected scroll: 15, Got: 15\n  Sending Ctrl+D...\n  Expected scroll: 30, Got: 30\n  ✓ PASS","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T13:30:00.118947023-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.18","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T13:30:00.120858248-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.18","depends_on_id":"clipboard-pve.17","type":"blocks","created_at":"2026-01-13T13:30:10.578744348-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.19","title":"Add Focus enum and scrolling state to PickerState","description":"## Overview\nAdd the Focus enum for mode tracking and scroll state fields to PickerState for preview scrolling support.\n\n## Implementation Details\n\n### Focus Enum\n```rust\n#[derive(Clone, Copy, PartialEq, Default)]\nenum Focus {\n    #[default]\n    List,     // Normal mode - navigate entry list\n    Preview,  // Preview mode - scroll through selected entry content\n}\n```\n\n### PickerState Additional Fields\n```rust\nstruct PickerState {\n    // Existing fields...\n    focus: Focus,                    // Current focus mode\n    preview_scroll: usize,           // Current scroll offset in preview\n    preview_lines: Vec\u003cString\u003e,      // Cached wrapped lines of preview content\n    preview_height: u16,             // Available height for preview area\n}\n```\n\n### Default Values\n```rust\nimpl Default for PickerState {\n    fn default() -\u003e Self {\n        Self {\n            // existing...\n            focus: Focus::List,\n            preview_scroll: 0,\n            preview_lines: Vec::new(),\n            preview_height: 10,  // Updated dynamically during render\n        }\n    }\n}\n```\n\n## Key Design Decisions\n- Focus::List is default (backwards compatible)\n- preview_lines caches wrapped text to avoid re-wrapping on scroll\n- preview_height updated each render cycle for responsive design\n- preview_scroll resets to 0 when selection changes\n\n## Files to Modify\n- src/picker.rs: Add Focus enum, update PickerState struct\n\n## Acceptance Criteria\n- [ ] Focus enum with List and Preview variants\n- [ ] Focus derives Clone, Copy, PartialEq, Default\n- [ ] PickerState has focus, preview_scroll, preview_lines, preview_height fields\n- [ ] Default implementation initializes all new fields\n- [ ] Code compiles without warnings","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:42:57.673324566-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:42:57.673324566-05:00","dependencies":[{"issue_id":"clipboard-pve.19","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:42:57.675148583-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.2","title":"[#4] Add preview_scroll field to Picker","description":"Add preview_scroll: usize field to Picker struct. Tracks scroll offset in lines. Initialize to 0. Reset when selection changes.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:39:55.312080505-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.2","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:39:55.313751809-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.20","title":"Implement Tab focus toggle and preview content loading","description":"## Overview\nImplement Tab key to toggle between List and Preview focus modes, with content loading and line wrapping.\n\n## Implementation Details\n\n### Tab Key Handler\n```rust\nKeyCode::Tab =\u003e {\n    self.focus = match self.focus {\n        Focus::List =\u003e {\n            // Entering preview mode - load and wrap content\n            self.load_preview_content(storage)?;\n            Focus::Preview\n        }\n        Focus::Preview =\u003e {\n            // Exiting preview mode - clear cache\n            self.preview_lines.clear();\n            self.preview_scroll = 0;\n            Focus::List\n        }\n    };\n}\n```\n\n### Content Loading and Wrapping\n```rust\nfn load_preview_content(\u0026mut self, storage: \u0026Storage) -\u003e Result\u003c()\u003e {\n    let entry = match self.current_entry() {\n        Some(e) =\u003e e,\n        None =\u003e return Ok(()),\n    };\n    \n    let content = storage.load_content(\u0026entry.id)?;\n    \n    // Wrap lines to preview width (typically terminal width - padding)\n    let wrap_width = 80;  // Or get from terminal size\n    self.preview_lines = content\n        .lines()\n        .flat_map(|line| {\n            if line.len() \u003c= wrap_width {\n                vec![line.to_string()]\n            } else {\n                line.chars()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .chunks(wrap_width)\n                    .map(|c| c.iter().collect::\u003cString\u003e())\n                    .collect()\n            }\n        })\n        .collect();\n    \n    self.preview_scroll = 0;\n    Ok(())\n}\n```\n\n### Selection Change Reset\nWhen selection changes in List mode, reset preview cache:\n```rust\nfn set_selected(\u0026mut self, idx: usize) {\n    if self.selected != idx {\n        self.selected = idx;\n        self.preview_lines.clear();  // Invalidate cache\n        self.preview_scroll = 0;\n    }\n}\n```\n\n## Key Design Decisions\n- Tab is intuitive toggle (like tab between form fields)\n- Content loaded lazily only when entering Preview mode\n- Line wrapping preserves existing line breaks\n- Cache cleared on selection change to avoid stale data\n\n## Files to Modify\n- src/picker.rs: Add Tab handler, load_preview_content method, update set_selected\n\n## Acceptance Criteria\n- [ ] Tab toggles between List and Preview focus\n- [ ] Content loaded when entering Preview mode\n- [ ] Lines wrapped to fit preview width\n- [ ] Preview cache cleared on selection change\n- [ ] Preview scroll resets on mode change","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:43:21.416419841-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:43:21.416419841-05:00","dependencies":[{"issue_id":"clipboard-pve.20","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:43:21.418328707-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.20","depends_on_id":"clipboard-pve.19","type":"blocks","created_at":"2026-01-13T15:44:53.26704141-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.21","title":"Implement preview scroll navigation keys","description":"## Overview\nImplement keyboard navigation for scrolling through preview content when in Focus::Preview mode.\n\n## Implementation Details\n\n### Navigation Keys in Preview Mode\n```rust\n// In handle_event match block, when self.focus == Focus::Preview:\nmatch key.code {\n    // Line-by-line scrolling\n    KeyCode::Up | KeyCode::Char('k') =\u003e {\n        self.preview_scroll = self.preview_scroll.saturating_sub(1);\n    }\n    KeyCode::Down | KeyCode::Char('j') =\u003e {\n        let max_scroll = self.preview_lines.len().saturating_sub(self.preview_height as usize);\n        if self.preview_scroll \u003c max_scroll {\n            self.preview_scroll += 1;\n        }\n    }\n    \n    // Page scrolling\n    KeyCode::PageUp =\u003e {\n        self.preview_scroll = self.preview_scroll.saturating_sub(self.preview_height as usize);\n    }\n    KeyCode::PageDown =\u003e {\n        let max_scroll = self.preview_lines.len().saturating_sub(self.preview_height as usize);\n        let page = self.preview_height as usize;\n        self.preview_scroll = (self.preview_scroll + page).min(max_scroll);\n    }\n    \n    // Jump to top/bottom\n    KeyCode::Home | KeyCode::Char('g') =\u003e {\n        self.preview_scroll = 0;\n    }\n    KeyCode::End | KeyCode::Char('G') =\u003e {\n        let max_scroll = self.preview_lines.len().saturating_sub(self.preview_height as usize);\n        self.preview_scroll = max_scroll;\n    }\n    \n    // Exit preview mode\n    KeyCode::Tab | KeyCode::Esc | KeyCode::Char('q') =\u003e {\n        self.focus = Focus::List;\n        self.preview_lines.clear();\n        self.preview_scroll = 0;\n    }\n    \n    _ =\u003e {}\n}\n```\n\n### Scroll Bounds Calculation\n```rust\nfn max_scroll(\u0026self) -\u003e usize {\n    self.preview_lines.len().saturating_sub(self.preview_height as usize)\n}\n```\n\n## Key Design Decisions\n- j/k for vi-style line navigation\n- PageUp/PageDown for fast scrolling\n- g/G for top/bottom (vi-style)\n- Multiple exit keys (Tab, Esc, q) for convenience\n- saturating_sub prevents underflow on boundaries\n\n## Files to Modify\n- src/picker.rs: Update handle_event for Focus::Preview keybindings\n\n## Acceptance Criteria\n- [ ] Up/k scrolls up one line\n- [ ] Down/j scrolls down one line\n- [ ] PageUp/PageDown scroll by page\n- [ ] g/Home jumps to top\n- [ ] G/End jumps to bottom\n- [ ] Tab/Esc/q exits preview mode\n- [ ] Scroll bounds respected (no over-scroll)","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:43:37.23253047-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:43:37.23253047-05:00","dependencies":[{"issue_id":"clipboard-pve.21","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:43:37.234523674-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.21","depends_on_id":"clipboard-pve.20","type":"blocks","created_at":"2026-01-13T15:44:53.307025597-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.22","title":"Update rendering for preview focus mode with scroll indicators","description":"## Overview\nUpdate the Picker rendering to show scrollable preview with visual indicators for focus mode and scroll position.\n\n## Implementation Details\n\n### Focus Mode Indicator in Title\n```rust\nfn render_title(\u0026self) -\u003e String {\n    match self.focus {\n        Focus::List =\u003e format!(\"ClipStack ({} entries)\", self.entries.len()),\n        Focus::Preview =\u003e format!(\"ClipStack [PREVIEW] - Tab to exit\"),\n    }\n}\n```\n\n### Preview Pane Rendering\n```rust\nfn render_preview(\u0026self, area: Rect, buf: \u0026mut Buffer) {\n    // Update height for scroll calculations\n    self.preview_height = area.height.saturating_sub(2);  // Account for borders\n    \n    // Calculate visible window\n    let start = self.preview_scroll;\n    let end = (start + self.preview_height as usize).min(self.preview_lines.len());\n    \n    // Render visible lines\n    for (i, line) in self.preview_lines[start..end].iter().enumerate() {\n        let y = area.y + i as u16 + 1;  // +1 for border\n        buf.set_string(area.x + 1, y, line, Style::default());\n    }\n    \n    // Scroll position indicator\n    if self.preview_lines.len() \u003e self.preview_height as usize {\n        let indicator = format!(\n            \"Lines {}-{} of {}\",\n            start + 1,\n            end,\n            self.preview_lines.len()\n        );\n        buf.set_string(area.x + 1, area.y + area.height - 1, \u0026indicator, Style::default().dim());\n    }\n}\n```\n\n### Scroll Bar Indicator\n```rust\nfn render_scrollbar(\u0026self, area: Rect, buf: \u0026mut Buffer) {\n    if self.preview_lines.len() \u003c= self.preview_height as usize {\n        return;  // No scrollbar needed\n    }\n    \n    let total = self.preview_lines.len();\n    let visible = self.preview_height as usize;\n    let scroll_ratio = self.preview_scroll as f32 / (total - visible) as f32;\n    \n    let bar_height = ((visible as f32 / total as f32) * area.height as f32).max(1.0) as u16;\n    let bar_y = (scroll_ratio * (area.height - bar_height) as f32) as u16;\n    \n    for y in bar_y..(bar_y + bar_height) {\n        buf.set_string(area.x + area.width - 1, area.y + y, \"█\", Style::default().fg(Color::DarkGray));\n    }\n}\n```\n\n### Help Text for Preview Mode\n```rust\nfn render_help(\u0026self) -\u003e String {\n    match self.focus {\n        Focus::List =\u003e \"/: search | Tab: preview | Enter: paste | d: delete | q: quit\",\n        Focus::Preview =\u003e \"j/k: scroll | PgUp/PgDn: page | g/G: top/bottom | Tab/Esc: back\",\n    }\n}\n```\n\n## Key Design Decisions\n- [PREVIEW] in title clearly indicates mode\n- Line number indicator shows position in content\n- Scrollbar provides visual scroll position\n- Help text contextually shows available keys\n\n## Files to Modify\n- src/picker.rs: Update render_* methods for preview mode\n\n## Acceptance Criteria\n- [ ] Title shows [PREVIEW] indicator in preview mode\n- [ ] Preview shows scrolled window of content\n- [ ] Line position indicator shows current/total lines\n- [ ] Scrollbar appears when content exceeds height\n- [ ] Help text shows preview-mode keybindings","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:43:55.919869587-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:43:55.919869587-05:00","dependencies":[{"issue_id":"clipboard-pve.22","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:43:55.921783363-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.22","depends_on_id":"clipboard-pve.21","type":"blocks","created_at":"2026-01-13T15:44:53.345327814-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.23","title":"Unit tests for preview scrolling","description":"## Overview\nComprehensive unit test suite for the preview scrolling and focus mode functionality.\n\n## Test Cases\n\n### Focus Mode Tests\n```rust\n#[test]\nfn test_focus_enum_default() {\n    let state = PickerState::default();\n    assert_eq\\!(state.focus, Focus::List);\n}\n\n#[test]\nfn test_tab_toggles_focus() {\n    let mut state = PickerState::default();\n    // Initial state\n    assert_eq\\!(state.focus, Focus::List);\n    \n    // Toggle to Preview\n    state.handle_key(KeyCode::Tab);\n    assert_eq\\!(state.focus, Focus::Preview);\n    \n    // Toggle back to List\n    state.handle_key(KeyCode::Tab);\n    assert_eq\\!(state.focus, Focus::List);\n}\n```\n\n### Content Loading Tests\n```rust\n#[test]\nfn test_preview_content_loaded_on_focus_change() {\n    let (storage, _dir) = test_storage();\n    storage.save_entry(\"line1\\nline2\\nline3\").unwrap();\n    \n    let mut state = PickerState::new(\u0026storage).unwrap();\n    assert\\!(state.preview_lines.is_empty());\n    \n    state.handle_key(KeyCode::Tab);  // Enter preview\n    assert\\!(\\!state.preview_lines.is_empty());\n    assert_eq\\!(state.preview_lines.len(), 3);\n}\n\n#[test]\nfn test_preview_cache_cleared_on_selection_change() {\n    // Setup with multiple entries\n    // Load preview for first entry\n    // Change selection\n    // Verify preview_lines is empty\n}\n```\n\n### Scroll Navigation Tests\n```rust\n#[test]\nfn test_scroll_down() {\n    let mut state = setup_preview_state(100);  // 100 lines\n    state.preview_height = 10;\n    \n    state.handle_key(KeyCode::Down);\n    assert_eq\\!(state.preview_scroll, 1);\n}\n\n#[test]\nfn test_scroll_up_at_top() {\n    let mut state = setup_preview_state(100);\n    state.preview_scroll = 0;\n    \n    state.handle_key(KeyCode::Up);\n    assert_eq\\!(state.preview_scroll, 0);  // No change, already at top\n}\n\n#[test]\nfn test_scroll_down_at_bottom() {\n    let mut state = setup_preview_state(100);\n    state.preview_height = 10;\n    state.preview_scroll = 90;  // max_scroll = 100 - 10 = 90\n    \n    state.handle_key(KeyCode::Down);\n    assert_eq\\!(state.preview_scroll, 90);  // No change, already at bottom\n}\n\n#[test]\nfn test_page_down_scrolls_by_page() {\n    let mut state = setup_preview_state(100);\n    state.preview_height = 10;\n    \n    state.handle_key(KeyCode::PageDown);\n    assert_eq\\!(state.preview_scroll, 10);\n}\n\n#[test]\nfn test_jump_to_end() {\n    let mut state = setup_preview_state(100);\n    state.preview_height = 10;\n    \n    state.handle_key(KeyCode::End);  // or G\n    assert_eq\\!(state.preview_scroll, 90);\n}\n\n#[test]\nfn test_jump_to_top() {\n    let mut state = setup_preview_state(100);\n    state.preview_scroll = 50;\n    \n    state.handle_key(KeyCode::Home);  // or g\n    assert_eq\\!(state.preview_scroll, 0);\n}\n```\n\n### Line Wrapping Tests\n```rust\n#[test]\nfn test_long_lines_wrapped() {\n    let (storage, _dir) = test_storage();\n    let long_line = \"x\".repeat(200);  // Exceeds wrap width\n    storage.save_entry(\u0026long_line).unwrap();\n    \n    let mut state = PickerState::new(\u0026storage).unwrap();\n    state.handle_key(KeyCode::Tab);\n    \n    assert\\!(state.preview_lines.len() \u003e 1);  // Line was wrapped\n}\n\n#[test]\nfn test_multiline_content_preserved() {\n    let (storage, _dir) = test_storage();\n    storage.save_entry(\"line1\\nline2\\nline3\").unwrap();\n    \n    let mut state = PickerState::new(\u0026storage).unwrap();\n    state.handle_key(KeyCode::Tab);\n    \n    assert\\!(state.preview_lines.iter().any(|l| l.contains(\"line1\")));\n    assert\\!(state.preview_lines.iter().any(|l| l.contains(\"line2\")));\n    assert\\!(state.preview_lines.iter().any(|l| l.contains(\"line3\")));\n}\n```\n\n## Test Utilities\n```rust\nfn setup_preview_state(num_lines: usize) -\u003e PickerState {\n    let mut state = PickerState::default();\n    state.focus = Focus::Preview;\n    state.preview_lines = (0..num_lines).map(|i| format\\!(\"Line {}\", i)).collect();\n    state\n}\n```\n\n## Files to Modify\n- src/picker.rs: Add tests in #[cfg(test)] mod tests\n\n## Acceptance Criteria\n- [ ] All focus mode tests pass\n- [ ] All content loading tests pass\n- [ ] All scroll navigation tests pass\n- [ ] All line wrapping tests pass\n- [ ] Tests cover boundary conditions (top, bottom, empty)","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:44:17.015413899-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:44:17.015413899-05:00","dependencies":[{"issue_id":"clipboard-pve.23","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:44:17.017307887-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.23","depends_on_id":"clipboard-pve.19","type":"blocks","created_at":"2026-01-13T15:44:53.385829201-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.24","title":"E2E tests for preview scrolling","description":"## Overview\nEnd-to-end test script for preview scrolling functionality, validating data layer support for full content viewing.\n\n## Test Script: tests/e2e_preview.sh\n\n```bash\n#!/bin/bash\nset -e\n\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" \u0026\u0026 pwd)\"\nPROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"\nBINARY=\"$PROJECT_ROOT/target/release/clipstack\"\nTEST_DIR=$(mktemp -d)\ntrap \"rm -rf $TEST_DIR\" EXIT\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\npass() { echo -e \"${GREEN}✓ PASS${NC}: $1\"; }\nfail() { echo -e \"${RED}✗ FAIL${NC}: $1\"; exit 1; }\ninfo() { echo -e \"${YELLOW}INFO${NC}: $1\"; }\n\n# Build release binary\ninfo \"Building release binary...\"\ncargo build --release --manifest-path=\"$PROJECT_ROOT/Cargo.toml\"\n\n# Test 1: Store and retrieve multi-line content\ninfo \"Test 1: Multi-line content storage and retrieval\"\nMULTILINE_CONTENT=$(cat \u003c\u003c'CONTENT'\nLine 1: First line of content\nLine 2: Second line with more text\nLine 3: Third line\nLine 4: Fourth line\nLine 5: Fifth line - this should all be stored\nCONTENT\n)\necho \"$MULTILINE_CONTENT\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\n# Retrieve content and verify all lines present\nENTRY_ID=$(jq -r '.entries[0].id' \"$TEST_DIR/index.json\")\nCONTENT_FILE=\"$TEST_DIR/${ENTRY_ID}.txt\"\n\nif [ -f \"$CONTENT_FILE\" ]; then\n    pass \"Content file created\"\nelse\n    fail \"Content file not created: $CONTENT_FILE\"\nfi\n\nLINE_COUNT=$(wc -l \u003c \"$CONTENT_FILE\")\nif [ \"$LINE_COUNT\" -ge 5 ]; then\n    pass \"All lines stored in content file ($LINE_COUNT lines)\"\nelse\n    fail \"Expected at least 5 lines, got $LINE_COUNT\"\nfi\n\n# Test 2: Long content preserved beyond preview\ninfo \"Test 2: Long content beyond preview length\"\n# Create 200 lines of content\nLONG_CONTENT=\"\"\nfor i in $(seq 1 200); do\n    LONG_CONTENT=\"${LONG_CONTENT}Line $i: This is line number $i with some padding text\\n\"\ndone\necho -e \"$LONG_CONTENT\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\nENTRY_ID=$(jq -r '.entries[0].id' \"$TEST_DIR/index.json\")\nCONTENT_FILE=\"$TEST_DIR/${ENTRY_ID}.txt\"\n\nSTORED_LINES=$(wc -l \u003c \"$CONTENT_FILE\")\nif [ \"$STORED_LINES\" -ge 200 ]; then\n    pass \"Long content fully stored ($STORED_LINES lines)\"\nelse\n    fail \"Long content truncated, expected 200+ lines, got $STORED_LINES\"\nfi\n\n# Verify preview is truncated but content is full\nPREVIEW_LEN=$(jq -r '.entries[0].preview | length' \"$TEST_DIR/index.json\")\nCONTENT_LEN=$(wc -c \u003c \"$CONTENT_FILE\")\nif [ \"$CONTENT_LEN\" -gt \"$PREVIEW_LEN\" ]; then\n    pass \"Full content ($CONTENT_LEN bytes) larger than preview ($PREVIEW_LEN chars)\"\nelse\n    fail \"Content should be larger than preview\"\nfi\n\n# Test 3: Unicode content in preview mode\ninfo \"Test 3: Unicode content handling\"\nUNICODE_CONTENT=\"Line 1: Hello 世界\nLine 2: Emojis 🎉🚀✨\nLine 3: Japanese テスト\nLine 4: Mixed content αβγδ\"\necho \"$UNICODE_CONTENT\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\nENTRY_ID=$(jq -r '.entries[0].id' \"$TEST_DIR/index.json\")\nCONTENT_FILE=\"$TEST_DIR/${ENTRY_ID}.txt\"\n\nif grep -q \"世界\" \"$CONTENT_FILE\" \u0026\u0026 grep -q \"🎉\" \"$CONTENT_FILE\"; then\n    pass \"Unicode content preserved correctly\"\nelse\n    fail \"Unicode content corrupted\"\nfi\n\n# Test 4: Binary-safe content (no null byte corruption)\ninfo \"Test 4: Content with special characters\"\nSPECIAL_CONTENT=\"Tab:\there\nBackslash: \\\\ here\nQuote: \\\"here\\\"\nSingle: 'here'\"\necho \"$SPECIAL_CONTENT\" | $BINARY --storage-dir=\"$TEST_DIR\" copy\n\nENTRY_ID=$(jq -r '.entries[0].id' \"$TEST_DIR/index.json\")\nCONTENT_FILE=\"$TEST_DIR/${ENTRY_ID}.txt\"\n\nif [ -s \"$CONTENT_FILE\" ]; then\n    pass \"Special characters handled without corruption\"\nelse\n    fail \"Content file empty or missing\"\nfi\n\necho \"\"\necho -e \"${GREEN}All preview E2E tests passed!${NC}\"\n```\n\n## Test Scenarios\n1. **Multi-line Storage**: Verify all lines stored and retrievable\n2. **Long Content**: 200+ lines fully preserved for scroll\n3. **Unicode**: Multi-language content not corrupted\n4. **Special Characters**: Tabs, quotes, backslashes preserved\n\n## Limitations\n- Cannot test interactive preview scrolling in automated tests\n- Tests verify data layer supports full content viewing\n\n## Files to Create\n- tests/e2e_preview.sh: E2E test script\n\n## Acceptance Criteria\n- [ ] Script is executable (chmod +x)\n- [ ] All test scenarios pass\n- [ ] Cleanup removes temp directory\n- [ ] Clear pass/fail output with colors\n- [ ] Script exits with non-zero on failure","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:44:45.978976243-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:44:45.978976243-05:00","dependencies":[{"issue_id":"clipboard-pve.24","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T15:44:45.981000105-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.24","depends_on_id":"clipboard-pve.23","type":"blocks","created_at":"2026-01-13T15:44:53.425684727-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-pve.3","title":"[#4] Add focus field to Picker","description":"Add focus: Focus field to Picker struct. Initialize with Focus::default() (List). Determines which pane responds to navigation keys.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:39:57.456480778-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.3","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:39:57.458290882-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.3","depends_on_id":"clipboard-pve.1","type":"blocks","created_at":"2026-01-13T12:40:38.912964591-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.4","title":"[#4] Implement scroll_preview() method","description":"fn scroll_preview(\u0026mut self, delta: i32). Adjusts preview_scroll by delta (+ = down, - = up). Clamps to valid range: 0 to total_lines-1. Handles empty content gracefully.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:39:59.598548565-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.4","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:39:59.600157052-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.4","depends_on_id":"clipboard-pve.2","type":"blocks","created_at":"2026-01-13T12:40:38.953922234-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.5","title":"[#4] Implement toggle_focus() method","description":"fn toggle_focus(\u0026mut self). Switches focus between Focus::List and Focus::Preview. Simple match expression.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:01.770873354-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.5","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:01.772576739-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.5","depends_on_id":"clipboard-pve.1","type":"blocks","created_at":"2026-01-13T12:40:38.994043414-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.6","title":"[#4] Update load_preview() to reset scroll on selection change","description":"CRITICAL: When preview_id changes (new selection), set preview_scroll = 0. User shouldn't see previous entry's scroll position when selecting new entry.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:04.17025974-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.6","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:04.171852318-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.6","depends_on_id":"clipboard-pve.2","type":"blocks","created_at":"2026-01-13T12:40:39.034767271-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.7","title":"[#4] Update render_preview() with scroll offset","description":"Apply preview_scroll when building visible lines: .skip(self.preview_scroll).take(visible_height). Content shifts based on scroll position.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:06.298968518-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.7","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:06.300513016-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.7","depends_on_id":"clipboard-pve.2","type":"blocks","created_at":"2026-01-13T12:40:39.076802419-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.8","title":"[#4] Add scroll position indicator in preview title","description":"Update preview title format: 'Preview - metadata [lines start-end/total]' when content exceeds visible height. Shows user where they are in document.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:08.46784661-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.8","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:08.469605678-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.8","depends_on_id":"clipboard-pve.7","type":"blocks","created_at":"2026-01-13T12:40:39.116930702-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-pve.9","title":"[#4] Add scroll indicators (arrows) in preview pane","description":"Render '▲' at top-right when can_scroll_up, '▼' at bottom-right when can_scroll_down. Color::Yellow. Provides visual affordance for scrolling.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:40:10.718937207-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:54.301590395-05:00","dependencies":[{"issue_id":"clipboard-pve.9","depends_on_id":"clipboard-pve","type":"parent-child","created_at":"2026-01-13T12:40:10.723919982-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-pve.9","depends_on_id":"clipboard-pve.7","type":"blocks","created_at":"2026-01-13T12:40:39.157889979-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:54.301590395-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd","title":"Improvement #5: Configurable Max Entries","description":"Enable user customization of history limit via CLI flag and env var. This MUST be implemented FIRST as it changes the Storage::new() signature that all other code depends on. The current hardcoded MAX_ENTRIES=100 doesn't serve all users: power users want 500+, privacy-conscious want fewer. Implementation adds --max-entries flag, CLIPSTACK_MAX_ENTRIES env var, clamping to 1-10000 range, and automatic pruning when limit is reduced.","status":"open","priority":1,"issue_type":"feature","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:28:52.595506805-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T12:28:52.595506805-05:00","dependencies":[{"issue_id":"clipboard-tsd","depends_on_id":"clipboard-0nf","type":"parent-child","created_at":"2026-01-13T12:30:09.278506803-05:00","created_by":"solsystemlabs"}],"comments":[{"id":2,"issue_id":"clipboard-tsd","author":"solsystemlabs","text":"# Improvement #5: Configurable Max Entries - Detailed Documentation\n\n## Problem Statement\n\nThe maximum number of stored entries is hardcoded:\n\n```rust\n// storage.rs:8\nconst MAX_ENTRIES: usize = 100;\n```\n\nThis one-size-fits-all default doesn't serve all users:\n- **Power users** may want 500+ entries for deep history across projects\n- **Privacy-conscious users** may want only 10-20 entries\n- **Resource-constrained systems** may need limits to control storage size\n\nCurrently, adjusting this requires modifying source code and recompiling - unacceptable UX.\n\n## Why This Must Be Done First\n\nThis improvement changes the `Storage::new()` signature from:\n```rust\npub fn new(base_dir: PathBuf) -\u003e Result\u003cSelf\u003e\n```\nTo:\n```rust\npub fn new(base_dir: PathBuf, max_entries: usize) -\u003e Result\u003cSelf\u003e\n```\n\nALL call sites must be updated, which affects:\n- main.rs (multiple places)\n- daemon.rs (Daemon::new)\n- picker.rs (tests)\n- storage.rs (tests)\n\nDoing this first prevents merge conflicts and signature mismatches in later improvements.\n\n## Solution Design\n\nConfiguration priority (highest to lowest):\n1. **CLI flag**: `--max-entries N`\n2. **Environment variable**: `CLIPSTACK_MAX_ENTRIES`\n3. **Stored preference**: In index.json (for persistence)\n4. **Default**: 100\n\n## Implementation Requirements\n\n### 1. Storage Struct Changes\n```rust\npub struct Storage {\n    base_dir: PathBuf,\n    max_entries: usize,  // NEW FIELD\n}\n```\n\n### 2. Constants\n```rust\nconst DEFAULT_MAX_ENTRIES: usize = 100;\nconst ABSOLUTE_MAX_ENTRIES: usize = 10000;  // Safety limit\n```\n\n### 3. CLI Flag (clap)\n```rust\n#[arg(long, global = true, value_parser = clap::value_parser!(u32).range(1..=10000))]\nmax_entries: Option\u003cu32\u003e,\n```\n\n### 4. Env Var Support\n```rust\nlet max_entries = cli.max_entries\n    .map(|n| n as usize)\n    .or_else(|| std::env::var(\"CLIPSTACK_MAX_ENTRIES\").ok().and_then(|s| s.parse().ok()))\n    .unwrap_or(100);\n```\n\n### 5. Automatic Pruning\nWhen max_entries is reduced below current entry count, prune oldest unpinned entries immediately.\n\n### 6. Daemon Integration\nDaemon::new() must also accept max_entries parameter.\n\n## Testing Requirements (TDD)\n\n1. `test_custom_max_entries()` - Verify limit is respected\n2. `test_max_entries_clamps_to_range()` - Verify 0 becomes 1, 999999 becomes 10000\n3. `test_reducing_max_entries_prunes_immediately()` - Verify old entries removed\n4. `test_pinned_entries_respect_separate_limit()` - Pinned don't count against max\n\n## Success Criteria\n\n- [ ] `--max-entries N` CLI flag works\n- [ ] `CLIPSTACK_MAX_ENTRIES` environment variable works\n- [ ] Values clamped to 1-10000 range\n- [ ] Reducing max_entries prunes old entries immediately\n- [ ] `stats` command shows current limit\n- [ ] Existing storage remains compatible\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| src/storage.rs | Add max_entries field, update new(), add sync_max_entries() |\n| src/main.rs | Add --max-entries flag, env var parsing, update all Storage::new() calls |\n| src/daemon.rs | Update Daemon::new() to accept max_entries |\n| src/picker.rs | Update test fixtures |\n\n## Dependencies\n\n- **None** - This is a foundation task that must be done first\n- **Blocked by this**: All other improvements (#3, #2, #1, #4)\n","created_at":"2026-01-13T17:29:41Z"}]}
{"id":"clipboard-tsd.1","title":"[#5] Cache max_entries in Storage for CLI/env override","description":"Add max_entries field to Storage struct to cache the configured limit from CLI/env. Note: ClipIndex already has max_entries for persistence - this Storage field is for the runtime override. When Storage is created with a non-default limit, it should use that instead of the index value. This enables daemon and picker to respect CLI flags and env vars.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:35.520311628-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.1","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:35.521735429-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.10","title":"[#5] Add Storage::max_entries() getter method","description":"Add pub fn max_entries(\u0026self) -\u003e usize { self.max_entries }. This allows stats/status commands to display the configured limit without accessing private fields.","status":"tombstone","priority":3,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:53.332678334-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.10","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:53.334406944-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.10","depends_on_id":"clipboard-tsd.1","type":"blocks","created_at":"2026-01-13T12:31:15.30360382-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.11","title":"[#5] Update Stats command to show configured max","description":"Update stats output to show: Entries: {}/{}. First number is current count, second is max_entries. Gives users visibility into how close they are to the limit.","status":"tombstone","priority":3,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:53.80954318-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.11","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:53.811395752-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.12","title":"[#5] Update Status command to show configuration source","description":"Add Configuration section showing max_entries and whether it came from CLI, env var, or default. Helps users understand and debug their configuration.","status":"tombstone","priority":3,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:54.097294604-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.12","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:54.098794096-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.13","title":"[#5] Update test fixtures to use new Storage::new() signature","description":"All tests using test_storage() helper or direct Storage::new() calls must be updated. Use DEFAULT_MAX_ENTRIES or a custom value as appropriate for each test.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:54.391610034-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.13","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:54.392996234-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.13","depends_on_id":"clipboard-tsd.3","type":"blocks","created_at":"2026-01-13T12:31:15.337444903-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.14","title":"[#5] Write unit tests for configurable max entries","description":"Write tests: test_custom_max_entries(), test_max_entries_clamps_to_range() (0→1, 999999→10000), test_reducing_max_entries_prunes_immediately(), test_pinned_entries_respect_separate_limit(). See IMPLEMENTATION_SPEC.md for code.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:54.706420378-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.14","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:54.708035766-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.14","depends_on_id":"clipboard-tsd.13","type":"blocks","created_at":"2026-01-13T12:31:15.372187341-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.15","title":"[#5] Write E2E test script for configurable max entries","description":"Create comprehensive E2E test script (tests/e2e/test_configurable_max.sh) that verifies configurable max entries via CLI. Tests:\n1. Default limit works (100 entries) - add 101 entries, verify oldest pruned\n2. --max-entries flag respected for daemon/pick/stats commands\n3. CLIPSTACK_MAX_ENTRIES env var works (test precedence: CLI \u003e env \u003e default)\n4. Reducing limit prunes old entries immediately (set 50, verify only 50 remain)\n5. Increasing limit allows more entries (set 200, verify 200 can be stored)\n6. Invalid values clamped to 1-10000 range (test 0, -1, 99999)\n\nLOGGING REQUIREMENTS:\n- Use colored output: GREEN=pass, RED=fail, YELLOW=info\n- Each test prints: [TEST N] Description... followed by result\n- Show expected vs actual values on failure\n- Print summary at end: \"X/Y tests passed\"\n- Exit code: 0 if all pass, 1 if any fail\n\nCLEANUP: Create temp dir per test, remove after each test\n\nExample output format:\n[TEST 1] Default limit (100 entries)...\n  Creating 101 test entries...\n  Verifying pruning...\n  Expected: 100 entries, Got: 100 entries\n  ✓ PASS\n\n[TEST 2] CLI flag --max-entries=50...\n  ...","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T13:29:39.084963011-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.15","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T13:29:39.086863876-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.15","depends_on_id":"clipboard-tsd.14","type":"blocks","created_at":"2026-01-13T13:30:09.12170531-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.16","title":"[#5] Add max_entries infrastructure (constants + Storage field)","description":"## Overview\nAdd the foundational constants and struct field needed for configurable max entries.\n\n## Code Changes in src/storage.rs\n\n### Add Constants (after existing consts)\n```rust\nconst DEFAULT_MAX_ENTRIES: usize = 100;\nconst ABSOLUTE_MAX_ENTRIES: usize = 10000;  // Safety limit\n```\n\n### Add Field to Storage Struct\n```rust\npub struct Storage {\n    base_dir: PathBuf,\n    max_entries: usize,  // NEW: cached limit for CLI/env override\n}\n```\n\n## Rationale\n- DEFAULT_MAX_ENTRIES maintains backwards compatibility (100 was the old hardcoded value)\n- ABSOLUTE_MAX_ENTRIES prevents users from accidentally setting unreasonably high values that would degrade performance\n- Caching max_entries in Storage enables runtime override via CLI/env without modifying stored index\n\n## Files Changed\n- src/storage.rs: Add 2 constants, add 1 struct field\n\n## Acceptance Criteria\n- [ ] Constants defined with correct values\n- [ ] Storage struct has max_entries field\n- [ ] Code compiles (field initialization comes in next bead)","status":"open","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:12:24.149762803-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:12:24.149762803-05:00","dependencies":[{"issue_id":"clipboard-tsd.16","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:12:24.151526382-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.17","title":"[#5] Update Storage::new() signature with max_entries parameter","description":"## Overview\nChange Storage::new() to accept max_entries parameter. This is the CRITICAL change that affects all call sites.\n\n## Code Changes in src/storage.rs\n\n### Update Storage::new()\n```rust\nimpl Storage {\n    /// Create storage with specified max entries\n    pub fn new(base_dir: PathBuf, max_entries: usize) -\u003e Result\u003cSelf\u003e {\n        fs::create_dir_all(\u0026base_dir)\n            .with_context(|| format!(\"Failed to create storage dir: {:?}\", base_dir))?;\n        \n        // Clamp to valid range\n        let max_entries = max_entries.clamp(1, ABSOLUTE_MAX_ENTRIES);\n        \n        let storage = Self { base_dir, max_entries };\n        \n        // Sync to stored index (prunes if needed)\n        storage.sync_max_entries()?;\n        \n        Ok(storage)\n    }\n    \n    /// Get the configured max entries\n    pub fn max_entries(\u0026self) -\u003e usize {\n        self.max_entries\n    }\n    \n    /// Sync max_entries to stored index and prune if necessary\n    fn sync_max_entries(\u0026self) -\u003e Result\u003c()\u003e {\n        let mut index = self.load_index()?;\n        \n        if index.max_entries != self.max_entries {\n            index.max_entries = self.max_entries;\n            // Prune will be implemented in pinned feature; for now just update\n            self.save_index(\u0026index)?;\n        }\n        \n        Ok(())\n    }\n    \n    /// Convenience constructor with default max_entries\n    pub fn with_defaults(base_dir: PathBuf) -\u003e Result\u003cSelf\u003e {\n        Self::new(base_dir, DEFAULT_MAX_ENTRIES)\n    }\n}\n```\n\n## Why This Is Critical\nALL code that creates Storage must be updated:\n- main.rs: Multiple Storage::new() calls\n- daemon.rs: Daemon::new() creates Storage\n- picker.rs tests: Test fixtures create Storage\n\n## Acceptance Criteria\n- [ ] Storage::new() accepts max_entries parameter\n- [ ] Values clamped to 1-10000 range\n- [ ] max_entries() getter works\n- [ ] with_defaults() convenience constructor added\n- [ ] NOTE: Call sites will break until updated","status":"open","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:12:31.715254948-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:12:31.715254948-05:00","dependencies":[{"issue_id":"clipboard-tsd.17","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:12:31.718609412-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.17","depends_on_id":"clipboard-tsd.16","type":"blocks","created_at":"2026-01-13T15:23:44.193873356-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.18","title":"[#5] Update all Storage::new() call sites (main.rs, daemon.rs)","description":"## Overview\nUpdate every location that creates Storage to use the new signature with max_entries.\n\n## Code Changes\n\n### src/main.rs - Determine max_entries from CLI/env\n```rust\nfn main() -\u003e Result\u003c()\u003e {\n    let cli = Cli::parse();\n    \n    // Determine max_entries: CLI \u003e env \u003e default (100)\n    let max_entries = cli\n        .max_entries\n        .map(|n| n as usize)\n        .or_else(|| {\n            std::env::var(\"CLIPSTACK_MAX_ENTRIES\")\n                .ok()\n                .and_then(|s| s.parse().ok())\n        })\n        .unwrap_or(100)\n        .clamp(1, 10000);\n    \n    // ... later ...\n    let storage = storage::Storage::new(storage_dir, max_entries)?;\n    // ...\n}\n```\n\n### src/main.rs - Update Daemon command\n```rust\nSome(Commands::Daemon) =\u003e {\n    let daemon = daemon::Daemon::new(\n        Some(storage.base_dir().to_path_buf()),\n        max_entries\n    )?;\n    // ...\n}\n```\n\n### src/daemon.rs - Update Daemon::new()\n```rust\nimpl Daemon {\n    pub fn new(storage_dir: Option\u003cPathBuf\u003e, max_entries: usize) -\u003e Result\u003cSelf\u003e {\n        Self::new_with_lock(storage_dir, max_entries, false)\n    }\n    \n    pub fn new_with_lock(\n        storage_dir: Option\u003cPathBuf\u003e,\n        max_entries: usize,\n        use_local_lock: bool,\n    ) -\u003e Result\u003cSelf\u003e {\n        let base_dir = storage_dir.unwrap_or_else(Storage::default_dir);\n        let storage = Storage::new(base_dir.clone(), max_entries)?;\n        // ...\n    }\n}\n```\n\n## Files Changed\n- src/main.rs: Add max_entries CLI/env parsing, update all Storage::new() calls, update Daemon call\n- src/daemon.rs: Update Daemon::new() and new_with_lock() signatures\n\n## Acceptance Criteria\n- [ ] All Storage::new() calls pass max_entries\n- [ ] Daemon::new() accepts and forwards max_entries\n- [ ] CLI flag --max-entries NOT YET ADDED (separate bead)\n- [ ] Code compiles and runs with defaults","status":"open","priority":1,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:13:45.541870541-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:13:45.541870541-05:00","dependencies":[{"issue_id":"clipboard-tsd.18","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:13:45.543737943-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.18","depends_on_id":"clipboard-tsd.17","type":"blocks","created_at":"2026-01-13T15:23:44.229808375-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.19","title":"[#5] Add --max-entries CLI flag and CLIPSTACK_MAX_ENTRIES env var","description":"## Overview\nAdd the user-facing configuration options: CLI flag and environment variable.\n\n## Code Changes in src/main.rs\n\n### Add CLI Flag to Struct\n```rust\n#[derive(Parser)]\n#[command(name = \"clipstack\")]\n#[command(about = \"Fast clipboard manager with lazy-loading history\")]\n#[command(version)]\nstruct Cli {\n    /// Custom storage directory\n    #[arg(long, global = true)]\n    storage_dir: Option\u003cPathBuf\u003e,\n    \n    /// Maximum entries to store (1-10000, default: 100)\n    /// Can also be set via CLIPSTACK_MAX_ENTRIES environment variable\n    #[arg(long, global = true, value_parser = clap::value_parser!(u32).range(1..=10000))]\n    max_entries: Option\u003cu32\u003e,\n    \n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n}\n```\n\n## Environment Variable\nThe env var is already parsed in the call sites bead. This bead ensures:\n- Help text documents the env var\n- CLI flag takes precedence over env var\n- Both are validated to 1-10000 range\n\n## Configuration Priority (documented in help)\n1. --max-entries N (CLI flag, highest priority)\n2. CLIPSTACK_MAX_ENTRIES (environment variable)\n3. 100 (default)\n\n## Acceptance Criteria\n- [ ] --max-entries flag works: clipstack --max-entries 500 stats\n- [ ] Env var works: CLIPSTACK_MAX_ENTRIES=500 clipstack stats\n- [ ] CLI overrides env: CLIPSTACK_MAX_ENTRIES=100 clipstack --max-entries 200 stats (uses 200)\n- [ ] Help text shows both options","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:13:48.633518462-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:13:48.633518462-05:00","dependencies":[{"issue_id":"clipboard-tsd.19","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:13:48.635304442-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.19","depends_on_id":"clipboard-tsd.18","type":"blocks","created_at":"2026-01-13T15:23:44.265098619-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.2","title":"[#5] Define constants DEFAULT_MAX_ENTRIES and ABSOLUTE_MAX_ENTRIES","description":"Add const DEFAULT_MAX_ENTRIES: usize = 100 and const ABSOLUTE_MAX_ENTRIES: usize = 10000 to storage.rs. The absolute max is a safety limit to prevent users from accidentally setting an unreasonably high value.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:35.82310521-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.2","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:35.824715148-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.20","title":"[#5] Update Stats and Status commands to show max_entries info","description":"## Overview\nShow configuration information in stats and status commands so users can verify their settings.\n\n## Code Changes in src/main.rs\n\n### Update Stats Command\n```rust\nSome(Commands::Stats) =\u003e {\n    let index = storage.load_index()?;\n    let total_size: usize = index.entries.iter().map(|e| e.size).sum();\n    let pinned_count = index.entries.iter().filter(|e| e.pinned).count();\n    let unpinned_count = index.entries.len() - pinned_count;\n    \n    println!(\"Entries:    {}\", index.entries.len());\n    println!(\"  Pinned:   {} (protected)\", pinned_count);\n    println!(\"  Regular:  {}/{}\", unpinned_count, storage.max_entries());\n    println!(\"Total size: {}\", util::format_size(total_size));\n    \n    if let Some(oldest) = index.entries.last() {\n        println!(\"Oldest:     {}\", util::format_relative_time(oldest.timestamp));\n    }\n    if let Some(newest) = index.entries.first() {\n        println!(\"Newest:     {}\", util::format_relative_time(newest.timestamp));\n    }\n}\n```\n\n### Update Status Command\n```rust\nSome(Commands::Status) =\u003e {\n    print_status(\u0026storage)?;\n    \n    println!();\n    println!(\"Configuration:\");\n    println!(\"  Max entries: {}\", storage.max_entries());\n    \n    if std::env::var(\"CLIPSTACK_MAX_ENTRIES\").is_ok() {\n        println!(\"  (from CLIPSTACK_MAX_ENTRIES env var)\");\n    }\n}\n```\n\n## Files Changed\n- src/main.rs: Update Stats and Status command handlers\n\n## Acceptance Criteria\n- [ ] stats shows Regular: X/Y where Y is max_entries\n- [ ] status shows Configuration section with max entries\n- [ ] status indicates source (env var) when applicable","status":"open","priority":3,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:14:10.673120121-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:14:10.673120121-05:00","dependencies":[{"issue_id":"clipboard-tsd.20","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:14:10.67486761-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.20","depends_on_id":"clipboard-tsd.18","type":"blocks","created_at":"2026-01-13T15:23:44.300711452-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.21","title":"[#5] Write comprehensive unit tests for configurable max entries","description":"## Overview\nTDD: Write comprehensive unit tests that verify all max_entries functionality.\n\n## Test Cases (copy-paste ready)\n\n```rust\n#[cfg(test)]\nmod max_entries_tests {\n    use super::*;\n    use tempfile::TempDir;\n    \n    #[test]\n    fn test_custom_max_entries() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 5).unwrap();\n        \n        // Fill beyond limit\n        for i in 0..10 {\n            storage.save_entry(\u0026format!(\"entry {}\", i)).unwrap();\n        }\n        \n        let index = storage.load_index().unwrap();\n        assert_eq!(index.entries.len(), 5);\n        assert_eq!(index.max_entries, 5);\n    }\n    \n    #[test]\n    fn test_max_entries_clamps_low() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 0).unwrap();\n        assert_eq!(storage.max_entries(), 1);\n    }\n    \n    #[test]\n    fn test_max_entries_clamps_high() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 999999).unwrap();\n        assert_eq!(storage.max_entries(), 10000);\n    }\n    \n    #[test]\n    fn test_reducing_max_entries_prunes_immediately() {\n        let dir = TempDir::new().unwrap();\n        \n        // Create with high limit\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        for i in 0..50 {\n            storage.save_entry(\u0026format!(\"entry {}\", i)).unwrap();\n        }\n        \n        // Recreate with lower limit - should prune\n        let storage = Storage::new(dir.path().to_path_buf(), 10).unwrap();\n        let index = storage.load_index().unwrap();\n        \n        assert_eq!(index.entries.len(), 10);\n    }\n    \n    #[test]\n    fn test_max_entries_getter() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 42).unwrap();\n        assert_eq!(storage.max_entries(), 42);\n    }\n    \n    #[test]\n    fn test_with_defaults_uses_100() {\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::with_defaults(dir.path().to_path_buf()).unwrap();\n        assert_eq!(storage.max_entries(), 100);\n    }\n    \n    #[test]\n    fn test_update_test_fixtures() {\n        // All test fixtures in picker.rs and elsewhere should compile\n        // with new Storage::new(path, max_entries) signature\n        let dir = TempDir::new().unwrap();\n        let storage = Storage::new(dir.path().to_path_buf(), 100).unwrap();\n        let _picker = Picker::new(storage).unwrap();\n    }\n}\n```\n\n## Files Changed\n- src/storage.rs: Add test module or update existing\n\n## Acceptance Criteria\n- [ ] All 7 tests pass\n- [ ] Tests run: cargo test max_entries\n- [ ] No test failures block the build","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:14:43.929130523-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:14:43.929130523-05:00","dependencies":[{"issue_id":"clipboard-tsd.21","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:14:43.930916584-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.21","depends_on_id":"clipboard-tsd.17","type":"blocks","created_at":"2026-01-13T15:23:44.335948536-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.22","title":"[#5] Write E2E test script for configurable max entries","description":"## Overview\nCreate an end-to-end test script that verifies the configurable max entries feature works correctly in practice.\n\n## E2E Test Script (tests/e2e_max_entries.sh)\n\n```bash\n#!/bin/bash\nset -euo pipefail\n\n# E2E Tests for Configurable Max Entries\n# Run from project root: ./tests/e2e_max_entries.sh\n\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m'\n\nTEST_DIR=$(mktemp -d)\nCLIPSTACK=\"./target/release/clipstack\"\n\nlog_pass() { echo -e \"${GREEN}✓${NC} $1\"; }\nlog_fail() { echo -e \"${RED}✗${NC} $1\"; exit 1; }\nlog_info() { echo -e \"${YELLOW}→${NC} $1\"; }\n\ncleanup() { rm -rf \"$TEST_DIR\"; }\ntrap cleanup EXIT\n\n# Build release if needed\nif [[ ! -f \"$CLIPSTACK\" ]]; then\n    log_info \"Building release binary...\"\n    cargo build --release\nfi\n\nlog_info \"Test directory: $TEST_DIR\"\n\n# Test 1: Default max_entries is 100\nlog_info \"Test 1: Default max_entries\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test1\" stats 2\u003e/dev/null || true\n$CLIPSTACK --storage-dir \"$TEST_DIR/test1\" status | grep -q \"Max entries: 100\" \u0026\u0026 \\\n    log_pass \"Default is 100\" || log_fail \"Default should be 100\"\n\n# Test 2: CLI flag overrides default\nlog_info \"Test 2: CLI flag\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test2\" --max-entries 50 stats \u003e/dev/null\n$CLIPSTACK --storage-dir \"$TEST_DIR/test2\" --max-entries 50 status | grep -q \"Max entries: 50\" \u0026\u0026 \\\n    log_pass \"CLI flag works\" || log_fail \"CLI flag should set max_entries\"\n\n# Test 3: Environment variable works\nlog_info \"Test 3: Environment variable\"\nCLIPSTACK_MAX_ENTRIES=75 $CLIPSTACK --storage-dir \"$TEST_DIR/test3\" stats \u003e/dev/null\nCLIPSTACK_MAX_ENTRIES=75 $CLIPSTACK --storage-dir \"$TEST_DIR/test3\" status | grep -q \"Max entries: 75\" \u0026\u0026 \\\n    log_pass \"Env var works\" || log_fail \"Env var should set max_entries\"\n\n# Test 4: CLI takes precedence over env var\nlog_info \"Test 4: CLI precedence\"\nCLIPSTACK_MAX_ENTRIES=100 $CLIPSTACK --storage-dir \"$TEST_DIR/test4\" --max-entries 200 status | \\\n    grep -q \"Max entries: 200\" \u0026\u0026 \\\n    log_pass \"CLI overrides env\" || log_fail \"CLI should override env var\"\n\n# Test 5: Entries are pruned when limit exceeded\nlog_info \"Test 5: Pruning works\"\nfor i in {1..20}; do\n    echo \"entry $i\" | $CLIPSTACK --storage-dir \"$TEST_DIR/test5\" --max-entries 10 copy\ndone\nCOUNT=$($CLIPSTACK --storage-dir \"$TEST_DIR/test5\" --max-entries 10 list 2\u003e/dev/null | wc -l)\n[[ \"$COUNT\" -le 12 ]] \u0026\u0026 log_pass \"Pruning works ($COUNT entries)\" || \\\n    log_fail \"Should have ~10 entries, got $COUNT\"\n\n# Test 6: Value clamping\nlog_info \"Test 6: Value clamping\"\n$CLIPSTACK --storage-dir \"$TEST_DIR/test6\" --max-entries 0 status 2\u003e\u00261 | \\\n    grep -qE \"(Max entries: 1|invalid)\" \u0026\u0026 \\\n    log_pass \"Low values clamped/rejected\" || log_fail \"Should clamp 0 to 1\"\n\necho \"\"\necho -e \"${GREEN}All E2E tests passed!${NC}\"\n```\n\n## Logging Requirements\n- Each test logs what it's testing\n- Pass/fail shown with colored output\n- Temp directory auto-cleaned\n\n## Acceptance Criteria\n- [ ] Script created at tests/e2e_max_entries.sh\n- [ ] Script is executable (chmod +x)\n- [ ] All 6 tests pass on clean install\n- [ ] Script cleans up after itself","status":"open","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T15:23:33.498837729-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:23:33.498837729-05:00","dependencies":[{"issue_id":"clipboard-tsd.22","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T15:23:33.50059574-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.22","depends_on_id":"clipboard-tsd.21","type":"blocks","created_at":"2026-01-13T15:23:44.371888785-05:00","created_by":"solsystemlabs"}]}
{"id":"clipboard-tsd.3","title":"[#5] Update Storage::new() signature to accept max_entries parameter","description":"Change signature from new(base_dir: PathBuf) -\u003e Result\u003cSelf\u003e to new(base_dir: PathBuf, max_entries: usize) -\u003e Result\u003cSelf\u003e. Add clamping logic: max_entries.clamp(1, ABSOLUTE_MAX_ENTRIES). This is the core signature change that affects all call sites.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:36.126611003-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.3","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:36.128025105-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.3","depends_on_id":"clipboard-tsd.1","type":"blocks","created_at":"2026-01-13T12:31:15.09821814-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.3","depends_on_id":"clipboard-tsd.2","type":"blocks","created_at":"2026-01-13T12:31:15.134525161-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.4","title":"[#5] Add Storage::with_defaults() convenience constructor","description":"Add a convenience method that uses DEFAULT_MAX_ENTRIES: pub fn with_defaults(base_dir: PathBuf) -\u003e Result\u003cSelf\u003e { Self::new(base_dir, DEFAULT_MAX_ENTRIES) }. This simplifies call sites that don't need custom limits.","status":"tombstone","priority":3,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:36.441947271-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.4","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:36.443586103-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.4","depends_on_id":"clipboard-tsd.3","type":"blocks","created_at":"2026-01-13T12:31:15.168006622-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.5","title":"[#5] Implement sync_max_entries() for immediate pruning on reduction","description":"Add method to check if current entry count exceeds new max_entries and prune oldest unpinned entries immediately. Call this in Storage::new() after loading index. This ensures reducing max_entries has immediate effect.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:36.771090496-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.5","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:36.772672011-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.5","depends_on_id":"clipboard-tsd.3","type":"blocks","created_at":"2026-01-13T12:31:15.200479709-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.6","title":"[#5] Add --max-entries CLI flag with clap","description":"Add to Cli struct: #[arg(long, global = true, value_parser = clap::value_parser!(u32).range(1..=10000))] max_entries: Option\u003cu32\u003e. The global=true makes it available for all subcommands. Value parser handles range validation.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:37.072965342-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.6","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:37.074544253-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.7","title":"[#5] Add CLIPSTACK_MAX_ENTRIES env var support","description":"In main(), parse env var as fallback when CLI flag not provided: cli.max_entries.or_else(|| std::env::var(\"CLIPSTACK_MAX_ENTRIES\").ok().and_then(|s| s.parse().ok())).unwrap_or(100). Priority: CLI \u003e env var \u003e default.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:37.381081541-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.7","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:37.382757142-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.8","title":"[#5] Update all Storage::new() call sites in main.rs","description":"Find all Storage::new() calls in main.rs and update to pass max_entries parameter. Each subcommand handler must pass the resolved max_entries value from CLI/env/default.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:52.696617136-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.8","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:52.698259134-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.8","depends_on_id":"clipboard-tsd.3","type":"blocks","created_at":"2026-01-13T12:31:15.234173657-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"clipboard-tsd.9","title":"[#5] Update Daemon::new() to accept and forward max_entries","description":"Daemon creates Storage internally. Update Daemon::new() signature to accept max_entries and pass it through to Storage::new(). This ensures daemon respects configured limits.","status":"tombstone","priority":2,"issue_type":"task","owner":"me@tayloreernisse.com","created_at":"2026-01-13T12:30:52.996601436-05:00","created_by":"solsystemlabs","updated_at":"2026-01-13T15:11:43.82977094-05:00","dependencies":[{"issue_id":"clipboard-tsd.9","depends_on_id":"clipboard-tsd","type":"parent-child","created_at":"2026-01-13T12:30:52.998056244-05:00","created_by":"solsystemlabs"},{"issue_id":"clipboard-tsd.9","depends_on_id":"clipboard-tsd.3","type":"blocks","created_at":"2026-01-13T12:31:15.269344916-05:00","created_by":"solsystemlabs"}],"deleted_at":"2026-01-13T15:11:43.82977094-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
